[
    {
        "Method_body": "public static OAuth10aService createOAuthService(String apiKey, String sharedSecret, Integer connectTimeoutMs, Integer readTimeoutMs) {\n    JDKHttpClientConfig config = JDKHttpClientConfig.defaultConfig();\n    if (connectTimeoutMs != null) {\n        config.setConnectTimeout(connectTimeoutMs);\n    }\n    if (readTimeoutMs != null) {\n        config.setReadTimeout(readTimeoutMs);\n    }\n    ServiceBuilder serviceBuilder = new ServiceBuilder(apiKey).apiSecret(sharedSecret).httpClientConfig(config);\n    if (Flickr.debugRequest) {\n        serviceBuilder = serviceBuilder.debug();\n    }\n    return serviceBuilder.build(FlickrApi.instance());\n}",
        "all_field_declaration": "private static final Logger logger = LoggerFactory.getLogger(OAuthUtilities.class);",
        "sub_project_name": "boncey_Flickr4Java",
        "lineNumbers": "6",
        "Filed": "",
        "Parameter_type": "String,String,Integer,Integer",
        "Import_statements": "import com.flickr4java.flickr.Flickr;\nimport com.flickr4java.flickr.auth.Auth;\nimport com.github.scribejava.apis.FlickrApi;\nimport com.github.scribejava.core.builder.ServiceBuilder;\nimport com.github.scribejava.core.httpclient.jdk.JDKHttpClientConfig;\nimport com.github.scribejava.core.oauth.OAuth10aService;\n",
        "public_method_signature": "public static OAuth10aService createOAuthService(String apiKey, String sharedSecret, Integer connectTimeoutMs, Integer readTimeoutMs);\npublic static void signRequest(OAuth10aService service, OAuthRequest request, String proxyCredentials);\npublic static OAuthRequest buildNormalPostRequest(Map<String, ?> parameters, String url);\npublic static OAuthRequest buildMultipartRequest(Map<String, String> parameters, String url);",
        "public_field": "",
        "Method_statement": "createOAuthService(String apiKey, String sharedSecret, Integer connectTimeoutMs, Integer readTimeoutMs)",
        "Method_name": "createOAuthService",
        "Class_declaration": "public  final class OAuthUtilities {\n",
        "constructors": "private OAuthUtilities() {\n}",
        "all_method_signature": "private OAuthUtilities();\npublic static OAuth10aService createOAuthService(String apiKey, String sharedSecret, Integer connectTimeoutMs, Integer readTimeoutMs);\npublic static void signRequest(OAuth10aService service, OAuthRequest request, String proxyCredentials);\npublic static OAuthRequest buildNormalPostRequest(Map<String, ?> parameters, String url);\npublic static OAuthRequest buildMultipartRequest(Map<String, String> parameters, String url);\nprivate static String getMultipartBoundary();",
        "Class_name": "OAuthUtilities",
        "project_path": "boncey_Flickr4Java###boncey_Flickr4Java/src/main/java/com/flickr4java/flickr/util/OAuthUtilities###createOAuthService",
        "Parameter_num": "4",
        "all_Import_statements": "import java.util.Map;\n\nimport java.util.UUID;\n\nimport org.slf4j.Logger;\n\nimport org.slf4j.LoggerFactory;\n\nimport com.flickr4java.flickr.Flickr;\n\nimport com.flickr4java.flickr.RequestContext;\n\nimport com.flickr4java.flickr.auth.Auth;\n\nimport com.github.scribejava.apis.FlickrApi;\n\nimport com.github.scribejava.core.builder.ServiceBuilder;\n\nimport com.github.scribejava.core.httpclient.jdk.JDKHttpClientConfig;\n\nimport com.github.scribejava.core.model.OAuth1AccessToken;\n\nimport com.github.scribejava.core.model.OAuthRequest;\n\nimport com.github.scribejava.core.model.Verb;\n\nimport com.github.scribejava.core.oauth.OAuth10aService;\n",
        "comment": "\n     * Creates a new OAuth 1.0.a service.\n     * \n     * @param apiKey OAuth API key\n     * @param sharedSecret OAuth API secret\n     * @param connectTimeoutMs connect timeout in milliseconds\n     * @param readTimeoutMs read timeout in milliseconds\n     *\n     * @return OAuth 1.0.a service\n     ",
        "packageName": "com.flickr4java.flickr.util",
        "method_signature": "public static OAuth10aService createOAuthService(String apiKey, String sharedSecret, Integer connectTimeoutMs, Integer readTimeoutMs);",
        "Junit_version": "4",
        "returnType": "OAuth10aService"
    },
    {
        "Method_body": "public static OAuthRequest buildMultipartRequest(Map<String, String> parameters, String url) {\n    OAuthRequest request = new OAuthRequest(Verb.POST, url);\n    String multipartBoundary = getMultipartBoundary();\n    request.initMultipartPayload(multipartBoundary);\n    request.addHeader(\"Content-Type\", \"multipart/form-data; boundary=\" + multipartBoundary);\n    parameters.entrySet().forEach(e -> request.addQuerystringParameter(e.getKey(), e.getValue()));\n    return request;\n}",
        "all_field_declaration": "private static final Logger logger = LoggerFactory.getLogger(OAuthUtilities.class);",
        "sub_project_name": "boncey_Flickr4Java",
        "lineNumbers": "6",
        "Filed": "",
        "Parameter_type": "Map<String, String>,String",
        "Import_statements": "import java.util.Map;\nimport com.flickr4java.flickr.auth.Auth;\nimport com.github.scribejava.core.model.OAuthRequest;\nimport com.github.scribejava.core.model.Verb;\n",
        "public_method_signature": "public static OAuth10aService createOAuthService(String apiKey, String sharedSecret, Integer connectTimeoutMs, Integer readTimeoutMs);\npublic static void signRequest(OAuth10aService service, OAuthRequest request, String proxyCredentials);\npublic static OAuthRequest buildNormalPostRequest(Map<String, ?> parameters, String url);\npublic static OAuthRequest buildMultipartRequest(Map<String, String> parameters, String url);",
        "public_field": "",
        "Method_statement": "buildMultipartRequest(Map<String, String> parameters, String url)",
        "Method_name": "buildMultipartRequest",
        "Class_declaration": "public  final class OAuthUtilities {\n",
        "constructors": "private OAuthUtilities() {\n}",
        "all_method_signature": "private OAuthUtilities();\npublic static OAuth10aService createOAuthService(String apiKey, String sharedSecret, Integer connectTimeoutMs, Integer readTimeoutMs);\npublic static void signRequest(OAuth10aService service, OAuthRequest request, String proxyCredentials);\npublic static OAuthRequest buildNormalPostRequest(Map<String, ?> parameters, String url);\npublic static OAuthRequest buildMultipartRequest(Map<String, String> parameters, String url);\nprivate static String getMultipartBoundary();",
        "Class_name": "OAuthUtilities",
        "project_path": "boncey_Flickr4Java###boncey_Flickr4Java/src/main/java/com/flickr4java/flickr/util/OAuthUtilities###buildMultipartRequest",
        "Parameter_num": "2",
        "all_Import_statements": "import java.util.Map;\n\nimport java.util.UUID;\n\nimport org.slf4j.Logger;\n\nimport org.slf4j.LoggerFactory;\n\nimport com.flickr4java.flickr.Flickr;\n\nimport com.flickr4java.flickr.RequestContext;\n\nimport com.flickr4java.flickr.auth.Auth;\n\nimport com.github.scribejava.apis.FlickrApi;\n\nimport com.github.scribejava.core.builder.ServiceBuilder;\n\nimport com.github.scribejava.core.httpclient.jdk.JDKHttpClientConfig;\n\nimport com.github.scribejava.core.model.OAuth1AccessToken;\n\nimport com.github.scribejava.core.model.OAuthRequest;\n\nimport com.github.scribejava.core.model.Verb;\n\nimport com.github.scribejava.core.oauth.OAuth10aService;\n",
        "comment": "\n     * Builds a multipart POST request.\n     *\n     * @param parameters QueryString parameters\n     * @param url URL\n     * @return OAuth request\n     ",
        "packageName": "com.flickr4java.flickr.util",
        "method_signature": "public static OAuthRequest buildMultipartRequest(Map<String, String> parameters, String url);",
        "Junit_version": "4",
        "returnType": "OAuthRequest"
    },
    {
        "Method_body": "public static OAuthRequest buildNormalPostRequest(Map<String, ?> parameters, String url) {\n    OAuthRequest request = new OAuthRequest(Verb.POST, url);\n    parameters.entrySet().forEach(e -> request.addBodyParameter(e.getKey(), String.valueOf(e.getValue())));\n    return request;\n}",
        "all_field_declaration": "private static final Logger logger = LoggerFactory.getLogger(OAuthUtilities.class);",
        "sub_project_name": "boncey_Flickr4Java",
        "lineNumbers": "3",
        "Filed": "",
        "Parameter_type": "Map<String, ?>,String",
        "Import_statements": "import java.util.Map;\nimport com.flickr4java.flickr.auth.Auth;\nimport com.github.scribejava.core.model.OAuthRequest;\nimport com.github.scribejava.core.model.Verb;\n",
        "public_method_signature": "public static OAuth10aService createOAuthService(String apiKey, String sharedSecret, Integer connectTimeoutMs, Integer readTimeoutMs);\npublic static void signRequest(OAuth10aService service, OAuthRequest request, String proxyCredentials);\npublic static OAuthRequest buildNormalPostRequest(Map<String, ?> parameters, String url);\npublic static OAuthRequest buildMultipartRequest(Map<String, String> parameters, String url);",
        "public_field": "",
        "Method_statement": "buildNormalPostRequest(Map<String, ?> parameters, String url)",
        "Method_name": "buildNormalPostRequest",
        "Class_declaration": "public  final class OAuthUtilities {\n",
        "constructors": "private OAuthUtilities() {\n}",
        "all_method_signature": "private OAuthUtilities();\npublic static OAuth10aService createOAuthService(String apiKey, String sharedSecret, Integer connectTimeoutMs, Integer readTimeoutMs);\npublic static void signRequest(OAuth10aService service, OAuthRequest request, String proxyCredentials);\npublic static OAuthRequest buildNormalPostRequest(Map<String, ?> parameters, String url);\npublic static OAuthRequest buildMultipartRequest(Map<String, String> parameters, String url);\nprivate static String getMultipartBoundary();",
        "Class_name": "OAuthUtilities",
        "project_path": "boncey_Flickr4Java###boncey_Flickr4Java/src/main/java/com/flickr4java/flickr/util/OAuthUtilities###buildNormalPostRequest",
        "Parameter_num": "2",
        "all_Import_statements": "import java.util.Map;\n\nimport java.util.UUID;\n\nimport org.slf4j.Logger;\n\nimport org.slf4j.LoggerFactory;\n\nimport com.flickr4java.flickr.Flickr;\n\nimport com.flickr4java.flickr.RequestContext;\n\nimport com.flickr4java.flickr.auth.Auth;\n\nimport com.github.scribejava.apis.FlickrApi;\n\nimport com.github.scribejava.core.builder.ServiceBuilder;\n\nimport com.github.scribejava.core.httpclient.jdk.JDKHttpClientConfig;\n\nimport com.github.scribejava.core.model.OAuth1AccessToken;\n\nimport com.github.scribejava.core.model.OAuthRequest;\n\nimport com.github.scribejava.core.model.Verb;\n\nimport com.github.scribejava.core.oauth.OAuth10aService;\n",
        "comment": "\n     * Builds a normal POST request.\n     *\n     * @param parameters body parameters\n     * @param url URL\n     * @return OAuth request\n     ",
        "packageName": "com.flickr4java.flickr.util",
        "method_signature": "public static OAuthRequest buildNormalPostRequest(Map<String, ?> parameters, String url);",
        "Junit_version": "4",
        "returnType": "OAuthRequest"
    },
    {
        "Method_body": "public static DateTime date(Date date) {\n    if (date == null) {\n        return null;\n    }\n    if (date instanceof DateTime) {\n        return (DateTime) date;\n    }\n    return dateNew(date);\n}",
        "all_field_declaration": "/**\n * java.util.Date EEE MMM zzz 缩写数组\n */\nprivate final static String[] wtb = { // \n// 星期\n\"sun\", // 星期\n\"mon\", // 星期\n\"tue\", // 星期\n\"wed\", // 星期\n\"thu\", // 星期\n\"fri\", // 星期\n\"sat\", // 月份\n\"jan\", // 月份\n\"feb\", // 月份\n\"mar\", // 月份\n\"apr\", // 月份\n\"may\", // 月份\n\"jun\", // 月份\n\"jul\", // 月份\n\"aug\", // 月份\n\"sep\", // 月份\n\"oct\", // 月份\n\"nov\", // 月份\n\"dec\", // 时间标准\n\"gmt\", // 时间标准\n\"ut\", // 时间标准\n\"utc\", // 时间标准\n\"est\", // 时间标准\n\"edt\", // 时间标准\n\"cst\", // 时间标准\n\"cdt\", // 时间标准\n\"mst\", // 时间标准\n\"mdt\", // 时间标准\n\"pst\", // 时间标准\n\"pdt\" };",
        "sub_project_name": "hutool-core",
        "lineNumbers": "3",
        "Filed": "",
        "Parameter_type": "Date",
        "Import_statements": "",
        "public_method_signature": "public static DateTime date();\npublic static DateTime dateSecond();\npublic static DateTime date(Date date);\npublic static DateTime dateNew(Date date);\npublic static DateTime date(long date);\npublic static DateTime date(Calendar calendar);\npublic static DateTime date(TemporalAccessor temporalAccessor);\npublic static long current();\npublic static long currentSeconds();\npublic static String now();\npublic static String today();\npublic static int year(Date date);\npublic static int quarter(Date date);\npublic static Quarter quarterEnum(Date date);\npublic static int month(Date date);\npublic static Month monthEnum(Date date);\npublic static int weekOfYear(Date date);\npublic static int weekOfMonth(Date date);\npublic static int dayOfMonth(Date date);\npublic static int dayOfYear(Date date);\npublic static int dayOfWeek(Date date);\npublic static Week dayOfWeekEnum(Date date);\npublic static boolean isWeekend(Date date);\npublic static int hour(Date date, boolean is24HourClock);\npublic static int minute(Date date);\npublic static int second(Date date);\npublic static int millisecond(Date date);\npublic static boolean isAM(Date date);\npublic static boolean isPM(Date date);\npublic static int thisYear();\npublic static int thisMonth();\npublic static Month thisMonthEnum();\npublic static int thisWeekOfYear();\npublic static int thisWeekOfMonth();\npublic static int thisDayOfMonth();\npublic static int thisDayOfWeek();\npublic static Week thisDayOfWeekEnum();\npublic static int thisHour(boolean is24HourClock);\npublic static int thisMinute();\npublic static int thisSecond();\npublic static int thisMillisecond();\npublic static String yearAndQuarter(Date date);\npublic static LinkedHashSet<String> yearAndQuarter(Date startDate, Date endDate);\npublic static String formatLocalDateTime(LocalDateTime localDateTime);\npublic static String format(LocalDateTime localDateTime, String format);\npublic static String format(Date date, String format);\npublic static String format(Date date, DatePrinter format);\npublic static String format(Date date, DateFormat format);\npublic static String format(Date date, DateTimeFormatter format);\npublic static String formatDateTime(Date date);\npublic static String formatDate(Date date);\npublic static String formatTime(Date date);\npublic static String formatHttpDate(Date date);\npublic static String formatChineseDate(Date date, boolean isUppercase, boolean withTime);\npublic static LocalDateTime parseLocalDateTime(CharSequence dateStr);\npublic static LocalDateTime parseLocalDateTime(CharSequence dateStr, String format);\npublic static DateTime parse(CharSequence dateStr, DateFormat dateFormat);\npublic static DateTime parse(CharSequence dateStr, DateParser parser);\npublic static DateTime parse(CharSequence dateStr, DateParser parser, boolean lenient);\npublic static DateTime parse(CharSequence dateStr, DateTimeFormatter formatter);\npublic static DateTime parse(CharSequence dateStr, String format);\npublic static DateTime parse(CharSequence dateStr, String format, Locale locale);\npublic static DateTime parse(String str, String... parsePatterns) throws DateException;\npublic static DateTime parseDateTime(CharSequence dateString);\npublic static DateTime parseDate(CharSequence dateString);\npublic static DateTime parseTime(CharSequence timeString);\npublic static DateTime parseTimeToday(CharSequence timeString);\npublic static DateTime parseUTC(String utcString);\npublic static DateTime parseCST(CharSequence cstString);\npublic static DateTime parse(CharSequence dateCharSequence);\npublic static DateTime truncate(Date date, DateField dateField);\npublic static DateTime round(Date date, DateField dateField);\npublic static DateTime ceiling(Date date, DateField dateField);\npublic static DateTime ceiling(Date date, DateField dateField, boolean truncateMillisecond);\npublic static DateTime beginOfSecond(Date date);\npublic static DateTime endOfSecond(Date date);\npublic static DateTime beginOfHour(Date date);\npublic static DateTime endOfHour(Date date);\npublic static DateTime beginOfMinute(Date date);\npublic static DateTime endOfMinute(Date date);\npublic static DateTime beginOfDay(Date date);\npublic static DateTime endOfDay(Date date);\npublic static DateTime beginOfWeek(Date date);\npublic static DateTime beginOfWeek(Date date, boolean isMondayAsFirstDay);\npublic static DateTime endOfWeek(Date date);\npublic static DateTime endOfWeek(Date date, boolean isSundayAsLastDay);\npublic static DateTime beginOfMonth(Date date);\npublic static DateTime endOfMonth(Date date);\npublic static DateTime beginOfQuarter(Date date);\npublic static DateTime endOfQuarter(Date date);\npublic static DateTime beginOfYear(Date date);\npublic static DateTime endOfYear(Date date);\npublic static DateTime yesterday();\npublic static DateTime tomorrow();\npublic static DateTime lastWeek();\npublic static DateTime nextWeek();\npublic static DateTime lastMonth();\npublic static DateTime nextMonth();\npublic static DateTime offsetMillisecond(Date date, int offset);\npublic static DateTime offsetSecond(Date date, int offset);\npublic static DateTime offsetMinute(Date date, int offset);\npublic static DateTime offsetHour(Date date, int offset);\npublic static DateTime offsetDay(Date date, int offset);\npublic static DateTime offsetWeek(Date date, int offset);\npublic static DateTime offsetMonth(Date date, int offset);\npublic static DateTime offset(Date date, DateField dateField, int offset);\npublic static long between(Date beginDate, Date endDate, DateUnit unit);\npublic static long between(Date beginDate, Date endDate, DateUnit unit, boolean isAbs);\npublic static long betweenMs(Date beginDate, Date endDate);\npublic static long betweenDay(Date beginDate, Date endDate, boolean isReset);\npublic static long betweenWeek(Date beginDate, Date endDate, boolean isReset);\npublic static long betweenMonth(Date beginDate, Date endDate, boolean isReset);\npublic static long betweenYear(Date beginDate, Date endDate, boolean isReset);\npublic static String formatBetween(Date beginDate, Date endDate, BetweenFormatter.Level level);\npublic static String formatBetween(Date beginDate, Date endDate);\npublic static String formatBetween(long betweenMs, BetweenFormatter.Level level);\npublic static String formatBetween(long betweenMs);\npublic static boolean isIn(Date date, Date beginDate, Date endDate);\npublic static boolean isSameTime(Date date1, Date date2);\npublic static boolean isSameDay(final Date date1, final Date date2);\npublic static boolean isSameWeek(final Date date1, final Date date2, boolean isMon);\npublic static boolean isSameMonth(final Date date1, final Date date2);\npublic static long spendNt(long preTime);\npublic static long spendMs(long preTime);\npublic static int toIntSecond(Date date);\npublic static TimeInterval timer();\npublic static TimeInterval timer(boolean isNano);\npublic static StopWatch createStopWatch();\npublic static StopWatch createStopWatch(String id);\npublic static int ageOfNow(String birthDay);\npublic static int ageOfNow(Date birthDay);\npublic static boolean isLeapYear(int year);\npublic static int age(Date birthday, Date dateToCompare);\npublic static boolean isExpired(Date startDate, DateField dateField, int timeLength, Date endDate);\npublic static boolean isExpired(Date startDate, Date endDate, Date checkDate);\npublic static int timeToSecond(String timeStr);\npublic static String secondToTime(int seconds);\npublic static DateRange range(Date start, Date end, final DateField unit);\npublic static List<DateTime> rangeContains(DateRange start, DateRange end);\npublic static List<DateTime> rangeNotContains(DateRange start, DateRange end);\npublic static List<T> rangeFunc(Date start, Date end, final DateField unit, Function<Date, T> func);\npublic static void rangeConsume(Date start, Date end, final DateField unit, Consumer<Date> consumer);\npublic static List<DateTime> rangeToList(Date start, Date end, DateField unit);\npublic static List<DateTime> rangeToList(Date start, Date end, final DateField unit, int step);\npublic static String getZodiac(int month, int day);\npublic static String getChineseZodiac(int year);\npublic static int compare(Date date1, Date date2);\npublic static int compare(Date date1, Date date2, String format);\npublic static long nanosToMillis(long duration);\npublic static double nanosToSeconds(long duration);\npublic static Instant toInstant(Date date);\npublic static Instant toInstant(TemporalAccessor temporalAccessor);\npublic static LocalDateTime toLocalDateTime(Instant instant);\npublic static LocalDateTime toLocalDateTime(Date date);\npublic static DateTime convertTimeZone(Date date, ZoneId zoneId);\npublic static DateTime convertTimeZone(Date date, TimeZone timeZone);\npublic static int lengthOfYear(int year);\npublic static int lengthOfMonth(int month, boolean isLeapYear);\npublic static SimpleDateFormat newSimpleFormat(String pattern);\npublic static SimpleDateFormat newSimpleFormat(String pattern, Locale locale, TimeZone timeZone);\npublic static String getShotName(TimeUnit unit);\npublic static boolean isOverlap(Date realStartTime, Date realEndTime, Date startTime, Date endTime);\npublic static boolean isLastDayOfMonth(Date date);\npublic static int getLastDayOfMonth(Date date);",
        "public_field": "",
        "Method_statement": "date(Date date)",
        "Method_name": "date",
        "Class_declaration": "public class DateUtil {\n",
        "constructors": "",
        "all_method_signature": "public static DateTime date();\npublic static DateTime dateSecond();\npublic static DateTime date(Date date);\npublic static DateTime dateNew(Date date);\npublic static DateTime date(long date);\npublic static DateTime date(Calendar calendar);\npublic static DateTime date(TemporalAccessor temporalAccessor);\npublic static long current();\npublic static long currentSeconds();\npublic static String now();\npublic static String today();\npublic static int year(Date date);\npublic static int quarter(Date date);\npublic static Quarter quarterEnum(Date date);\npublic static int month(Date date);\npublic static Month monthEnum(Date date);\npublic static int weekOfYear(Date date);\npublic static int weekOfMonth(Date date);\npublic static int dayOfMonth(Date date);\npublic static int dayOfYear(Date date);\npublic static int dayOfWeek(Date date);\npublic static Week dayOfWeekEnum(Date date);\npublic static boolean isWeekend(Date date);\npublic static int hour(Date date, boolean is24HourClock);\npublic static int minute(Date date);\npublic static int second(Date date);\npublic static int millisecond(Date date);\npublic static boolean isAM(Date date);\npublic static boolean isPM(Date date);\npublic static int thisYear();\npublic static int thisMonth();\npublic static Month thisMonthEnum();\npublic static int thisWeekOfYear();\npublic static int thisWeekOfMonth();\npublic static int thisDayOfMonth();\npublic static int thisDayOfWeek();\npublic static Week thisDayOfWeekEnum();\npublic static int thisHour(boolean is24HourClock);\npublic static int thisMinute();\npublic static int thisSecond();\npublic static int thisMillisecond();\npublic static String yearAndQuarter(Date date);\npublic static LinkedHashSet<String> yearAndQuarter(Date startDate, Date endDate);\npublic static String formatLocalDateTime(LocalDateTime localDateTime);\npublic static String format(LocalDateTime localDateTime, String format);\npublic static String format(Date date, String format);\npublic static String format(Date date, DatePrinter format);\npublic static String format(Date date, DateFormat format);\npublic static String format(Date date, DateTimeFormatter format);\npublic static String formatDateTime(Date date);\npublic static String formatDate(Date date);\npublic static String formatTime(Date date);\npublic static String formatHttpDate(Date date);\npublic static String formatChineseDate(Date date, boolean isUppercase, boolean withTime);\npublic static LocalDateTime parseLocalDateTime(CharSequence dateStr);\npublic static LocalDateTime parseLocalDateTime(CharSequence dateStr, String format);\npublic static DateTime parse(CharSequence dateStr, DateFormat dateFormat);\npublic static DateTime parse(CharSequence dateStr, DateParser parser);\npublic static DateTime parse(CharSequence dateStr, DateParser parser, boolean lenient);\npublic static DateTime parse(CharSequence dateStr, DateTimeFormatter formatter);\npublic static DateTime parse(CharSequence dateStr, String format);\npublic static DateTime parse(CharSequence dateStr, String format, Locale locale);\npublic static DateTime parse(String str, String... parsePatterns) throws DateException;\npublic static DateTime parseDateTime(CharSequence dateString);\npublic static DateTime parseDate(CharSequence dateString);\npublic static DateTime parseTime(CharSequence timeString);\npublic static DateTime parseTimeToday(CharSequence timeString);\npublic static DateTime parseUTC(String utcString);\npublic static DateTime parseCST(CharSequence cstString);\npublic static DateTime parse(CharSequence dateCharSequence);\npublic static DateTime truncate(Date date, DateField dateField);\npublic static DateTime round(Date date, DateField dateField);\npublic static DateTime ceiling(Date date, DateField dateField);\npublic static DateTime ceiling(Date date, DateField dateField, boolean truncateMillisecond);\npublic static DateTime beginOfSecond(Date date);\npublic static DateTime endOfSecond(Date date);\npublic static DateTime beginOfHour(Date date);\npublic static DateTime endOfHour(Date date);\npublic static DateTime beginOfMinute(Date date);\npublic static DateTime endOfMinute(Date date);\npublic static DateTime beginOfDay(Date date);\npublic static DateTime endOfDay(Date date);\npublic static DateTime beginOfWeek(Date date);\npublic static DateTime beginOfWeek(Date date, boolean isMondayAsFirstDay);\npublic static DateTime endOfWeek(Date date);\npublic static DateTime endOfWeek(Date date, boolean isSundayAsLastDay);\npublic static DateTime beginOfMonth(Date date);\npublic static DateTime endOfMonth(Date date);\npublic static DateTime beginOfQuarter(Date date);\npublic static DateTime endOfQuarter(Date date);\npublic static DateTime beginOfYear(Date date);\npublic static DateTime endOfYear(Date date);\npublic static DateTime yesterday();\npublic static DateTime tomorrow();\npublic static DateTime lastWeek();\npublic static DateTime nextWeek();\npublic static DateTime lastMonth();\npublic static DateTime nextMonth();\npublic static DateTime offsetMillisecond(Date date, int offset);\npublic static DateTime offsetSecond(Date date, int offset);\npublic static DateTime offsetMinute(Date date, int offset);\npublic static DateTime offsetHour(Date date, int offset);\npublic static DateTime offsetDay(Date date, int offset);\npublic static DateTime offsetWeek(Date date, int offset);\npublic static DateTime offsetMonth(Date date, int offset);\npublic static DateTime offset(Date date, DateField dateField, int offset);\npublic static long between(Date beginDate, Date endDate, DateUnit unit);\npublic static long between(Date beginDate, Date endDate, DateUnit unit, boolean isAbs);\npublic static long betweenMs(Date beginDate, Date endDate);\npublic static long betweenDay(Date beginDate, Date endDate, boolean isReset);\npublic static long betweenWeek(Date beginDate, Date endDate, boolean isReset);\npublic static long betweenMonth(Date beginDate, Date endDate, boolean isReset);\npublic static long betweenYear(Date beginDate, Date endDate, boolean isReset);\npublic static String formatBetween(Date beginDate, Date endDate, BetweenFormatter.Level level);\npublic static String formatBetween(Date beginDate, Date endDate);\npublic static String formatBetween(long betweenMs, BetweenFormatter.Level level);\npublic static String formatBetween(long betweenMs);\npublic static boolean isIn(Date date, Date beginDate, Date endDate);\npublic static boolean isSameTime(Date date1, Date date2);\npublic static boolean isSameDay(final Date date1, final Date date2);\npublic static boolean isSameWeek(final Date date1, final Date date2, boolean isMon);\npublic static boolean isSameMonth(final Date date1, final Date date2);\npublic static long spendNt(long preTime);\npublic static long spendMs(long preTime);\npublic static int toIntSecond(Date date);\npublic static TimeInterval timer();\npublic static TimeInterval timer(boolean isNano);\npublic static StopWatch createStopWatch();\npublic static StopWatch createStopWatch(String id);\npublic static int ageOfNow(String birthDay);\npublic static int ageOfNow(Date birthDay);\npublic static boolean isLeapYear(int year);\npublic static int age(Date birthday, Date dateToCompare);\npublic static boolean isExpired(Date startDate, DateField dateField, int timeLength, Date endDate);\npublic static boolean isExpired(Date startDate, Date endDate, Date checkDate);\npublic static int timeToSecond(String timeStr);\npublic static String secondToTime(int seconds);\npublic static DateRange range(Date start, Date end, final DateField unit);\npublic static List<DateTime> rangeContains(DateRange start, DateRange end);\npublic static List<DateTime> rangeNotContains(DateRange start, DateRange end);\npublic static List<T> rangeFunc(Date start, Date end, final DateField unit, Function<Date, T> func);\npublic static void rangeConsume(Date start, Date end, final DateField unit, Consumer<Date> consumer);\npublic static List<DateTime> rangeToList(Date start, Date end, DateField unit);\npublic static List<DateTime> rangeToList(Date start, Date end, final DateField unit, int step);\npublic static String getZodiac(int month, int day);\npublic static String getChineseZodiac(int year);\npublic static int compare(Date date1, Date date2);\npublic static int compare(Date date1, Date date2, String format);\npublic static long nanosToMillis(long duration);\npublic static double nanosToSeconds(long duration);\npublic static Instant toInstant(Date date);\npublic static Instant toInstant(TemporalAccessor temporalAccessor);\npublic static LocalDateTime toLocalDateTime(Instant instant);\npublic static LocalDateTime toLocalDateTime(Date date);\npublic static DateTime convertTimeZone(Date date, ZoneId zoneId);\npublic static DateTime convertTimeZone(Date date, TimeZone timeZone);\npublic static int lengthOfYear(int year);\npublic static int lengthOfMonth(int month, boolean isLeapYear);\npublic static SimpleDateFormat newSimpleFormat(String pattern);\npublic static SimpleDateFormat newSimpleFormat(String pattern, Locale locale, TimeZone timeZone);\npublic static String getShotName(TimeUnit unit);\npublic static boolean isOverlap(Date realStartTime, Date realEndTime, Date startTime, Date endTime);\npublic static boolean isLastDayOfMonth(Date date);\npublic static int getLastDayOfMonth(Date date);\nprivate static String normalize(CharSequence dateStr);\nprivate static String normalizeMillSeconds(String dateStr, CharSequence before, CharSequence after);",
        "Class_name": "DateUtil",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/date/DateUtil###date",
        "Parameter_num": "1",
        "all_Import_statements": "import cn.hutool.core.collection.CollUtil;\n\nimport cn.hutool.core.comparator.CompareUtil;\n\nimport cn.hutool.core.date.format.DateParser;\n\nimport cn.hutool.core.date.format.DatePrinter;\n\nimport cn.hutool.core.date.format.FastDateFormat;\n\nimport cn.hutool.core.date.format.GlobalCustomFormat;\n\nimport cn.hutool.core.lang.Assert;\n\nimport cn.hutool.core.lang.PatternPool;\n\nimport cn.hutool.core.util.CharUtil;\n\nimport cn.hutool.core.util.NumberUtil;\n\nimport cn.hutool.core.util.ReUtil;\n\nimport cn.hutool.core.util.StrUtil;\n\nimport java.text.DateFormat;\n\nimport java.text.SimpleDateFormat;\n\nimport java.time.Instant;\n\nimport java.time.LocalDateTime;\n\nimport java.time.Year;\n\nimport java.time.ZoneId;\n\nimport java.time.format.DateTimeFormatter;\n\nimport java.time.temporal.TemporalAccessor;\n\nimport java.util.*;\n\nimport java.util.concurrent.TimeUnit;\n\nimport java.util.function.Consumer;\n\nimport java.util.function.Function;\n\nimport java.util.stream.Collectors;\n",
        "comment": "\n\t * {@link Date}类型时间转为{@link DateTime}<br>\n\t * 如果date本身为DateTime对象，则返回强转后的对象，否则新建一个DateTime对象\n\t *\n\t * @param date Long类型Date（Unix时间戳），如果传入{@code null}，返回{@code null}\n\t * @return 时间对象\n\t * @since 3.0.7\n\t ",
        "packageName": "cn.hutool.core.date",
        "method_signature": "public static DateTime date(Date date);",
        "Junit_version": "5",
        "returnType": "DateTime"
    },
    {
        "Method_body": "public static int age(Date birthday, Date dateToCompare) {\n    Assert.notNull(birthday, \"Birthday can not be null !\");\n    if (null == dateToCompare) {\n        dateToCompare = date();\n    }\n    return age(birthday.getTime(), dateToCompare.getTime());\n}",
        "all_field_declaration": "/**\n * java.util.Date EEE MMM zzz 缩写数组\n */\nprivate final static String[] wtb = { // \n// 星期\n\"sun\", // 星期\n\"mon\", // 星期\n\"tue\", // 星期\n\"wed\", // 星期\n\"thu\", // 星期\n\"fri\", // 星期\n\"sat\", // 月份\n\"jan\", // 月份\n\"feb\", // 月份\n\"mar\", // 月份\n\"apr\", // 月份\n\"may\", // 月份\n\"jun\", // 月份\n\"jul\", // 月份\n\"aug\", // 月份\n\"sep\", // 月份\n\"oct\", // 月份\n\"nov\", // 月份\n\"dec\", // 时间标准\n\"gmt\", // 时间标准\n\"ut\", // 时间标准\n\"utc\", // 时间标准\n\"est\", // 时间标准\n\"edt\", // 时间标准\n\"cst\", // 时间标准\n\"cdt\", // 时间标准\n\"mst\", // 时间标准\n\"mdt\", // 时间标准\n\"pst\", // 时间标准\n\"pdt\" };",
        "sub_project_name": "hutool-core",
        "lineNumbers": "3",
        "Filed": "",
        "Parameter_type": "Date,Date",
        "Import_statements": "import cn.hutool.core.lang.Assert;\n",
        "public_method_signature": "public static DateTime date();\npublic static DateTime dateSecond();\npublic static DateTime date(Date date);\npublic static DateTime dateNew(Date date);\npublic static DateTime date(long date);\npublic static DateTime date(Calendar calendar);\npublic static DateTime date(TemporalAccessor temporalAccessor);\npublic static long current();\npublic static long currentSeconds();\npublic static String now();\npublic static String today();\npublic static int year(Date date);\npublic static int quarter(Date date);\npublic static Quarter quarterEnum(Date date);\npublic static int month(Date date);\npublic static Month monthEnum(Date date);\npublic static int weekOfYear(Date date);\npublic static int weekOfMonth(Date date);\npublic static int dayOfMonth(Date date);\npublic static int dayOfYear(Date date);\npublic static int dayOfWeek(Date date);\npublic static Week dayOfWeekEnum(Date date);\npublic static boolean isWeekend(Date date);\npublic static int hour(Date date, boolean is24HourClock);\npublic static int minute(Date date);\npublic static int second(Date date);\npublic static int millisecond(Date date);\npublic static boolean isAM(Date date);\npublic static boolean isPM(Date date);\npublic static int thisYear();\npublic static int thisMonth();\npublic static Month thisMonthEnum();\npublic static int thisWeekOfYear();\npublic static int thisWeekOfMonth();\npublic static int thisDayOfMonth();\npublic static int thisDayOfWeek();\npublic static Week thisDayOfWeekEnum();\npublic static int thisHour(boolean is24HourClock);\npublic static int thisMinute();\npublic static int thisSecond();\npublic static int thisMillisecond();\npublic static String yearAndQuarter(Date date);\npublic static LinkedHashSet<String> yearAndQuarter(Date startDate, Date endDate);\npublic static String formatLocalDateTime(LocalDateTime localDateTime);\npublic static String format(LocalDateTime localDateTime, String format);\npublic static String format(Date date, String format);\npublic static String format(Date date, DatePrinter format);\npublic static String format(Date date, DateFormat format);\npublic static String format(Date date, DateTimeFormatter format);\npublic static String formatDateTime(Date date);\npublic static String formatDate(Date date);\npublic static String formatTime(Date date);\npublic static String formatHttpDate(Date date);\npublic static String formatChineseDate(Date date, boolean isUppercase, boolean withTime);\npublic static LocalDateTime parseLocalDateTime(CharSequence dateStr);\npublic static LocalDateTime parseLocalDateTime(CharSequence dateStr, String format);\npublic static DateTime parse(CharSequence dateStr, DateFormat dateFormat);\npublic static DateTime parse(CharSequence dateStr, DateParser parser);\npublic static DateTime parse(CharSequence dateStr, DateParser parser, boolean lenient);\npublic static DateTime parse(CharSequence dateStr, DateTimeFormatter formatter);\npublic static DateTime parse(CharSequence dateStr, String format);\npublic static DateTime parse(CharSequence dateStr, String format, Locale locale);\npublic static DateTime parse(String str, String... parsePatterns) throws DateException;\npublic static DateTime parseDateTime(CharSequence dateString);\npublic static DateTime parseDate(CharSequence dateString);\npublic static DateTime parseTime(CharSequence timeString);\npublic static DateTime parseTimeToday(CharSequence timeString);\npublic static DateTime parseUTC(String utcString);\npublic static DateTime parseCST(CharSequence cstString);\npublic static DateTime parse(CharSequence dateCharSequence);\npublic static DateTime truncate(Date date, DateField dateField);\npublic static DateTime round(Date date, DateField dateField);\npublic static DateTime ceiling(Date date, DateField dateField);\npublic static DateTime ceiling(Date date, DateField dateField, boolean truncateMillisecond);\npublic static DateTime beginOfSecond(Date date);\npublic static DateTime endOfSecond(Date date);\npublic static DateTime beginOfHour(Date date);\npublic static DateTime endOfHour(Date date);\npublic static DateTime beginOfMinute(Date date);\npublic static DateTime endOfMinute(Date date);\npublic static DateTime beginOfDay(Date date);\npublic static DateTime endOfDay(Date date);\npublic static DateTime beginOfWeek(Date date);\npublic static DateTime beginOfWeek(Date date, boolean isMondayAsFirstDay);\npublic static DateTime endOfWeek(Date date);\npublic static DateTime endOfWeek(Date date, boolean isSundayAsLastDay);\npublic static DateTime beginOfMonth(Date date);\npublic static DateTime endOfMonth(Date date);\npublic static DateTime beginOfQuarter(Date date);\npublic static DateTime endOfQuarter(Date date);\npublic static DateTime beginOfYear(Date date);\npublic static DateTime endOfYear(Date date);\npublic static DateTime yesterday();\npublic static DateTime tomorrow();\npublic static DateTime lastWeek();\npublic static DateTime nextWeek();\npublic static DateTime lastMonth();\npublic static DateTime nextMonth();\npublic static DateTime offsetMillisecond(Date date, int offset);\npublic static DateTime offsetSecond(Date date, int offset);\npublic static DateTime offsetMinute(Date date, int offset);\npublic static DateTime offsetHour(Date date, int offset);\npublic static DateTime offsetDay(Date date, int offset);\npublic static DateTime offsetWeek(Date date, int offset);\npublic static DateTime offsetMonth(Date date, int offset);\npublic static DateTime offset(Date date, DateField dateField, int offset);\npublic static long between(Date beginDate, Date endDate, DateUnit unit);\npublic static long between(Date beginDate, Date endDate, DateUnit unit, boolean isAbs);\npublic static long betweenMs(Date beginDate, Date endDate);\npublic static long betweenDay(Date beginDate, Date endDate, boolean isReset);\npublic static long betweenWeek(Date beginDate, Date endDate, boolean isReset);\npublic static long betweenMonth(Date beginDate, Date endDate, boolean isReset);\npublic static long betweenYear(Date beginDate, Date endDate, boolean isReset);\npublic static String formatBetween(Date beginDate, Date endDate, BetweenFormatter.Level level);\npublic static String formatBetween(Date beginDate, Date endDate);\npublic static String formatBetween(long betweenMs, BetweenFormatter.Level level);\npublic static String formatBetween(long betweenMs);\npublic static boolean isIn(Date date, Date beginDate, Date endDate);\npublic static boolean isSameTime(Date date1, Date date2);\npublic static boolean isSameDay(final Date date1, final Date date2);\npublic static boolean isSameWeek(final Date date1, final Date date2, boolean isMon);\npublic static boolean isSameMonth(final Date date1, final Date date2);\npublic static long spendNt(long preTime);\npublic static long spendMs(long preTime);\npublic static int toIntSecond(Date date);\npublic static TimeInterval timer();\npublic static TimeInterval timer(boolean isNano);\npublic static StopWatch createStopWatch();\npublic static StopWatch createStopWatch(String id);\npublic static int ageOfNow(String birthDay);\npublic static int ageOfNow(Date birthDay);\npublic static boolean isLeapYear(int year);\npublic static int age(Date birthday, Date dateToCompare);\npublic static boolean isExpired(Date startDate, DateField dateField, int timeLength, Date endDate);\npublic static boolean isExpired(Date startDate, Date endDate, Date checkDate);\npublic static int timeToSecond(String timeStr);\npublic static String secondToTime(int seconds);\npublic static DateRange range(Date start, Date end, final DateField unit);\npublic static List<DateTime> rangeContains(DateRange start, DateRange end);\npublic static List<DateTime> rangeNotContains(DateRange start, DateRange end);\npublic static List<T> rangeFunc(Date start, Date end, final DateField unit, Function<Date, T> func);\npublic static void rangeConsume(Date start, Date end, final DateField unit, Consumer<Date> consumer);\npublic static List<DateTime> rangeToList(Date start, Date end, DateField unit);\npublic static List<DateTime> rangeToList(Date start, Date end, final DateField unit, int step);\npublic static String getZodiac(int month, int day);\npublic static String getChineseZodiac(int year);\npublic static int compare(Date date1, Date date2);\npublic static int compare(Date date1, Date date2, String format);\npublic static long nanosToMillis(long duration);\npublic static double nanosToSeconds(long duration);\npublic static Instant toInstant(Date date);\npublic static Instant toInstant(TemporalAccessor temporalAccessor);\npublic static LocalDateTime toLocalDateTime(Instant instant);\npublic static LocalDateTime toLocalDateTime(Date date);\npublic static DateTime convertTimeZone(Date date, ZoneId zoneId);\npublic static DateTime convertTimeZone(Date date, TimeZone timeZone);\npublic static int lengthOfYear(int year);\npublic static int lengthOfMonth(int month, boolean isLeapYear);\npublic static SimpleDateFormat newSimpleFormat(String pattern);\npublic static SimpleDateFormat newSimpleFormat(String pattern, Locale locale, TimeZone timeZone);\npublic static String getShotName(TimeUnit unit);\npublic static boolean isOverlap(Date realStartTime, Date realEndTime, Date startTime, Date endTime);\npublic static boolean isLastDayOfMonth(Date date);\npublic static int getLastDayOfMonth(Date date);",
        "public_field": "",
        "Method_statement": "age(Date birthday, Date dateToCompare)",
        "Method_name": "age",
        "Class_declaration": "public class DateUtil {\n",
        "constructors": "",
        "all_method_signature": "public static DateTime date();\npublic static DateTime dateSecond();\npublic static DateTime date(Date date);\npublic static DateTime dateNew(Date date);\npublic static DateTime date(long date);\npublic static DateTime date(Calendar calendar);\npublic static DateTime date(TemporalAccessor temporalAccessor);\npublic static long current();\npublic static long currentSeconds();\npublic static String now();\npublic static String today();\npublic static int year(Date date);\npublic static int quarter(Date date);\npublic static Quarter quarterEnum(Date date);\npublic static int month(Date date);\npublic static Month monthEnum(Date date);\npublic static int weekOfYear(Date date);\npublic static int weekOfMonth(Date date);\npublic static int dayOfMonth(Date date);\npublic static int dayOfYear(Date date);\npublic static int dayOfWeek(Date date);\npublic static Week dayOfWeekEnum(Date date);\npublic static boolean isWeekend(Date date);\npublic static int hour(Date date, boolean is24HourClock);\npublic static int minute(Date date);\npublic static int second(Date date);\npublic static int millisecond(Date date);\npublic static boolean isAM(Date date);\npublic static boolean isPM(Date date);\npublic static int thisYear();\npublic static int thisMonth();\npublic static Month thisMonthEnum();\npublic static int thisWeekOfYear();\npublic static int thisWeekOfMonth();\npublic static int thisDayOfMonth();\npublic static int thisDayOfWeek();\npublic static Week thisDayOfWeekEnum();\npublic static int thisHour(boolean is24HourClock);\npublic static int thisMinute();\npublic static int thisSecond();\npublic static int thisMillisecond();\npublic static String yearAndQuarter(Date date);\npublic static LinkedHashSet<String> yearAndQuarter(Date startDate, Date endDate);\npublic static String formatLocalDateTime(LocalDateTime localDateTime);\npublic static String format(LocalDateTime localDateTime, String format);\npublic static String format(Date date, String format);\npublic static String format(Date date, DatePrinter format);\npublic static String format(Date date, DateFormat format);\npublic static String format(Date date, DateTimeFormatter format);\npublic static String formatDateTime(Date date);\npublic static String formatDate(Date date);\npublic static String formatTime(Date date);\npublic static String formatHttpDate(Date date);\npublic static String formatChineseDate(Date date, boolean isUppercase, boolean withTime);\npublic static LocalDateTime parseLocalDateTime(CharSequence dateStr);\npublic static LocalDateTime parseLocalDateTime(CharSequence dateStr, String format);\npublic static DateTime parse(CharSequence dateStr, DateFormat dateFormat);\npublic static DateTime parse(CharSequence dateStr, DateParser parser);\npublic static DateTime parse(CharSequence dateStr, DateParser parser, boolean lenient);\npublic static DateTime parse(CharSequence dateStr, DateTimeFormatter formatter);\npublic static DateTime parse(CharSequence dateStr, String format);\npublic static DateTime parse(CharSequence dateStr, String format, Locale locale);\npublic static DateTime parse(String str, String... parsePatterns) throws DateException;\npublic static DateTime parseDateTime(CharSequence dateString);\npublic static DateTime parseDate(CharSequence dateString);\npublic static DateTime parseTime(CharSequence timeString);\npublic static DateTime parseTimeToday(CharSequence timeString);\npublic static DateTime parseUTC(String utcString);\npublic static DateTime parseCST(CharSequence cstString);\npublic static DateTime parse(CharSequence dateCharSequence);\npublic static DateTime truncate(Date date, DateField dateField);\npublic static DateTime round(Date date, DateField dateField);\npublic static DateTime ceiling(Date date, DateField dateField);\npublic static DateTime ceiling(Date date, DateField dateField, boolean truncateMillisecond);\npublic static DateTime beginOfSecond(Date date);\npublic static DateTime endOfSecond(Date date);\npublic static DateTime beginOfHour(Date date);\npublic static DateTime endOfHour(Date date);\npublic static DateTime beginOfMinute(Date date);\npublic static DateTime endOfMinute(Date date);\npublic static DateTime beginOfDay(Date date);\npublic static DateTime endOfDay(Date date);\npublic static DateTime beginOfWeek(Date date);\npublic static DateTime beginOfWeek(Date date, boolean isMondayAsFirstDay);\npublic static DateTime endOfWeek(Date date);\npublic static DateTime endOfWeek(Date date, boolean isSundayAsLastDay);\npublic static DateTime beginOfMonth(Date date);\npublic static DateTime endOfMonth(Date date);\npublic static DateTime beginOfQuarter(Date date);\npublic static DateTime endOfQuarter(Date date);\npublic static DateTime beginOfYear(Date date);\npublic static DateTime endOfYear(Date date);\npublic static DateTime yesterday();\npublic static DateTime tomorrow();\npublic static DateTime lastWeek();\npublic static DateTime nextWeek();\npublic static DateTime lastMonth();\npublic static DateTime nextMonth();\npublic static DateTime offsetMillisecond(Date date, int offset);\npublic static DateTime offsetSecond(Date date, int offset);\npublic static DateTime offsetMinute(Date date, int offset);\npublic static DateTime offsetHour(Date date, int offset);\npublic static DateTime offsetDay(Date date, int offset);\npublic static DateTime offsetWeek(Date date, int offset);\npublic static DateTime offsetMonth(Date date, int offset);\npublic static DateTime offset(Date date, DateField dateField, int offset);\npublic static long between(Date beginDate, Date endDate, DateUnit unit);\npublic static long between(Date beginDate, Date endDate, DateUnit unit, boolean isAbs);\npublic static long betweenMs(Date beginDate, Date endDate);\npublic static long betweenDay(Date beginDate, Date endDate, boolean isReset);\npublic static long betweenWeek(Date beginDate, Date endDate, boolean isReset);\npublic static long betweenMonth(Date beginDate, Date endDate, boolean isReset);\npublic static long betweenYear(Date beginDate, Date endDate, boolean isReset);\npublic static String formatBetween(Date beginDate, Date endDate, BetweenFormatter.Level level);\npublic static String formatBetween(Date beginDate, Date endDate);\npublic static String formatBetween(long betweenMs, BetweenFormatter.Level level);\npublic static String formatBetween(long betweenMs);\npublic static boolean isIn(Date date, Date beginDate, Date endDate);\npublic static boolean isSameTime(Date date1, Date date2);\npublic static boolean isSameDay(final Date date1, final Date date2);\npublic static boolean isSameWeek(final Date date1, final Date date2, boolean isMon);\npublic static boolean isSameMonth(final Date date1, final Date date2);\npublic static long spendNt(long preTime);\npublic static long spendMs(long preTime);\npublic static int toIntSecond(Date date);\npublic static TimeInterval timer();\npublic static TimeInterval timer(boolean isNano);\npublic static StopWatch createStopWatch();\npublic static StopWatch createStopWatch(String id);\npublic static int ageOfNow(String birthDay);\npublic static int ageOfNow(Date birthDay);\npublic static boolean isLeapYear(int year);\npublic static int age(Date birthday, Date dateToCompare);\npublic static boolean isExpired(Date startDate, DateField dateField, int timeLength, Date endDate);\npublic static boolean isExpired(Date startDate, Date endDate, Date checkDate);\npublic static int timeToSecond(String timeStr);\npublic static String secondToTime(int seconds);\npublic static DateRange range(Date start, Date end, final DateField unit);\npublic static List<DateTime> rangeContains(DateRange start, DateRange end);\npublic static List<DateTime> rangeNotContains(DateRange start, DateRange end);\npublic static List<T> rangeFunc(Date start, Date end, final DateField unit, Function<Date, T> func);\npublic static void rangeConsume(Date start, Date end, final DateField unit, Consumer<Date> consumer);\npublic static List<DateTime> rangeToList(Date start, Date end, DateField unit);\npublic static List<DateTime> rangeToList(Date start, Date end, final DateField unit, int step);\npublic static String getZodiac(int month, int day);\npublic static String getChineseZodiac(int year);\npublic static int compare(Date date1, Date date2);\npublic static int compare(Date date1, Date date2, String format);\npublic static long nanosToMillis(long duration);\npublic static double nanosToSeconds(long duration);\npublic static Instant toInstant(Date date);\npublic static Instant toInstant(TemporalAccessor temporalAccessor);\npublic static LocalDateTime toLocalDateTime(Instant instant);\npublic static LocalDateTime toLocalDateTime(Date date);\npublic static DateTime convertTimeZone(Date date, ZoneId zoneId);\npublic static DateTime convertTimeZone(Date date, TimeZone timeZone);\npublic static int lengthOfYear(int year);\npublic static int lengthOfMonth(int month, boolean isLeapYear);\npublic static SimpleDateFormat newSimpleFormat(String pattern);\npublic static SimpleDateFormat newSimpleFormat(String pattern, Locale locale, TimeZone timeZone);\npublic static String getShotName(TimeUnit unit);\npublic static boolean isOverlap(Date realStartTime, Date realEndTime, Date startTime, Date endTime);\npublic static boolean isLastDayOfMonth(Date date);\npublic static int getLastDayOfMonth(Date date);\nprivate static String normalize(CharSequence dateStr);\nprivate static String normalizeMillSeconds(String dateStr, CharSequence before, CharSequence after);",
        "Class_name": "DateUtil",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/date/DateUtil###age",
        "Parameter_num": "2",
        "all_Import_statements": "import cn.hutool.core.collection.CollUtil;\n\nimport cn.hutool.core.comparator.CompareUtil;\n\nimport cn.hutool.core.date.format.DateParser;\n\nimport cn.hutool.core.date.format.DatePrinter;\n\nimport cn.hutool.core.date.format.FastDateFormat;\n\nimport cn.hutool.core.date.format.GlobalCustomFormat;\n\nimport cn.hutool.core.lang.Assert;\n\nimport cn.hutool.core.lang.PatternPool;\n\nimport cn.hutool.core.util.CharUtil;\n\nimport cn.hutool.core.util.NumberUtil;\n\nimport cn.hutool.core.util.ReUtil;\n\nimport cn.hutool.core.util.StrUtil;\n\nimport java.text.DateFormat;\n\nimport java.text.SimpleDateFormat;\n\nimport java.time.Instant;\n\nimport java.time.LocalDateTime;\n\nimport java.time.Year;\n\nimport java.time.ZoneId;\n\nimport java.time.format.DateTimeFormatter;\n\nimport java.time.temporal.TemporalAccessor;\n\nimport java.util.*;\n\nimport java.util.concurrent.TimeUnit;\n\nimport java.util.function.Consumer;\n\nimport java.util.function.Function;\n\nimport java.util.stream.Collectors;\n",
        "comment": "\n\t * 计算相对于dateToCompare的年龄，常用于计算指定生日在某年的年龄\n\t *\n\t * @param birthday      生日\n\t * @param dateToCompare 需要对比的日期\n\t * @return 年龄\n\t ",
        "packageName": "cn.hutool.core.date",
        "method_signature": "public static int age(Date birthday, Date dateToCompare);",
        "Junit_version": "5",
        "returnType": "int"
    },
    {
        "Method_body": "public static String format(long size) {\n    if (size <= 0) {\n        return \"0\";\n    }\n    int digitGroups = Math.min(DataUnit.UNIT_NAMES.length - 1, (int) (Math.log10(size) / Math.log10(1024)));\n    return new DecimalFormat(\"#,##0.##\").format(size / Math.pow(1024, digitGroups)) + \" \" + DataUnit.UNIT_NAMES[digitGroups];\n}",
        "all_field_declaration": "",
        "sub_project_name": "hutool-core",
        "lineNumbers": "3",
        "Filed": "",
        "Parameter_type": "long",
        "Import_statements": "import java.text.DecimalFormat;\n",
        "public_method_signature": "public static long parse(String text);\npublic static String format(long size);",
        "public_field": "",
        "Method_statement": "format(long size)",
        "Method_name": "format",
        "Class_declaration": "public class DataSizeUtil {\n",
        "constructors": "",
        "all_method_signature": "public static long parse(String text);\npublic static String format(long size);",
        "Class_name": "DataSizeUtil",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/io/unit/DataSizeUtil###format",
        "Parameter_num": "1",
        "all_Import_statements": "import java.text.DecimalFormat;\n",
        "comment": "\n\t * 可读的文件大小<br>\n\t * 参考 http://stackoverflow.com/questions/3263892/format-file-size-as-mb-gb-etc\n\t *\n\t * @param size Long类型大小\n\t * @return 大小\n\t ",
        "packageName": "cn.hutool.core.io.unit",
        "method_signature": "public static String format(long size);",
        "Junit_version": "5",
        "returnType": "String"
    },
    {
        "Method_body": "public static <K, V> void forEach(Map<K, V> map, KVConsumer<K, V> kvConsumer) {\n    if (map == null) {\n        return;\n    }\n    int index = 0;\n    for (Entry<K, V> entry : map.entrySet()) {\n        kvConsumer.accept(entry.getKey(), entry.getValue(), index);\n        index++;\n    }\n}",
        "all_field_declaration": "",
        "sub_project_name": "hutool-core",
        "lineNumbers": "3",
        "Filed": "",
        "Parameter_type": "Map<K, V>,KVConsumer<K, V>",
        "Import_statements": "import java.util.Map.Entry;\n",
        "public_method_signature": "public static Set<T> emptyIfNull(Set<T> set);\npublic static List<T> emptyIfNull(List<T> list);\npublic static Collection<T> union(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> union(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Set<T> unionDistinct(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static List<T> unionAll(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Collection<T> intersection(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> intersection(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Set<T> intersectionDistinct(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Collection<T> disjunction(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> subtract(Collection<T> coll1, Collection<T> coll2);\npublic static List<T> subtractToList(Collection<T> coll1, Collection<T> coll2);\npublic static boolean contains(Collection<?> collection, Object value);\npublic static boolean safeContains(Collection<?> collection, Object value);\npublic static boolean contains(Collection<T> collection, Predicate<? super T> containFunc);\npublic static boolean containsAny(Collection<?> coll1, Collection<?> coll2);\npublic static boolean containsAll(Collection<?> coll1, Collection<?> coll2);\npublic static Map<T, Integer> countMap(Iterable<T> collection);\npublic static String join(Iterable<T> iterable, CharSequence conjunction, Function<T, ? extends CharSequence> func);\npublic static String join(Iterable<T> iterable, CharSequence conjunction);\npublic static String join(Iterable<T> iterable, CharSequence conjunction, String prefix, String suffix);\npublic static String join(Iterator<T> iterator, CharSequence conjunction);\npublic static List<T> popPart(Stack<T> surplusAlaDatas, int partSize);\npublic static List<T> popPart(Deque<T> surplusAlaDatas, int partSize);\npublic static HashSet<T> newHashSet(T... ts);\npublic static LinkedHashSet<T> newLinkedHashSet(T... ts);\npublic static HashSet<T> set(boolean isSorted, T... ts);\npublic static HashSet<T> newHashSet(Collection<T> collection);\npublic static HashSet<T> newHashSet(boolean isSorted, Collection<T> collection);\npublic static HashSet<T> newHashSet(boolean isSorted, Iterator<T> iter);\npublic static HashSet<T> newHashSet(boolean isSorted, Enumeration<T> enumeration);\npublic static List<T> list(boolean isLinked);\npublic static List<T> list(boolean isLinked, T... values);\npublic static List<T> list(boolean isLinked, Collection<T> collection);\npublic static List<T> list(boolean isLinked, Iterable<T> iterable);\npublic static List<T> list(boolean isLinked, Iterator<T> iter);\npublic static List<T> list(boolean isLinked, Enumeration<T> enumeration);\npublic static ArrayList<T> newArrayList(T... values);\npublic static ArrayList<T> toList(T... values);\npublic static ArrayList<T> newArrayList(Collection<T> collection);\npublic static ArrayList<T> newArrayList(Iterable<T> iterable);\npublic static ArrayList<T> newArrayList(Iterator<T> iterator);\npublic static ArrayList<T> newArrayList(Enumeration<T> enumeration);\npublic static LinkedList<T> newLinkedList(T... values);\npublic static CopyOnWriteArrayList<T> newCopyOnWriteArrayList(Collection<T> collection);\npublic static BlockingQueue<T> newBlockingQueue(int capacity, boolean isLinked);\npublic static Collection<T> create(Class<?> collectionType);\npublic static Collection<T> create(Class<?> collectionType, Class<T> elementType);\npublic static ArrayList<T> distinct(Collection<T> collection);\npublic static List<T> distinct(Collection<T> collection, Function<T, K> uniqueGenerator, boolean override);\npublic static List<T> sub(List<T> list, int start, int end);\npublic static List<T> sub(List<T> list, int start, int end, int step);\npublic static List<T> sub(Collection<T> collection, int start, int end);\npublic static List<T> sub(Collection<T> collection, int start, int end, int step);\npublic static List<List<T>> splitList(List<T> list, int size);\npublic static List<List<T>> split(Collection<T> collection, int size);\npublic static Collection<T> edit(Collection<T> collection, Editor<T> editor);\npublic static Collection<T> filterNew(Collection<T> collection, Filter<T> filter);\npublic static T removeAny(T collection, E... elesRemoved);\npublic static T filter(T collection, final Filter<E> filter);\npublic static T removeNull(T collection);\npublic static T removeEmpty(T collection);\npublic static T removeBlank(T collection);\npublic static T removeWithAddIf(T targetCollection, T resultCollection, Predicate<? super E> predicate);\npublic static List<E> removeWithAddIf(T targetCollection, Predicate<? super E> predicate);\npublic static List<Object> extract(Iterable<?> collection, Editor<Object> editor);\npublic static List<Object> extract(Iterable<?> collection, Editor<Object> editor, boolean ignoreNull);\npublic static List<R> map(Iterable<T> collection, Function<? super T, ? extends R> func, boolean ignoreNull);\npublic static List<Object> getFieldValues(Iterable<?> collection, final String fieldName);\npublic static List<Object> getFieldValues(Iterable<?> collection, final String fieldName, boolean ignoreNull);\npublic static List<T> getFieldValues(Iterable<?> collection, final String fieldName, final Class<T> elementType);\npublic static Map<K, V> fieldValueMap(Iterable<V> iterable, String fieldName);\npublic static Map<K, V> fieldValueAsMap(Iterable<?> iterable, String fieldNameForKey, String fieldNameForValue);\npublic static T findOne(Iterable<T> collection, Filter<T> filter);\npublic static T findOneByField(Iterable<T> collection, final String fieldName, final Object fieldValue);\npublic static int count(Iterable<T> iterable, Matcher<T> matcher);\npublic static int indexOf(Collection<T> collection, Matcher<T> matcher);\npublic static int lastIndexOf(Collection<T> collection, Matcher<T> matcher);\npublic static int[] indexOfAll(Collection<T> collection, Matcher<T> matcher);\npublic static boolean isEmpty(Collection<?> collection);\npublic static T defaultIfEmpty(T collection, T defaultCollection);\npublic static T defaultIfEmpty(T collection, Supplier<? extends T> supplier);\npublic static boolean isEmpty(Iterable<?> iterable);\npublic static boolean isEmpty(Iterator<?> Iterator);\npublic static boolean isEmpty(Enumeration<?> enumeration);\npublic static boolean isEmpty(Map<?, ?> map);\npublic static boolean isNotEmpty(Collection<?> collection);\npublic static boolean isNotEmpty(Iterable<?> iterable);\npublic static boolean isNotEmpty(Iterator<?> Iterator);\npublic static boolean isNotEmpty(Enumeration<?> enumeration);\npublic static boolean hasNull(Iterable<?> iterable);\npublic static boolean isNotEmpty(Map<?, ?> map);\npublic static Map<String, String> zip(String keys, String values, String delimiter, boolean isOrder);\npublic static Map<String, String> zip(String keys, String values, String delimiter);\npublic static Map<K, V> zip(Collection<K> keys, Collection<V> values);\npublic static HashMap<K, V> toMap(Iterable<Entry<K, V>> entryIter);\npublic static HashMap<Object, Object> toMap(Object[] array);\npublic static TreeSet<T> toTreeSet(Collection<T> collection, Comparator<T> comparator);\npublic static Enumeration<E> asEnumeration(Iterator<E> iter);\npublic static Iterator<E> asIterator(Enumeration<E> e);\npublic static Iterable<E> asIterable(final Iterator<E> iter);\npublic static Collection<E> toCollection(Iterable<E> iterable);\npublic static Map<K, List<V>> toListMap(Iterable<? extends Map<K, V>> mapList);\npublic static List<Map<K, V>> toMapList(Map<K, ? extends Iterable<V>> listMap);\npublic static Map<K, V> toMap(Iterable<V> values, Map<K, V> map, Func1<V, K> keyFunc);\npublic static Map<K, V> toMap(Iterable<E> values, Map<K, V> map, Func1<E, K> keyFunc, Func1<E, V> valueFunc);\npublic static boolean addIfAbsent(Collection<T> collection, S object);\npublic static Collection<T> addAll(Collection<T> collection, Object value);\npublic static Collection<T> addAll(Collection<T> collection, Object value, Type elementType);\npublic static Collection<T> addAll(Collection<T> collection, Iterator<T> iterator);\npublic static Collection<T> addAll(Collection<T> collection, Iterable<T> iterable);\npublic static Collection<T> addAll(Collection<T> collection, Enumeration<T> enumeration);\npublic static Collection<T> addAll(Collection<T> collection, T[] values);\npublic static List<T> addAllIfNotContains(List<T> list, List<T> otherList);\npublic static T get(Collection<T> collection, int index);\npublic static List<T> getAny(Collection<T> collection, int... indexes);\npublic static T getFirst(Iterable<T> iterable);\npublic static T getFirst(Iterator<T> iterator);\npublic static T getLast(Collection<T> collection);\npublic static Class<?> getElementType(Iterable<?> iterable);\npublic static Class<?> getElementType(Iterator<?> iterator);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, K... keys);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, Iterable<K> keys);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, Iterator<K> keys);\npublic static List<T> sortPageAll(int pageNo, int pageSize, Comparator<T> comparator, Collection<T>... colls);\npublic static List<T> page(int pageNo, int pageSize, List<T> list);\npublic static List<T> sort(Collection<T> collection, Comparator<? super T> comparator);\npublic static List<T> sort(List<T> list, Comparator<? super T> c);\npublic static List<T> sortByProperty(Collection<T> collection, String property);\npublic static List<T> sortByProperty(List<T> list, String property);\npublic static List<String> sortByPinyin(Collection<String> collection);\npublic static List<String> sortByPinyin(List<String> list);\npublic static TreeMap<K, V> sort(Map<K, V> map, Comparator<? super K> comparator);\npublic static LinkedHashMap<K, V> sortToMap(Collection<Map.Entry<K, V>> entryCollection, Comparator<Map.Entry<K, V>> comparator);\npublic static LinkedHashMap<K, V> sortByEntry(Map<K, V> map, Comparator<Map.Entry<K, V>> comparator);\npublic static List<Entry<K, V>> sortEntryToList(Collection<Entry<K, V>> collection);\npublic static void forEach(Iterable<T> iterable, Consumer<T> consumer);\npublic static void forEach(Iterator<T> iterator, Consumer<T> consumer);\npublic static void forEach(Enumeration<T> enumeration, Consumer<T> consumer);\npublic static void forEach(Map<K, V> map, KVConsumer<K, V> kvConsumer);\npublic static List<List<T>> group(Collection<T> collection, Hash32<T> hash);\npublic static List<List<T>> groupByField(Collection<T> collection, final String fieldName);\npublic static List<T> reverse(List<T> list);\npublic static List<T> reverseNew(List<T> list);\npublic static List<T> setOrAppend(List<T> list, int index, T element);\npublic static Set<K> keySet(Collection<Map<K, ?>> mapCollection);\npublic static List<V> values(Collection<Map<?, V>> mapCollection);\npublic static T max(Collection<T> coll);\npublic static T min(Collection<T> coll);\npublic static Collection<T> unmodifiable(Collection<? extends T> c);\npublic static T empty(Class<?> collectionClass);\npublic static void clear(Collection<?>... collections);\npublic static void padLeft(List<T> list, int minLen, T padObj);\npublic static void padRight(Collection<T> list, int minLen, T padObj);\npublic static Collection<T> trans(Collection<F> collection, Function<? super F, ? extends T> function);\npublic static void setValueByMap(Iterable<E> iterable, Map<K, V> map, Function<E, K> keyGenerate, BiConsumer<E, V> biConsumer);\npublic static int size(final Object object);\npublic static boolean isEqualList(final Collection<?> list1, final Collection<?> list2);",
        "public_field": "",
        "Method_statement": "forEach(Map<K, V> map, KVConsumer<K, V> kvConsumer)",
        "Method_name": "forEach",
        "Class_declaration": "public class CollUtil {\n",
        "constructors": "",
        "all_method_signature": "public static Set<T> emptyIfNull(Set<T> set);\npublic static List<T> emptyIfNull(List<T> list);\npublic static Collection<T> union(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> union(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Set<T> unionDistinct(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static List<T> unionAll(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Collection<T> intersection(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> intersection(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Set<T> intersectionDistinct(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Collection<T> disjunction(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> subtract(Collection<T> coll1, Collection<T> coll2);\npublic static List<T> subtractToList(Collection<T> coll1, Collection<T> coll2);\npublic static boolean contains(Collection<?> collection, Object value);\npublic static boolean safeContains(Collection<?> collection, Object value);\npublic static boolean contains(Collection<T> collection, Predicate<? super T> containFunc);\npublic static boolean containsAny(Collection<?> coll1, Collection<?> coll2);\npublic static boolean containsAll(Collection<?> coll1, Collection<?> coll2);\npublic static Map<T, Integer> countMap(Iterable<T> collection);\npublic static String join(Iterable<T> iterable, CharSequence conjunction, Function<T, ? extends CharSequence> func);\npublic static String join(Iterable<T> iterable, CharSequence conjunction);\npublic static String join(Iterable<T> iterable, CharSequence conjunction, String prefix, String suffix);\npublic static String join(Iterator<T> iterator, CharSequence conjunction);\npublic static List<T> popPart(Stack<T> surplusAlaDatas, int partSize);\npublic static List<T> popPart(Deque<T> surplusAlaDatas, int partSize);\npublic static HashSet<T> newHashSet(T... ts);\npublic static LinkedHashSet<T> newLinkedHashSet(T... ts);\npublic static HashSet<T> set(boolean isSorted, T... ts);\npublic static HashSet<T> newHashSet(Collection<T> collection);\npublic static HashSet<T> newHashSet(boolean isSorted, Collection<T> collection);\npublic static HashSet<T> newHashSet(boolean isSorted, Iterator<T> iter);\npublic static HashSet<T> newHashSet(boolean isSorted, Enumeration<T> enumeration);\npublic static List<T> list(boolean isLinked);\npublic static List<T> list(boolean isLinked, T... values);\npublic static List<T> list(boolean isLinked, Collection<T> collection);\npublic static List<T> list(boolean isLinked, Iterable<T> iterable);\npublic static List<T> list(boolean isLinked, Iterator<T> iter);\npublic static List<T> list(boolean isLinked, Enumeration<T> enumeration);\npublic static ArrayList<T> newArrayList(T... values);\npublic static ArrayList<T> toList(T... values);\npublic static ArrayList<T> newArrayList(Collection<T> collection);\npublic static ArrayList<T> newArrayList(Iterable<T> iterable);\npublic static ArrayList<T> newArrayList(Iterator<T> iterator);\npublic static ArrayList<T> newArrayList(Enumeration<T> enumeration);\npublic static LinkedList<T> newLinkedList(T... values);\npublic static CopyOnWriteArrayList<T> newCopyOnWriteArrayList(Collection<T> collection);\npublic static BlockingQueue<T> newBlockingQueue(int capacity, boolean isLinked);\npublic static Collection<T> create(Class<?> collectionType);\npublic static Collection<T> create(Class<?> collectionType, Class<T> elementType);\npublic static ArrayList<T> distinct(Collection<T> collection);\npublic static List<T> distinct(Collection<T> collection, Function<T, K> uniqueGenerator, boolean override);\npublic static List<T> sub(List<T> list, int start, int end);\npublic static List<T> sub(List<T> list, int start, int end, int step);\npublic static List<T> sub(Collection<T> collection, int start, int end);\npublic static List<T> sub(Collection<T> collection, int start, int end, int step);\npublic static List<List<T>> splitList(List<T> list, int size);\npublic static List<List<T>> split(Collection<T> collection, int size);\npublic static Collection<T> edit(Collection<T> collection, Editor<T> editor);\npublic static Collection<T> filterNew(Collection<T> collection, Filter<T> filter);\npublic static T removeAny(T collection, E... elesRemoved);\npublic static T filter(T collection, final Filter<E> filter);\npublic static T removeNull(T collection);\npublic static T removeEmpty(T collection);\npublic static T removeBlank(T collection);\npublic static T removeWithAddIf(T targetCollection, T resultCollection, Predicate<? super E> predicate);\npublic static List<E> removeWithAddIf(T targetCollection, Predicate<? super E> predicate);\npublic static List<Object> extract(Iterable<?> collection, Editor<Object> editor);\npublic static List<Object> extract(Iterable<?> collection, Editor<Object> editor, boolean ignoreNull);\npublic static List<R> map(Iterable<T> collection, Function<? super T, ? extends R> func, boolean ignoreNull);\npublic static List<Object> getFieldValues(Iterable<?> collection, final String fieldName);\npublic static List<Object> getFieldValues(Iterable<?> collection, final String fieldName, boolean ignoreNull);\npublic static List<T> getFieldValues(Iterable<?> collection, final String fieldName, final Class<T> elementType);\npublic static Map<K, V> fieldValueMap(Iterable<V> iterable, String fieldName);\npublic static Map<K, V> fieldValueAsMap(Iterable<?> iterable, String fieldNameForKey, String fieldNameForValue);\npublic static T findOne(Iterable<T> collection, Filter<T> filter);\npublic static T findOneByField(Iterable<T> collection, final String fieldName, final Object fieldValue);\npublic static int count(Iterable<T> iterable, Matcher<T> matcher);\npublic static int indexOf(Collection<T> collection, Matcher<T> matcher);\npublic static int lastIndexOf(Collection<T> collection, Matcher<T> matcher);\npublic static int[] indexOfAll(Collection<T> collection, Matcher<T> matcher);\npublic static boolean isEmpty(Collection<?> collection);\npublic static T defaultIfEmpty(T collection, T defaultCollection);\npublic static T defaultIfEmpty(T collection, Supplier<? extends T> supplier);\npublic static boolean isEmpty(Iterable<?> iterable);\npublic static boolean isEmpty(Iterator<?> Iterator);\npublic static boolean isEmpty(Enumeration<?> enumeration);\npublic static boolean isEmpty(Map<?, ?> map);\npublic static boolean isNotEmpty(Collection<?> collection);\npublic static boolean isNotEmpty(Iterable<?> iterable);\npublic static boolean isNotEmpty(Iterator<?> Iterator);\npublic static boolean isNotEmpty(Enumeration<?> enumeration);\npublic static boolean hasNull(Iterable<?> iterable);\npublic static boolean isNotEmpty(Map<?, ?> map);\npublic static Map<String, String> zip(String keys, String values, String delimiter, boolean isOrder);\npublic static Map<String, String> zip(String keys, String values, String delimiter);\npublic static Map<K, V> zip(Collection<K> keys, Collection<V> values);\npublic static HashMap<K, V> toMap(Iterable<Entry<K, V>> entryIter);\npublic static HashMap<Object, Object> toMap(Object[] array);\npublic static TreeSet<T> toTreeSet(Collection<T> collection, Comparator<T> comparator);\npublic static Enumeration<E> asEnumeration(Iterator<E> iter);\npublic static Iterator<E> asIterator(Enumeration<E> e);\npublic static Iterable<E> asIterable(final Iterator<E> iter);\npublic static Collection<E> toCollection(Iterable<E> iterable);\npublic static Map<K, List<V>> toListMap(Iterable<? extends Map<K, V>> mapList);\npublic static List<Map<K, V>> toMapList(Map<K, ? extends Iterable<V>> listMap);\npublic static Map<K, V> toMap(Iterable<V> values, Map<K, V> map, Func1<V, K> keyFunc);\npublic static Map<K, V> toMap(Iterable<E> values, Map<K, V> map, Func1<E, K> keyFunc, Func1<E, V> valueFunc);\npublic static boolean addIfAbsent(Collection<T> collection, S object);\npublic static Collection<T> addAll(Collection<T> collection, Object value);\npublic static Collection<T> addAll(Collection<T> collection, Object value, Type elementType);\npublic static Collection<T> addAll(Collection<T> collection, Iterator<T> iterator);\npublic static Collection<T> addAll(Collection<T> collection, Iterable<T> iterable);\npublic static Collection<T> addAll(Collection<T> collection, Enumeration<T> enumeration);\npublic static Collection<T> addAll(Collection<T> collection, T[] values);\npublic static List<T> addAllIfNotContains(List<T> list, List<T> otherList);\npublic static T get(Collection<T> collection, int index);\npublic static List<T> getAny(Collection<T> collection, int... indexes);\npublic static T getFirst(Iterable<T> iterable);\npublic static T getFirst(Iterator<T> iterator);\npublic static T getLast(Collection<T> collection);\npublic static Class<?> getElementType(Iterable<?> iterable);\npublic static Class<?> getElementType(Iterator<?> iterator);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, K... keys);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, Iterable<K> keys);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, Iterator<K> keys);\npublic static List<T> sortPageAll(int pageNo, int pageSize, Comparator<T> comparator, Collection<T>... colls);\npublic static List<T> page(int pageNo, int pageSize, List<T> list);\npublic static List<T> sort(Collection<T> collection, Comparator<? super T> comparator);\npublic static List<T> sort(List<T> list, Comparator<? super T> c);\npublic static List<T> sortByProperty(Collection<T> collection, String property);\npublic static List<T> sortByProperty(List<T> list, String property);\npublic static List<String> sortByPinyin(Collection<String> collection);\npublic static List<String> sortByPinyin(List<String> list);\npublic static TreeMap<K, V> sort(Map<K, V> map, Comparator<? super K> comparator);\npublic static LinkedHashMap<K, V> sortToMap(Collection<Map.Entry<K, V>> entryCollection, Comparator<Map.Entry<K, V>> comparator);\npublic static LinkedHashMap<K, V> sortByEntry(Map<K, V> map, Comparator<Map.Entry<K, V>> comparator);\npublic static List<Entry<K, V>> sortEntryToList(Collection<Entry<K, V>> collection);\npublic static void forEach(Iterable<T> iterable, Consumer<T> consumer);\npublic static void forEach(Iterator<T> iterator, Consumer<T> consumer);\npublic static void forEach(Enumeration<T> enumeration, Consumer<T> consumer);\npublic static void forEach(Map<K, V> map, KVConsumer<K, V> kvConsumer);\npublic static List<List<T>> group(Collection<T> collection, Hash32<T> hash);\npublic static List<List<T>> groupByField(Collection<T> collection, final String fieldName);\npublic static List<T> reverse(List<T> list);\npublic static List<T> reverseNew(List<T> list);\npublic static List<T> setOrAppend(List<T> list, int index, T element);\npublic static Set<K> keySet(Collection<Map<K, ?>> mapCollection);\npublic static List<V> values(Collection<Map<?, V>> mapCollection);\npublic static T max(Collection<T> coll);\npublic static T min(Collection<T> coll);\npublic static Collection<T> unmodifiable(Collection<? extends T> c);\npublic static T empty(Class<?> collectionClass);\npublic static void clear(Collection<?>... collections);\npublic static void padLeft(List<T> list, int minLen, T padObj);\npublic static void padRight(Collection<T> list, int minLen, T padObj);\npublic static Collection<T> trans(Collection<F> collection, Function<? super F, ? extends T> function);\npublic static void setValueByMap(Iterable<E> iterable, Map<K, V> map, Function<E, K> keyGenerate, BiConsumer<E, V> biConsumer);\npublic static int size(final Object object);\npublic static boolean isEqualList(final Collection<?> list1, final Collection<?> list2);",
        "Class_name": "CollUtil",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/collection/CollUtil###forEach",
        "Parameter_num": "2",
        "all_Import_statements": "import cn.hutool.core.bean.BeanUtil;\n\nimport cn.hutool.core.comparator.CompareUtil;\n\nimport cn.hutool.core.comparator.PinyinComparator;\n\nimport cn.hutool.core.comparator.PropertyComparator;\n\nimport cn.hutool.core.convert.Convert;\n\nimport cn.hutool.core.convert.ConverterRegistry;\n\nimport cn.hutool.core.exceptions.UtilException;\n\nimport cn.hutool.core.lang.Assert;\n\nimport cn.hutool.core.lang.Editor;\n\nimport cn.hutool.core.lang.Filter;\n\nimport cn.hutool.core.lang.Matcher;\n\nimport cn.hutool.core.lang.func.Func1;\n\nimport cn.hutool.core.lang.hash.Hash32;\n\nimport cn.hutool.core.map.MapUtil;\n\nimport cn.hutool.core.util.*;\n\nimport java.io.Serializable;\n\nimport java.lang.reflect.Type;\n\nimport java.util.*;\n\nimport java.util.Map.Entry;\n\nimport java.util.concurrent.ArrayBlockingQueue;\n\nimport java.util.concurrent.BlockingQueue;\n\nimport java.util.concurrent.CopyOnWriteArrayList;\n\nimport java.util.concurrent.LinkedBlockingDeque;\n\nimport java.util.function.BiConsumer;\n\nimport java.util.function.Function;\n\nimport java.util.function.Predicate;\n\nimport java.util.function.Supplier;\n",
        "comment": "\n\t * 循环遍历Map，使用{@link KVConsumer} 接受遍历的每条数据，并针对每条数据做处理<br>\n\t * 和JDK8中的map.forEach不同的是，此方法支持index\n\t *\n\t * @param <K>        Key类型\n\t * @param <V>        Value类型\n\t * @param map        {@link Map}\n\t * @param kvConsumer {@link KVConsumer} 遍历的每条数据处理器\n\t ",
        "packageName": "cn.hutool.core.collection",
        "method_signature": "public static void forEach(Map<K, V> map, KVConsumer<K, V> kvConsumer);",
        "Junit_version": "5",
        "returnType": "void"
    },
    {
        "Method_body": "public static CharSequence commonPrefix(CharSequence str1, CharSequence str2) {\n    if (isEmpty(str1) || isEmpty(str2)) {\n        return EMPTY;\n    }\n    final int minLength = Math.min(str1.length(), str2.length());\n    int index = 0;\n    for (; index < minLength; index++) {\n        if (str1.charAt(index) != str2.charAt(index)) {\n            break;\n        }\n    }\n    return str1.subSequence(0, index);\n}",
        "all_field_declaration": "public static final int INDEX_NOT_FOUND = Finder.INDEX_NOT_FOUND;\n/**\n * 字符串常量：{@code \"null\"} <br>\n * 注意：{@code \"null\" != null}\n */\npublic static final String NULL = \"null\";\n/**\n * 字符串常量：空字符串 {@code \"\"}\n */\npublic static final String EMPTY = \"\";\n/**\n * 字符串常量：空格符 {@code \" \"}\n */\npublic static final String SPACE = \" \";",
        "sub_project_name": "hutool-core",
        "lineNumbers": "5",
        "Filed": "public static final String EMPTY = \"\";",
        "Parameter_type": "CharSequence,CharSequence",
        "Import_statements": "",
        "public_method_signature": "public static boolean isBlank(CharSequence str);\npublic static boolean isNotBlank(CharSequence str);\npublic static boolean hasBlank(CharSequence... strs);\npublic static boolean isAllBlank(CharSequence... strs);\npublic static boolean isEmpty(CharSequence str);\npublic static boolean isNotEmpty(CharSequence str);\npublic static String emptyIfNull(CharSequence str);\npublic static String nullToEmpty(CharSequence str);\npublic static String nullToDefault(CharSequence str, String defaultStr);\npublic static String emptyToDefault(CharSequence str, String defaultStr);\npublic static String blankToDefault(CharSequence str, String defaultStr);\npublic static String emptyToNull(CharSequence str);\npublic static boolean hasEmpty(CharSequence... strs);\npublic static boolean isAllEmpty(CharSequence... strs);\npublic static boolean isAllNotEmpty(CharSequence... args);\npublic static boolean isAllNotBlank(CharSequence... args);\npublic static boolean isNullOrUndefined(CharSequence str);\npublic static boolean isEmptyOrUndefined(CharSequence str);\npublic static boolean isBlankOrUndefined(CharSequence str);\npublic static String trim(CharSequence str);\npublic static String trimToEmpty(CharSequence str);\npublic static String trimToNull(CharSequence str);\npublic static String trimStart(CharSequence str);\npublic static String trimEnd(CharSequence str);\npublic static String trim(CharSequence str, int mode);\npublic static String trim(CharSequence str, int mode, Predicate<Character> predicate);\npublic static boolean startWith(CharSequence str, char c);\npublic static boolean startWith(CharSequence str, CharSequence prefix, boolean ignoreCase);\npublic static boolean startWith(CharSequence str, CharSequence prefix, boolean ignoreCase, boolean ignoreEquals);\npublic static boolean startWith(CharSequence str, CharSequence prefix);\npublic static boolean startWithIgnoreEquals(CharSequence str, CharSequence prefix);\npublic static boolean startWithIgnoreCase(CharSequence str, CharSequence prefix);\npublic static boolean startWithAny(CharSequence str, CharSequence... prefixes);\npublic static boolean startWithAnyIgnoreCase(final CharSequence str, final CharSequence... suffixes);\npublic static boolean endWith(CharSequence str, char c);\npublic static boolean endWith(CharSequence str, CharSequence suffix, boolean ignoreCase);\npublic static boolean endWith(CharSequence str, CharSequence suffix, boolean ignoreCase, boolean ignoreEquals);\npublic static boolean endWith(CharSequence str, CharSequence suffix);\npublic static boolean endWithIgnoreCase(CharSequence str, CharSequence suffix);\npublic static boolean endWithAny(CharSequence str, CharSequence... suffixes);\npublic static boolean endWithAnyIgnoreCase(CharSequence str, CharSequence... suffixes);\npublic static boolean contains(CharSequence str, char searchChar);\npublic static boolean contains(CharSequence str, CharSequence searchStr);\npublic static boolean containsAny(CharSequence str, CharSequence... testStrs);\npublic static boolean containsAny(CharSequence str, char... testChars);\npublic static boolean containsOnly(CharSequence str, char... testChars);\npublic static boolean containsAll(CharSequence str, CharSequence... testChars);\npublic static boolean containsBlank(CharSequence str);\npublic static String getContainsStr(CharSequence str, CharSequence... testStrs);\npublic static boolean containsIgnoreCase(CharSequence str, CharSequence testStr);\npublic static boolean containsAnyIgnoreCase(CharSequence str, CharSequence... testStrs);\npublic static String getContainsStrIgnoreCase(CharSequence str, CharSequence... testStrs);\npublic static int indexOf(CharSequence str, char searchChar);\npublic static int indexOf(CharSequence str, char searchChar, int start);\npublic static int indexOf(CharSequence text, char searchChar, int start, int end);\npublic static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr);\npublic static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int fromIndex);\npublic static int indexOf(CharSequence text, CharSequence searchStr, int from, boolean ignoreCase);\npublic static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr);\npublic static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr, int fromIndex);\npublic static int lastIndexOf(CharSequence text, CharSequence searchStr, int from, boolean ignoreCase);\npublic static int ordinalIndexOf(CharSequence str, CharSequence searchStr, int ordinal);\npublic static String removeAll(CharSequence str, CharSequence strToRemove);\npublic static String removeAny(CharSequence str, CharSequence... strsToRemove);\npublic static String removeAll(CharSequence str, char... chars);\npublic static String removeAllLineBreaks(CharSequence str);\npublic static String removePreAndLowerFirst(CharSequence str, int preLength);\npublic static String removePreAndLowerFirst(CharSequence str, CharSequence prefix);\npublic static String removePrefix(CharSequence str, CharSequence prefix);\npublic static String removePrefixIgnoreCase(CharSequence str, CharSequence prefix);\npublic static String removeSuffix(CharSequence str, CharSequence suffix);\npublic static String removeSufAndLowerFirst(CharSequence str, CharSequence suffix);\npublic static String removeSuffixIgnoreCase(CharSequence str, CharSequence suffix);\npublic static String cleanBlank(CharSequence str);\npublic static String strip(CharSequence str, CharSequence prefixOrSuffix);\npublic static String strip(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String stripIgnoreCase(CharSequence str, CharSequence prefixOrSuffix);\npublic static String stripIgnoreCase(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String addPrefixIfNot(CharSequence str, CharSequence prefix);\npublic static String addSuffixIfNot(CharSequence str, CharSequence suffix);\npublic static long[] splitToLong(CharSequence str, char separator);\npublic static long[] splitToLong(CharSequence str, CharSequence separator);\npublic static int[] splitToInt(CharSequence str, char separator);\npublic static int[] splitToInt(CharSequence str, CharSequence separator);\npublic static List<String> split(CharSequence str, char separator);\npublic static String[] splitToArray(CharSequence str, CharSequence separator);\npublic static String[] splitToArray(CharSequence str, char separator);\npublic static String[] splitToArray(CharSequence text, char separator, int limit);\npublic static List<String> split(CharSequence str, char separator, int limit);\npublic static List<String> splitTrim(CharSequence str, char separator);\npublic static List<String> splitTrim(CharSequence str, CharSequence separator);\npublic static List<String> splitTrim(CharSequence str, char separator, int limit);\npublic static List<String> splitTrim(CharSequence str, CharSequence separator, int limit);\npublic static List<String> split(CharSequence str, char separator, boolean isTrim, boolean ignoreEmpty);\npublic static List<String> split(CharSequence str, char separator, int limit, boolean isTrim, boolean ignoreEmpty);\npublic static List<R> split(CharSequence str, char separator, int limit, boolean ignoreEmpty, Function<String, R> mapping);\npublic static List<String> split(CharSequence str, CharSequence separator);\npublic static List<String> split(CharSequence str, CharSequence separator, boolean isTrim, boolean ignoreEmpty);\npublic static List<String> split(CharSequence str, CharSequence separator, int limit, boolean isTrim, boolean ignoreEmpty);\npublic static String[] split(CharSequence str, int len);\npublic static String[] cut(CharSequence str, int partLength);\npublic static String sub(CharSequence str, int fromIndexInclude, int toIndexExclude);\npublic static String subByCodePoint(CharSequence str, int fromIndex, int toIndex);\npublic static String subPreGbk(CharSequence str, int len, CharSequence suffix);\npublic static String subPreGbk(CharSequence str, int len, boolean halfUp);\npublic static String subPre(CharSequence string, int toIndexExclude);\npublic static String subSuf(CharSequence string, int fromIndex);\npublic static String subSufByLength(CharSequence string, int length);\npublic static String subWithLength(String input, int fromIndex, int length);\npublic static String subBefore(CharSequence string, CharSequence separator, boolean isLastSeparator);\npublic static String subBefore(CharSequence string, char separator, boolean isLastSeparator);\npublic static String subAfter(CharSequence string, CharSequence separator, boolean isLastSeparator);\npublic static String subAfter(CharSequence string, char separator, boolean isLastSeparator);\npublic static String subBetween(CharSequence str, CharSequence before, CharSequence after);\npublic static String subBetween(CharSequence str, CharSequence beforeAndAfter);\npublic static String[] subBetweenAll(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String[] subBetweenAll(CharSequence str, CharSequence prefixAndSuffix);\npublic static String repeat(char c, int count);\npublic static String repeat(CharSequence str, int count);\npublic static String repeatByLength(CharSequence str, int padLen);\npublic static String repeatAndJoin(CharSequence str, int count, CharSequence delimiter);\npublic static boolean equals(CharSequence str1, CharSequence str2);\npublic static boolean equalsIgnoreCase(CharSequence str1, CharSequence str2);\npublic static boolean equals(CharSequence str1, CharSequence str2, boolean ignoreCase);\npublic static boolean equalsAnyIgnoreCase(CharSequence str1, CharSequence... strs);\npublic static boolean equalsAny(CharSequence str1, CharSequence... strs);\npublic static boolean equalsAny(CharSequence str1, boolean ignoreCase, CharSequence... strs);\npublic static boolean equalsCharAt(CharSequence str, int position, char c);\npublic static boolean isSubEquals(CharSequence str1, int start1, CharSequence str2, boolean ignoreCase);\npublic static boolean isSubEquals(CharSequence str1, int start1, CharSequence str2, int start2, int length, boolean ignoreCase);\npublic static String format(CharSequence template, Object... params);\npublic static String indexedFormat(CharSequence pattern, Object... arguments);\npublic static byte[] utf8Bytes(CharSequence str);\npublic static byte[] bytes(CharSequence str);\npublic static byte[] bytes(CharSequence str, String charset);\npublic static byte[] bytes(CharSequence str, Charset charset);\npublic static ByteBuffer byteBuffer(CharSequence str, String charset);\npublic static String wrap(CharSequence str, CharSequence prefixAndSuffix);\npublic static String wrap(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String[] wrapAllWithPair(CharSequence prefixAndSuffix, CharSequence... strs);\npublic static String[] wrapAll(CharSequence prefix, CharSequence suffix, CharSequence... strs);\npublic static String wrapIfMissing(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String[] wrapAllWithPairIfMissing(CharSequence prefixAndSuffix, CharSequence... strs);\npublic static String[] wrapAllIfMissing(CharSequence prefix, CharSequence suffix, CharSequence... strs);\npublic static String unWrap(CharSequence str, String prefix, String suffix);\npublic static String unWrap(CharSequence str, char prefix, char suffix);\npublic static String unWrap(CharSequence str, char prefixAndSuffix);\npublic static boolean isWrap(CharSequence str, String prefix, String suffix);\npublic static boolean isWrap(CharSequence str, String wrapper);\npublic static boolean isWrap(CharSequence str, char wrapper);\npublic static boolean isWrap(CharSequence str, char prefixChar, char suffixChar);\npublic static String padPre(CharSequence str, int length, CharSequence padStr);\npublic static String padPre(CharSequence str, int length, char padChar);\npublic static String padAfter(CharSequence str, int length, char padChar);\npublic static String padAfter(CharSequence str, int length, CharSequence padStr);\npublic static String center(CharSequence str, final int size);\npublic static String center(CharSequence str, final int size, char padChar);\npublic static String center(CharSequence str, final int size, CharSequence padStr);\npublic static String str(CharSequence cs);\npublic static int count(CharSequence content, CharSequence strForSearch);\npublic static int count(CharSequence content, char charForSearch);\npublic static int compare(final CharSequence str1, final CharSequence str2, final boolean nullIsLess);\npublic static int compareIgnoreCase(CharSequence str1, CharSequence str2, boolean nullIsLess);\npublic static int compareVersion(CharSequence version1, CharSequence version2);\npublic static String appendIfMissing(CharSequence str, CharSequence suffix, CharSequence... suffixes);\npublic static String appendIfMissingIgnoreCase(CharSequence str, CharSequence suffix, CharSequence... suffixes);\npublic static String appendIfMissing(CharSequence str, CharSequence suffix, boolean ignoreCase, CharSequence... testSuffixes);\npublic static String prependIfMissing(CharSequence str, CharSequence prefix, CharSequence... prefixes);\npublic static String prependIfMissingIgnoreCase(CharSequence str, CharSequence prefix, CharSequence... prefixes);\npublic static String prependIfMissing(CharSequence str, CharSequence prefix, boolean ignoreCase, CharSequence... prefixes);\npublic static String replaceIgnoreCase(CharSequence str, CharSequence searchStr, CharSequence replacement);\npublic static String replace(CharSequence str, CharSequence searchStr, CharSequence replacement);\npublic static String replace(CharSequence str, CharSequence searchStr, CharSequence replacement, boolean ignoreCase);\npublic static String replace(CharSequence str, int fromIndex, CharSequence searchStr, CharSequence replacement, boolean ignoreCase);\npublic static String replace(CharSequence str, int startInclude, int endExclude, char replacedChar);\npublic static String replace(CharSequence str, int startInclude, int endExclude, CharSequence replacedStr);\npublic static String replace(CharSequence str, java.util.regex.Pattern pattern, Func1<java.util.regex.Matcher, String> replaceFun);\npublic static String replace(CharSequence str, String regex, Func1<java.util.regex.Matcher, String> replaceFun);\npublic static String replaceLast(CharSequence str, CharSequence searchStr, CharSequence replacedStr);\npublic static String replaceLast(CharSequence str, CharSequence searchStr, CharSequence replacedStr, boolean ignoreCase);\npublic static String replaceFirst(CharSequence str, CharSequence searchStr, CharSequence replacedStr);\npublic static String replaceFirst(CharSequence str, CharSequence searchStr, CharSequence replacedStr, boolean ignoreCase);\npublic static String hide(CharSequence str, int startInclude, int endExclude);\npublic static String desensitized(CharSequence str, DesensitizedUtil.DesensitizedType desensitizedType);\npublic static String replaceChars(CharSequence str, String chars, CharSequence replacedStr);\npublic static String replaceChars(CharSequence str, char[] chars, CharSequence replacedStr);\npublic static int length(CharSequence cs);\npublic static int byteLength(CharSequence cs, Charset charset);\npublic static int totalLength(CharSequence... strs);\npublic static String maxLength(CharSequence string, int length);\npublic static T firstNonNull(T... strs);\npublic static T firstNonEmpty(T... strs);\npublic static T firstNonBlank(T... strs);\npublic static String upperFirstAndAddPre(CharSequence str, String preString);\npublic static String upperFirst(CharSequence str);\npublic static String lowerFirst(CharSequence str);\npublic static String filter(CharSequence str, final Filter<Character> filter);\npublic static boolean isUpperCase(CharSequence str);\npublic static boolean isLowerCase(CharSequence str);\npublic static String swapCase(final String str);\npublic static String toUnderlineCase(CharSequence str);\npublic static String toSymbolCase(CharSequence str, char symbol);\npublic static String toCamelCase(CharSequence name);\npublic static String toCamelCase(CharSequence name, char symbol);\npublic static boolean isSurround(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static boolean isSurround(CharSequence str, char prefix, char suffix);\npublic static StringBuilder builder(CharSequence... strs);\npublic static StrBuilder strBuilder(CharSequence... strs);\npublic static String getGeneralField(CharSequence getOrSetMethodName);\npublic static String genSetter(CharSequence fieldName);\npublic static String genGetter(CharSequence fieldName);\npublic static String concat(boolean isNullToEmpty, CharSequence... strs);\npublic static String brief(CharSequence str, int maxLength);\npublic static String join(CharSequence conjunction, Object... objs);\npublic static String join(CharSequence conjunction, Iterable<T> iterable);\npublic static boolean isAllCharMatch(CharSequence value, Matcher<Character> matcher);\npublic static boolean isNumeric(CharSequence str);\npublic static String move(CharSequence str, int startInclude, int endExclude, int moveLength);\npublic static boolean isCharEquals(CharSequence str);\npublic static String normalize(CharSequence str);\npublic static String fixLength(CharSequence str, char fixedChar, int length);\npublic static boolean hasLetter(CharSequence str);\npublic static CharSequence commonPrefix(CharSequence str1, CharSequence str2);\npublic static CharSequence commonSuffix(CharSequence str1, CharSequence str2);",
        "public_field": "public static final int INDEX_NOT_FOUND = Finder.INDEX_NOT_FOUND;\n/**\n * 字符串常量：{@code \"null\"} <br>\n * 注意：{@code \"null\" != null}\n */\npublic static final String NULL = \"null\";\n/**\n * 字符串常量：空字符串 {@code \"\"}\n */\npublic static final String EMPTY = \"\";\n/**\n * 字符串常量：空格符 {@code \" \"}\n */\npublic static final String SPACE = \" \";",
        "Method_statement": "commonPrefix(CharSequence str1, CharSequence str2)",
        "Method_name": "commonPrefix",
        "Class_declaration": "public class CharSequenceUtil {\n",
        "constructors": "",
        "all_method_signature": "public static boolean isBlank(CharSequence str);\npublic static boolean isNotBlank(CharSequence str);\npublic static boolean hasBlank(CharSequence... strs);\npublic static boolean isAllBlank(CharSequence... strs);\npublic static boolean isEmpty(CharSequence str);\npublic static boolean isNotEmpty(CharSequence str);\npublic static String emptyIfNull(CharSequence str);\npublic static String nullToEmpty(CharSequence str);\npublic static String nullToDefault(CharSequence str, String defaultStr);\npublic static String emptyToDefault(CharSequence str, String defaultStr);\npublic static String blankToDefault(CharSequence str, String defaultStr);\npublic static String emptyToNull(CharSequence str);\npublic static boolean hasEmpty(CharSequence... strs);\npublic static boolean isAllEmpty(CharSequence... strs);\npublic static boolean isAllNotEmpty(CharSequence... args);\npublic static boolean isAllNotBlank(CharSequence... args);\npublic static boolean isNullOrUndefined(CharSequence str);\npublic static boolean isEmptyOrUndefined(CharSequence str);\npublic static boolean isBlankOrUndefined(CharSequence str);\nprivate static boolean isNullOrUndefinedStr(CharSequence str);\npublic static String trim(CharSequence str);\npublic static String trimToEmpty(CharSequence str);\npublic static String trimToNull(CharSequence str);\npublic static String trimStart(CharSequence str);\npublic static String trimEnd(CharSequence str);\npublic static String trim(CharSequence str, int mode);\npublic static String trim(CharSequence str, int mode, Predicate<Character> predicate);\npublic static boolean startWith(CharSequence str, char c);\npublic static boolean startWith(CharSequence str, CharSequence prefix, boolean ignoreCase);\npublic static boolean startWith(CharSequence str, CharSequence prefix, boolean ignoreCase, boolean ignoreEquals);\npublic static boolean startWith(CharSequence str, CharSequence prefix);\npublic static boolean startWithIgnoreEquals(CharSequence str, CharSequence prefix);\npublic static boolean startWithIgnoreCase(CharSequence str, CharSequence prefix);\npublic static boolean startWithAny(CharSequence str, CharSequence... prefixes);\npublic static boolean startWithAnyIgnoreCase(final CharSequence str, final CharSequence... suffixes);\npublic static boolean endWith(CharSequence str, char c);\npublic static boolean endWith(CharSequence str, CharSequence suffix, boolean ignoreCase);\npublic static boolean endWith(CharSequence str, CharSequence suffix, boolean ignoreCase, boolean ignoreEquals);\npublic static boolean endWith(CharSequence str, CharSequence suffix);\npublic static boolean endWithIgnoreCase(CharSequence str, CharSequence suffix);\npublic static boolean endWithAny(CharSequence str, CharSequence... suffixes);\npublic static boolean endWithAnyIgnoreCase(CharSequence str, CharSequence... suffixes);\npublic static boolean contains(CharSequence str, char searchChar);\npublic static boolean contains(CharSequence str, CharSequence searchStr);\npublic static boolean containsAny(CharSequence str, CharSequence... testStrs);\npublic static boolean containsAny(CharSequence str, char... testChars);\npublic static boolean containsOnly(CharSequence str, char... testChars);\npublic static boolean containsAll(CharSequence str, CharSequence... testChars);\npublic static boolean containsBlank(CharSequence str);\npublic static String getContainsStr(CharSequence str, CharSequence... testStrs);\npublic static boolean containsIgnoreCase(CharSequence str, CharSequence testStr);\npublic static boolean containsAnyIgnoreCase(CharSequence str, CharSequence... testStrs);\npublic static String getContainsStrIgnoreCase(CharSequence str, CharSequence... testStrs);\npublic static int indexOf(CharSequence str, char searchChar);\npublic static int indexOf(CharSequence str, char searchChar, int start);\npublic static int indexOf(CharSequence text, char searchChar, int start, int end);\npublic static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr);\npublic static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int fromIndex);\npublic static int indexOf(CharSequence text, CharSequence searchStr, int from, boolean ignoreCase);\npublic static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr);\npublic static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr, int fromIndex);\npublic static int lastIndexOf(CharSequence text, CharSequence searchStr, int from, boolean ignoreCase);\npublic static int ordinalIndexOf(CharSequence str, CharSequence searchStr, int ordinal);\npublic static String removeAll(CharSequence str, CharSequence strToRemove);\npublic static String removeAny(CharSequence str, CharSequence... strsToRemove);\npublic static String removeAll(CharSequence str, char... chars);\npublic static String removeAllLineBreaks(CharSequence str);\npublic static String removePreAndLowerFirst(CharSequence str, int preLength);\npublic static String removePreAndLowerFirst(CharSequence str, CharSequence prefix);\npublic static String removePrefix(CharSequence str, CharSequence prefix);\npublic static String removePrefixIgnoreCase(CharSequence str, CharSequence prefix);\npublic static String removeSuffix(CharSequence str, CharSequence suffix);\npublic static String removeSufAndLowerFirst(CharSequence str, CharSequence suffix);\npublic static String removeSuffixIgnoreCase(CharSequence str, CharSequence suffix);\npublic static String cleanBlank(CharSequence str);\npublic static String strip(CharSequence str, CharSequence prefixOrSuffix);\npublic static String strip(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String stripIgnoreCase(CharSequence str, CharSequence prefixOrSuffix);\npublic static String stripIgnoreCase(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String addPrefixIfNot(CharSequence str, CharSequence prefix);\npublic static String addSuffixIfNot(CharSequence str, CharSequence suffix);\npublic static long[] splitToLong(CharSequence str, char separator);\npublic static long[] splitToLong(CharSequence str, CharSequence separator);\npublic static int[] splitToInt(CharSequence str, char separator);\npublic static int[] splitToInt(CharSequence str, CharSequence separator);\npublic static List<String> split(CharSequence str, char separator);\npublic static String[] splitToArray(CharSequence str, CharSequence separator);\npublic static String[] splitToArray(CharSequence str, char separator);\npublic static String[] splitToArray(CharSequence text, char separator, int limit);\npublic static List<String> split(CharSequence str, char separator, int limit);\npublic static List<String> splitTrim(CharSequence str, char separator);\npublic static List<String> splitTrim(CharSequence str, CharSequence separator);\npublic static List<String> splitTrim(CharSequence str, char separator, int limit);\npublic static List<String> splitTrim(CharSequence str, CharSequence separator, int limit);\npublic static List<String> split(CharSequence str, char separator, boolean isTrim, boolean ignoreEmpty);\npublic static List<String> split(CharSequence str, char separator, int limit, boolean isTrim, boolean ignoreEmpty);\npublic static List<R> split(CharSequence str, char separator, int limit, boolean ignoreEmpty, Function<String, R> mapping);\npublic static List<String> split(CharSequence str, CharSequence separator);\npublic static List<String> split(CharSequence str, CharSequence separator, boolean isTrim, boolean ignoreEmpty);\npublic static List<String> split(CharSequence str, CharSequence separator, int limit, boolean isTrim, boolean ignoreEmpty);\npublic static String[] split(CharSequence str, int len);\npublic static String[] cut(CharSequence str, int partLength);\npublic static String sub(CharSequence str, int fromIndexInclude, int toIndexExclude);\npublic static String subByCodePoint(CharSequence str, int fromIndex, int toIndex);\npublic static String subPreGbk(CharSequence str, int len, CharSequence suffix);\npublic static String subPreGbk(CharSequence str, int len, boolean halfUp);\npublic static String subPre(CharSequence string, int toIndexExclude);\npublic static String subSuf(CharSequence string, int fromIndex);\npublic static String subSufByLength(CharSequence string, int length);\npublic static String subWithLength(String input, int fromIndex, int length);\npublic static String subBefore(CharSequence string, CharSequence separator, boolean isLastSeparator);\npublic static String subBefore(CharSequence string, char separator, boolean isLastSeparator);\npublic static String subAfter(CharSequence string, CharSequence separator, boolean isLastSeparator);\npublic static String subAfter(CharSequence string, char separator, boolean isLastSeparator);\npublic static String subBetween(CharSequence str, CharSequence before, CharSequence after);\npublic static String subBetween(CharSequence str, CharSequence beforeAndAfter);\npublic static String[] subBetweenAll(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String[] subBetweenAll(CharSequence str, CharSequence prefixAndSuffix);\npublic static String repeat(char c, int count);\npublic static String repeat(CharSequence str, int count);\npublic static String repeatByLength(CharSequence str, int padLen);\npublic static String repeatAndJoin(CharSequence str, int count, CharSequence delimiter);\npublic static boolean equals(CharSequence str1, CharSequence str2);\npublic static boolean equalsIgnoreCase(CharSequence str1, CharSequence str2);\npublic static boolean equals(CharSequence str1, CharSequence str2, boolean ignoreCase);\npublic static boolean equalsAnyIgnoreCase(CharSequence str1, CharSequence... strs);\npublic static boolean equalsAny(CharSequence str1, CharSequence... strs);\npublic static boolean equalsAny(CharSequence str1, boolean ignoreCase, CharSequence... strs);\npublic static boolean equalsCharAt(CharSequence str, int position, char c);\npublic static boolean isSubEquals(CharSequence str1, int start1, CharSequence str2, boolean ignoreCase);\npublic static boolean isSubEquals(CharSequence str1, int start1, CharSequence str2, int start2, int length, boolean ignoreCase);\npublic static String format(CharSequence template, Object... params);\npublic static String indexedFormat(CharSequence pattern, Object... arguments);\npublic static byte[] utf8Bytes(CharSequence str);\npublic static byte[] bytes(CharSequence str);\npublic static byte[] bytes(CharSequence str, String charset);\npublic static byte[] bytes(CharSequence str, Charset charset);\npublic static ByteBuffer byteBuffer(CharSequence str, String charset);\npublic static String wrap(CharSequence str, CharSequence prefixAndSuffix);\npublic static String wrap(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String[] wrapAllWithPair(CharSequence prefixAndSuffix, CharSequence... strs);\npublic static String[] wrapAll(CharSequence prefix, CharSequence suffix, CharSequence... strs);\npublic static String wrapIfMissing(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String[] wrapAllWithPairIfMissing(CharSequence prefixAndSuffix, CharSequence... strs);\npublic static String[] wrapAllIfMissing(CharSequence prefix, CharSequence suffix, CharSequence... strs);\npublic static String unWrap(CharSequence str, String prefix, String suffix);\npublic static String unWrap(CharSequence str, char prefix, char suffix);\npublic static String unWrap(CharSequence str, char prefixAndSuffix);\npublic static boolean isWrap(CharSequence str, String prefix, String suffix);\npublic static boolean isWrap(CharSequence str, String wrapper);\npublic static boolean isWrap(CharSequence str, char wrapper);\npublic static boolean isWrap(CharSequence str, char prefixChar, char suffixChar);\npublic static String padPre(CharSequence str, int length, CharSequence padStr);\npublic static String padPre(CharSequence str, int length, char padChar);\npublic static String padAfter(CharSequence str, int length, char padChar);\npublic static String padAfter(CharSequence str, int length, CharSequence padStr);\npublic static String center(CharSequence str, final int size);\npublic static String center(CharSequence str, final int size, char padChar);\npublic static String center(CharSequence str, final int size, CharSequence padStr);\npublic static String str(CharSequence cs);\npublic static int count(CharSequence content, CharSequence strForSearch);\npublic static int count(CharSequence content, char charForSearch);\npublic static int compare(final CharSequence str1, final CharSequence str2, final boolean nullIsLess);\npublic static int compareIgnoreCase(CharSequence str1, CharSequence str2, boolean nullIsLess);\npublic static int compareVersion(CharSequence version1, CharSequence version2);\npublic static String appendIfMissing(CharSequence str, CharSequence suffix, CharSequence... suffixes);\npublic static String appendIfMissingIgnoreCase(CharSequence str, CharSequence suffix, CharSequence... suffixes);\npublic static String appendIfMissing(CharSequence str, CharSequence suffix, boolean ignoreCase, CharSequence... testSuffixes);\npublic static String prependIfMissing(CharSequence str, CharSequence prefix, CharSequence... prefixes);\npublic static String prependIfMissingIgnoreCase(CharSequence str, CharSequence prefix, CharSequence... prefixes);\npublic static String prependIfMissing(CharSequence str, CharSequence prefix, boolean ignoreCase, CharSequence... prefixes);\npublic static String replaceIgnoreCase(CharSequence str, CharSequence searchStr, CharSequence replacement);\npublic static String replace(CharSequence str, CharSequence searchStr, CharSequence replacement);\npublic static String replace(CharSequence str, CharSequence searchStr, CharSequence replacement, boolean ignoreCase);\npublic static String replace(CharSequence str, int fromIndex, CharSequence searchStr, CharSequence replacement, boolean ignoreCase);\npublic static String replace(CharSequence str, int startInclude, int endExclude, char replacedChar);\npublic static String replace(CharSequence str, int startInclude, int endExclude, CharSequence replacedStr);\npublic static String replace(CharSequence str, java.util.regex.Pattern pattern, Func1<java.util.regex.Matcher, String> replaceFun);\npublic static String replace(CharSequence str, String regex, Func1<java.util.regex.Matcher, String> replaceFun);\npublic static String replaceLast(CharSequence str, CharSequence searchStr, CharSequence replacedStr);\npublic static String replaceLast(CharSequence str, CharSequence searchStr, CharSequence replacedStr, boolean ignoreCase);\npublic static String replaceFirst(CharSequence str, CharSequence searchStr, CharSequence replacedStr);\npublic static String replaceFirst(CharSequence str, CharSequence searchStr, CharSequence replacedStr, boolean ignoreCase);\npublic static String hide(CharSequence str, int startInclude, int endExclude);\npublic static String desensitized(CharSequence str, DesensitizedUtil.DesensitizedType desensitizedType);\npublic static String replaceChars(CharSequence str, String chars, CharSequence replacedStr);\npublic static String replaceChars(CharSequence str, char[] chars, CharSequence replacedStr);\npublic static int length(CharSequence cs);\npublic static int byteLength(CharSequence cs, Charset charset);\npublic static int totalLength(CharSequence... strs);\npublic static String maxLength(CharSequence string, int length);\npublic static T firstNonNull(T... strs);\npublic static T firstNonEmpty(T... strs);\npublic static T firstNonBlank(T... strs);\npublic static String upperFirstAndAddPre(CharSequence str, String preString);\npublic static String upperFirst(CharSequence str);\npublic static String lowerFirst(CharSequence str);\npublic static String filter(CharSequence str, final Filter<Character> filter);\npublic static boolean isUpperCase(CharSequence str);\npublic static boolean isLowerCase(CharSequence str);\npublic static String swapCase(final String str);\npublic static String toUnderlineCase(CharSequence str);\npublic static String toSymbolCase(CharSequence str, char symbol);\npublic static String toCamelCase(CharSequence name);\npublic static String toCamelCase(CharSequence name, char symbol);\npublic static boolean isSurround(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static boolean isSurround(CharSequence str, char prefix, char suffix);\npublic static StringBuilder builder(CharSequence... strs);\npublic static StrBuilder strBuilder(CharSequence... strs);\npublic static String getGeneralField(CharSequence getOrSetMethodName);\npublic static String genSetter(CharSequence fieldName);\npublic static String genGetter(CharSequence fieldName);\npublic static String concat(boolean isNullToEmpty, CharSequence... strs);\npublic static String brief(CharSequence str, int maxLength);\npublic static String join(CharSequence conjunction, Object... objs);\npublic static String join(CharSequence conjunction, Iterable<T> iterable);\npublic static boolean isAllCharMatch(CharSequence value, Matcher<Character> matcher);\npublic static boolean isNumeric(CharSequence str);\npublic static String move(CharSequence str, int startInclude, int endExclude, int moveLength);\npublic static boolean isCharEquals(CharSequence str);\npublic static String normalize(CharSequence str);\npublic static String fixLength(CharSequence str, char fixedChar, int length);\npublic static boolean hasLetter(CharSequence str);\npublic static CharSequence commonPrefix(CharSequence str1, CharSequence str2);\npublic static CharSequence commonSuffix(CharSequence str1, CharSequence str2);",
        "Class_name": "CharSequenceUtil",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/text/CharSequenceUtil###commonPrefix",
        "Parameter_num": "2",
        "all_Import_statements": "import cn.hutool.core.collection.CollUtil;\n\nimport cn.hutool.core.comparator.VersionComparator;\n\nimport cn.hutool.core.convert.Convert;\n\nimport cn.hutool.core.lang.Assert;\n\nimport cn.hutool.core.lang.Filter;\n\nimport cn.hutool.core.lang.Matcher;\n\nimport cn.hutool.core.lang.func.Func1;\n\nimport cn.hutool.core.text.finder.CharFinder;\n\nimport cn.hutool.core.text.finder.Finder;\n\nimport cn.hutool.core.text.finder.StrFinder;\n\nimport cn.hutool.core.util.ArrayUtil;\n\nimport cn.hutool.core.util.CharUtil;\n\nimport cn.hutool.core.util.CharsetUtil;\n\nimport cn.hutool.core.util.DesensitizedUtil;\n\nimport cn.hutool.core.util.NumberUtil;\n\nimport cn.hutool.core.util.ReUtil;\n\nimport cn.hutool.core.util.StrUtil;\n\nimport java.nio.ByteBuffer;\n\nimport java.nio.charset.Charset;\n\nimport java.text.MessageFormat;\n\nimport java.text.Normalizer;\n\nimport java.util.HashSet;\n\nimport java.util.LinkedList;\n\nimport java.util.List;\n\nimport java.util.Set;\n\nimport java.util.function.Function;\n\nimport java.util.function.Predicate;\n",
        "comment": "\n\t * 字符串1和字符串2的公共前缀\n\t *\n\t * @param str1 字符串1\n\t * @param str2 字符串2\n\t * @return 字符串1和字符串2的公共前缀\n\t ",
        "packageName": "cn.hutool.core.text",
        "method_signature": "public static CharSequence commonPrefix(CharSequence str1, CharSequence str2);",
        "Junit_version": "5",
        "returnType": "CharSequence"
    },
    {
        "Method_body": "public static String format(Date date, String format) {\n    if (null == date || StrUtil.isBlank(format)) {\n        return null;\n    }\n    if (GlobalCustomFormat.isCustomFormat(format)) {\n        return GlobalCustomFormat.format(date, format);\n    }\n    TimeZone timeZone = null;\n    if (date instanceof DateTime) {\n        timeZone = ((DateTime) date).getTimeZone();\n    }\n    return format(date, newSimpleFormat(format, null, timeZone));\n}",
        "all_field_declaration": "/**\n * java.util.Date EEE MMM zzz 缩写数组\n */\nprivate final static String[] wtb = { // \n// 星期\n\"sun\", // 星期\n\"mon\", // 星期\n\"tue\", // 星期\n\"wed\", // 星期\n\"thu\", // 星期\n\"fri\", // 星期\n\"sat\", // 月份\n\"jan\", // 月份\n\"feb\", // 月份\n\"mar\", // 月份\n\"apr\", // 月份\n\"may\", // 月份\n\"jun\", // 月份\n\"jul\", // 月份\n\"aug\", // 月份\n\"sep\", // 月份\n\"oct\", // 月份\n\"nov\", // 月份\n\"dec\", // 时间标准\n\"gmt\", // 时间标准\n\"ut\", // 时间标准\n\"utc\", // 时间标准\n\"est\", // 时间标准\n\"edt\", // 时间标准\n\"cst\", // 时间标准\n\"cdt\", // 时间标准\n\"mst\", // 时间标准\n\"mdt\", // 时间标准\n\"pst\", // 时间标准\n\"pdt\" };",
        "sub_project_name": "hutool-core",
        "lineNumbers": "5",
        "Filed": "",
        "Parameter_type": "Date,String",
        "Import_statements": "import cn.hutool.core.date.format.GlobalCustomFormat;\nimport cn.hutool.core.util.StrUtil;\n",
        "public_method_signature": "public static DateTime date();\npublic static DateTime dateSecond();\npublic static DateTime date(Date date);\npublic static DateTime dateNew(Date date);\npublic static DateTime date(long date);\npublic static DateTime date(Calendar calendar);\npublic static DateTime date(TemporalAccessor temporalAccessor);\npublic static long current();\npublic static long currentSeconds();\npublic static String now();\npublic static String today();\npublic static int year(Date date);\npublic static int quarter(Date date);\npublic static Quarter quarterEnum(Date date);\npublic static int month(Date date);\npublic static Month monthEnum(Date date);\npublic static int weekOfYear(Date date);\npublic static int weekOfMonth(Date date);\npublic static int dayOfMonth(Date date);\npublic static int dayOfYear(Date date);\npublic static int dayOfWeek(Date date);\npublic static Week dayOfWeekEnum(Date date);\npublic static boolean isWeekend(Date date);\npublic static int hour(Date date, boolean is24HourClock);\npublic static int minute(Date date);\npublic static int second(Date date);\npublic static int millisecond(Date date);\npublic static boolean isAM(Date date);\npublic static boolean isPM(Date date);\npublic static int thisYear();\npublic static int thisMonth();\npublic static Month thisMonthEnum();\npublic static int thisWeekOfYear();\npublic static int thisWeekOfMonth();\npublic static int thisDayOfMonth();\npublic static int thisDayOfWeek();\npublic static Week thisDayOfWeekEnum();\npublic static int thisHour(boolean is24HourClock);\npublic static int thisMinute();\npublic static int thisSecond();\npublic static int thisMillisecond();\npublic static String yearAndQuarter(Date date);\npublic static LinkedHashSet<String> yearAndQuarter(Date startDate, Date endDate);\npublic static String formatLocalDateTime(LocalDateTime localDateTime);\npublic static String format(LocalDateTime localDateTime, String format);\npublic static String format(Date date, String format);\npublic static String format(Date date, DatePrinter format);\npublic static String format(Date date, DateFormat format);\npublic static String format(Date date, DateTimeFormatter format);\npublic static String formatDateTime(Date date);\npublic static String formatDate(Date date);\npublic static String formatTime(Date date);\npublic static String formatHttpDate(Date date);\npublic static String formatChineseDate(Date date, boolean isUppercase, boolean withTime);\npublic static LocalDateTime parseLocalDateTime(CharSequence dateStr);\npublic static LocalDateTime parseLocalDateTime(CharSequence dateStr, String format);\npublic static DateTime parse(CharSequence dateStr, DateFormat dateFormat);\npublic static DateTime parse(CharSequence dateStr, DateParser parser);\npublic static DateTime parse(CharSequence dateStr, DateParser parser, boolean lenient);\npublic static DateTime parse(CharSequence dateStr, DateTimeFormatter formatter);\npublic static DateTime parse(CharSequence dateStr, String format);\npublic static DateTime parse(CharSequence dateStr, String format, Locale locale);\npublic static DateTime parse(String str, String... parsePatterns) throws DateException;\npublic static DateTime parseDateTime(CharSequence dateString);\npublic static DateTime parseDate(CharSequence dateString);\npublic static DateTime parseTime(CharSequence timeString);\npublic static DateTime parseTimeToday(CharSequence timeString);\npublic static DateTime parseUTC(String utcString);\npublic static DateTime parseCST(CharSequence cstString);\npublic static DateTime parse(CharSequence dateCharSequence);\npublic static DateTime truncate(Date date, DateField dateField);\npublic static DateTime round(Date date, DateField dateField);\npublic static DateTime ceiling(Date date, DateField dateField);\npublic static DateTime ceiling(Date date, DateField dateField, boolean truncateMillisecond);\npublic static DateTime beginOfSecond(Date date);\npublic static DateTime endOfSecond(Date date);\npublic static DateTime beginOfHour(Date date);\npublic static DateTime endOfHour(Date date);\npublic static DateTime beginOfMinute(Date date);\npublic static DateTime endOfMinute(Date date);\npublic static DateTime beginOfDay(Date date);\npublic static DateTime endOfDay(Date date);\npublic static DateTime beginOfWeek(Date date);\npublic static DateTime beginOfWeek(Date date, boolean isMondayAsFirstDay);\npublic static DateTime endOfWeek(Date date);\npublic static DateTime endOfWeek(Date date, boolean isSundayAsLastDay);\npublic static DateTime beginOfMonth(Date date);\npublic static DateTime endOfMonth(Date date);\npublic static DateTime beginOfQuarter(Date date);\npublic static DateTime endOfQuarter(Date date);\npublic static DateTime beginOfYear(Date date);\npublic static DateTime endOfYear(Date date);\npublic static DateTime yesterday();\npublic static DateTime tomorrow();\npublic static DateTime lastWeek();\npublic static DateTime nextWeek();\npublic static DateTime lastMonth();\npublic static DateTime nextMonth();\npublic static DateTime offsetMillisecond(Date date, int offset);\npublic static DateTime offsetSecond(Date date, int offset);\npublic static DateTime offsetMinute(Date date, int offset);\npublic static DateTime offsetHour(Date date, int offset);\npublic static DateTime offsetDay(Date date, int offset);\npublic static DateTime offsetWeek(Date date, int offset);\npublic static DateTime offsetMonth(Date date, int offset);\npublic static DateTime offset(Date date, DateField dateField, int offset);\npublic static long between(Date beginDate, Date endDate, DateUnit unit);\npublic static long between(Date beginDate, Date endDate, DateUnit unit, boolean isAbs);\npublic static long betweenMs(Date beginDate, Date endDate);\npublic static long betweenDay(Date beginDate, Date endDate, boolean isReset);\npublic static long betweenWeek(Date beginDate, Date endDate, boolean isReset);\npublic static long betweenMonth(Date beginDate, Date endDate, boolean isReset);\npublic static long betweenYear(Date beginDate, Date endDate, boolean isReset);\npublic static String formatBetween(Date beginDate, Date endDate, BetweenFormatter.Level level);\npublic static String formatBetween(Date beginDate, Date endDate);\npublic static String formatBetween(long betweenMs, BetweenFormatter.Level level);\npublic static String formatBetween(long betweenMs);\npublic static boolean isIn(Date date, Date beginDate, Date endDate);\npublic static boolean isSameTime(Date date1, Date date2);\npublic static boolean isSameDay(final Date date1, final Date date2);\npublic static boolean isSameWeek(final Date date1, final Date date2, boolean isMon);\npublic static boolean isSameMonth(final Date date1, final Date date2);\npublic static long spendNt(long preTime);\npublic static long spendMs(long preTime);\npublic static int toIntSecond(Date date);\npublic static TimeInterval timer();\npublic static TimeInterval timer(boolean isNano);\npublic static StopWatch createStopWatch();\npublic static StopWatch createStopWatch(String id);\npublic static int ageOfNow(String birthDay);\npublic static int ageOfNow(Date birthDay);\npublic static boolean isLeapYear(int year);\npublic static int age(Date birthday, Date dateToCompare);\npublic static boolean isExpired(Date startDate, DateField dateField, int timeLength, Date endDate);\npublic static boolean isExpired(Date startDate, Date endDate, Date checkDate);\npublic static int timeToSecond(String timeStr);\npublic static String secondToTime(int seconds);\npublic static DateRange range(Date start, Date end, final DateField unit);\npublic static List<DateTime> rangeContains(DateRange start, DateRange end);\npublic static List<DateTime> rangeNotContains(DateRange start, DateRange end);\npublic static List<T> rangeFunc(Date start, Date end, final DateField unit, Function<Date, T> func);\npublic static void rangeConsume(Date start, Date end, final DateField unit, Consumer<Date> consumer);\npublic static List<DateTime> rangeToList(Date start, Date end, DateField unit);\npublic static List<DateTime> rangeToList(Date start, Date end, final DateField unit, int step);\npublic static String getZodiac(int month, int day);\npublic static String getChineseZodiac(int year);\npublic static int compare(Date date1, Date date2);\npublic static int compare(Date date1, Date date2, String format);\npublic static long nanosToMillis(long duration);\npublic static double nanosToSeconds(long duration);\npublic static Instant toInstant(Date date);\npublic static Instant toInstant(TemporalAccessor temporalAccessor);\npublic static LocalDateTime toLocalDateTime(Instant instant);\npublic static LocalDateTime toLocalDateTime(Date date);\npublic static DateTime convertTimeZone(Date date, ZoneId zoneId);\npublic static DateTime convertTimeZone(Date date, TimeZone timeZone);\npublic static int lengthOfYear(int year);\npublic static int lengthOfMonth(int month, boolean isLeapYear);\npublic static SimpleDateFormat newSimpleFormat(String pattern);\npublic static SimpleDateFormat newSimpleFormat(String pattern, Locale locale, TimeZone timeZone);\npublic static String getShotName(TimeUnit unit);\npublic static boolean isOverlap(Date realStartTime, Date realEndTime, Date startTime, Date endTime);\npublic static boolean isLastDayOfMonth(Date date);\npublic static int getLastDayOfMonth(Date date);",
        "public_field": "",
        "Method_statement": "format(Date date, String format)",
        "Method_name": "format",
        "Class_declaration": "public class DateUtil {\n",
        "constructors": "",
        "all_method_signature": "public static DateTime date();\npublic static DateTime dateSecond();\npublic static DateTime date(Date date);\npublic static DateTime dateNew(Date date);\npublic static DateTime date(long date);\npublic static DateTime date(Calendar calendar);\npublic static DateTime date(TemporalAccessor temporalAccessor);\npublic static long current();\npublic static long currentSeconds();\npublic static String now();\npublic static String today();\npublic static int year(Date date);\npublic static int quarter(Date date);\npublic static Quarter quarterEnum(Date date);\npublic static int month(Date date);\npublic static Month monthEnum(Date date);\npublic static int weekOfYear(Date date);\npublic static int weekOfMonth(Date date);\npublic static int dayOfMonth(Date date);\npublic static int dayOfYear(Date date);\npublic static int dayOfWeek(Date date);\npublic static Week dayOfWeekEnum(Date date);\npublic static boolean isWeekend(Date date);\npublic static int hour(Date date, boolean is24HourClock);\npublic static int minute(Date date);\npublic static int second(Date date);\npublic static int millisecond(Date date);\npublic static boolean isAM(Date date);\npublic static boolean isPM(Date date);\npublic static int thisYear();\npublic static int thisMonth();\npublic static Month thisMonthEnum();\npublic static int thisWeekOfYear();\npublic static int thisWeekOfMonth();\npublic static int thisDayOfMonth();\npublic static int thisDayOfWeek();\npublic static Week thisDayOfWeekEnum();\npublic static int thisHour(boolean is24HourClock);\npublic static int thisMinute();\npublic static int thisSecond();\npublic static int thisMillisecond();\npublic static String yearAndQuarter(Date date);\npublic static LinkedHashSet<String> yearAndQuarter(Date startDate, Date endDate);\npublic static String formatLocalDateTime(LocalDateTime localDateTime);\npublic static String format(LocalDateTime localDateTime, String format);\npublic static String format(Date date, String format);\npublic static String format(Date date, DatePrinter format);\npublic static String format(Date date, DateFormat format);\npublic static String format(Date date, DateTimeFormatter format);\npublic static String formatDateTime(Date date);\npublic static String formatDate(Date date);\npublic static String formatTime(Date date);\npublic static String formatHttpDate(Date date);\npublic static String formatChineseDate(Date date, boolean isUppercase, boolean withTime);\npublic static LocalDateTime parseLocalDateTime(CharSequence dateStr);\npublic static LocalDateTime parseLocalDateTime(CharSequence dateStr, String format);\npublic static DateTime parse(CharSequence dateStr, DateFormat dateFormat);\npublic static DateTime parse(CharSequence dateStr, DateParser parser);\npublic static DateTime parse(CharSequence dateStr, DateParser parser, boolean lenient);\npublic static DateTime parse(CharSequence dateStr, DateTimeFormatter formatter);\npublic static DateTime parse(CharSequence dateStr, String format);\npublic static DateTime parse(CharSequence dateStr, String format, Locale locale);\npublic static DateTime parse(String str, String... parsePatterns) throws DateException;\npublic static DateTime parseDateTime(CharSequence dateString);\npublic static DateTime parseDate(CharSequence dateString);\npublic static DateTime parseTime(CharSequence timeString);\npublic static DateTime parseTimeToday(CharSequence timeString);\npublic static DateTime parseUTC(String utcString);\npublic static DateTime parseCST(CharSequence cstString);\npublic static DateTime parse(CharSequence dateCharSequence);\npublic static DateTime truncate(Date date, DateField dateField);\npublic static DateTime round(Date date, DateField dateField);\npublic static DateTime ceiling(Date date, DateField dateField);\npublic static DateTime ceiling(Date date, DateField dateField, boolean truncateMillisecond);\npublic static DateTime beginOfSecond(Date date);\npublic static DateTime endOfSecond(Date date);\npublic static DateTime beginOfHour(Date date);\npublic static DateTime endOfHour(Date date);\npublic static DateTime beginOfMinute(Date date);\npublic static DateTime endOfMinute(Date date);\npublic static DateTime beginOfDay(Date date);\npublic static DateTime endOfDay(Date date);\npublic static DateTime beginOfWeek(Date date);\npublic static DateTime beginOfWeek(Date date, boolean isMondayAsFirstDay);\npublic static DateTime endOfWeek(Date date);\npublic static DateTime endOfWeek(Date date, boolean isSundayAsLastDay);\npublic static DateTime beginOfMonth(Date date);\npublic static DateTime endOfMonth(Date date);\npublic static DateTime beginOfQuarter(Date date);\npublic static DateTime endOfQuarter(Date date);\npublic static DateTime beginOfYear(Date date);\npublic static DateTime endOfYear(Date date);\npublic static DateTime yesterday();\npublic static DateTime tomorrow();\npublic static DateTime lastWeek();\npublic static DateTime nextWeek();\npublic static DateTime lastMonth();\npublic static DateTime nextMonth();\npublic static DateTime offsetMillisecond(Date date, int offset);\npublic static DateTime offsetSecond(Date date, int offset);\npublic static DateTime offsetMinute(Date date, int offset);\npublic static DateTime offsetHour(Date date, int offset);\npublic static DateTime offsetDay(Date date, int offset);\npublic static DateTime offsetWeek(Date date, int offset);\npublic static DateTime offsetMonth(Date date, int offset);\npublic static DateTime offset(Date date, DateField dateField, int offset);\npublic static long between(Date beginDate, Date endDate, DateUnit unit);\npublic static long between(Date beginDate, Date endDate, DateUnit unit, boolean isAbs);\npublic static long betweenMs(Date beginDate, Date endDate);\npublic static long betweenDay(Date beginDate, Date endDate, boolean isReset);\npublic static long betweenWeek(Date beginDate, Date endDate, boolean isReset);\npublic static long betweenMonth(Date beginDate, Date endDate, boolean isReset);\npublic static long betweenYear(Date beginDate, Date endDate, boolean isReset);\npublic static String formatBetween(Date beginDate, Date endDate, BetweenFormatter.Level level);\npublic static String formatBetween(Date beginDate, Date endDate);\npublic static String formatBetween(long betweenMs, BetweenFormatter.Level level);\npublic static String formatBetween(long betweenMs);\npublic static boolean isIn(Date date, Date beginDate, Date endDate);\npublic static boolean isSameTime(Date date1, Date date2);\npublic static boolean isSameDay(final Date date1, final Date date2);\npublic static boolean isSameWeek(final Date date1, final Date date2, boolean isMon);\npublic static boolean isSameMonth(final Date date1, final Date date2);\npublic static long spendNt(long preTime);\npublic static long spendMs(long preTime);\npublic static int toIntSecond(Date date);\npublic static TimeInterval timer();\npublic static TimeInterval timer(boolean isNano);\npublic static StopWatch createStopWatch();\npublic static StopWatch createStopWatch(String id);\npublic static int ageOfNow(String birthDay);\npublic static int ageOfNow(Date birthDay);\npublic static boolean isLeapYear(int year);\npublic static int age(Date birthday, Date dateToCompare);\npublic static boolean isExpired(Date startDate, DateField dateField, int timeLength, Date endDate);\npublic static boolean isExpired(Date startDate, Date endDate, Date checkDate);\npublic static int timeToSecond(String timeStr);\npublic static String secondToTime(int seconds);\npublic static DateRange range(Date start, Date end, final DateField unit);\npublic static List<DateTime> rangeContains(DateRange start, DateRange end);\npublic static List<DateTime> rangeNotContains(DateRange start, DateRange end);\npublic static List<T> rangeFunc(Date start, Date end, final DateField unit, Function<Date, T> func);\npublic static void rangeConsume(Date start, Date end, final DateField unit, Consumer<Date> consumer);\npublic static List<DateTime> rangeToList(Date start, Date end, DateField unit);\npublic static List<DateTime> rangeToList(Date start, Date end, final DateField unit, int step);\npublic static String getZodiac(int month, int day);\npublic static String getChineseZodiac(int year);\npublic static int compare(Date date1, Date date2);\npublic static int compare(Date date1, Date date2, String format);\npublic static long nanosToMillis(long duration);\npublic static double nanosToSeconds(long duration);\npublic static Instant toInstant(Date date);\npublic static Instant toInstant(TemporalAccessor temporalAccessor);\npublic static LocalDateTime toLocalDateTime(Instant instant);\npublic static LocalDateTime toLocalDateTime(Date date);\npublic static DateTime convertTimeZone(Date date, ZoneId zoneId);\npublic static DateTime convertTimeZone(Date date, TimeZone timeZone);\npublic static int lengthOfYear(int year);\npublic static int lengthOfMonth(int month, boolean isLeapYear);\npublic static SimpleDateFormat newSimpleFormat(String pattern);\npublic static SimpleDateFormat newSimpleFormat(String pattern, Locale locale, TimeZone timeZone);\npublic static String getShotName(TimeUnit unit);\npublic static boolean isOverlap(Date realStartTime, Date realEndTime, Date startTime, Date endTime);\npublic static boolean isLastDayOfMonth(Date date);\npublic static int getLastDayOfMonth(Date date);\nprivate static String normalize(CharSequence dateStr);\nprivate static String normalizeMillSeconds(String dateStr, CharSequence before, CharSequence after);",
        "Class_name": "DateUtil",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/date/DateUtil###format",
        "Parameter_num": "2",
        "all_Import_statements": "import cn.hutool.core.collection.CollUtil;\n\nimport cn.hutool.core.comparator.CompareUtil;\n\nimport cn.hutool.core.date.format.DateParser;\n\nimport cn.hutool.core.date.format.DatePrinter;\n\nimport cn.hutool.core.date.format.FastDateFormat;\n\nimport cn.hutool.core.date.format.GlobalCustomFormat;\n\nimport cn.hutool.core.lang.Assert;\n\nimport cn.hutool.core.lang.PatternPool;\n\nimport cn.hutool.core.util.CharUtil;\n\nimport cn.hutool.core.util.NumberUtil;\n\nimport cn.hutool.core.util.ReUtil;\n\nimport cn.hutool.core.util.StrUtil;\n\nimport java.text.DateFormat;\n\nimport java.text.SimpleDateFormat;\n\nimport java.time.Instant;\n\nimport java.time.LocalDateTime;\n\nimport java.time.Year;\n\nimport java.time.ZoneId;\n\nimport java.time.format.DateTimeFormatter;\n\nimport java.time.temporal.TemporalAccessor;\n\nimport java.util.*;\n\nimport java.util.concurrent.TimeUnit;\n\nimport java.util.function.Consumer;\n\nimport java.util.function.Function;\n\nimport java.util.stream.Collectors;\n",
        "comment": "\n\t * 根据特定格式格式化日期\n\t *\n\t * @param date   被格式化的日期\n\t * @param format 日期格式，常用格式见： {@link DatePattern} {@link DatePattern#NORM_DATETIME_PATTERN}\n\t * @return 格式化后的字符串\n\t ",
        "packageName": "cn.hutool.core.date",
        "method_signature": "public static String format(Date date, String format);",
        "Junit_version": "5",
        "returnType": "String"
    },
    {
        "Method_body": "public static boolean isBase64(byte[] base64Bytes) {\n    if (base64Bytes == null || base64Bytes.length < 3) {\n        return false;\n    }\n    boolean hasPadding = false;\n    for (byte base64Byte : base64Bytes) {\n        if (hasPadding) {\n            if ('=' != base64Byte) {\n                return false;\n            }\n        } else if ('=' == base64Byte) {\n            hasPadding = true;\n        } else if (false == (Base64Decoder.isBase64Code(base64Byte) || isWhiteSpace(base64Byte))) {\n            return false;\n        }\n    }\n    return true;\n}",
        "all_field_declaration": "private static final Charset DEFAULT_CHARSET = CharsetUtil.CHARSET_UTF_8;",
        "sub_project_name": "hutool-core",
        "lineNumbers": "4",
        "Filed": "",
        "Parameter_type": "byte[]",
        "Import_statements": "",
        "public_method_signature": "public static byte[] encode(byte[] arr, boolean lineSep);\npublic static byte[] encodeUrlSafe(byte[] arr, boolean lineSep);\npublic static String encode(CharSequence source);\npublic static String encodeUrlSafe(CharSequence source);\npublic static String encode(CharSequence source, String charset);\npublic static String encodeWithoutPadding(CharSequence source, String charset);\npublic static String encodeUrlSafe(CharSequence source, String charset);\npublic static String encode(CharSequence source, Charset charset);\npublic static String encodeUrlSafe(CharSequence source, Charset charset);\npublic static String encode(byte[] source);\npublic static String encodeWithoutPadding(byte[] source);\npublic static String encodeUrlSafe(byte[] source);\npublic static String encode(InputStream in);\npublic static String encodeUrlSafe(InputStream in);\npublic static String encode(File file);\npublic static String encodeUrlSafe(File file);\npublic static String encodeStr(byte[] arr, boolean isMultiLine, boolean isUrlSafe);\npublic static byte[] encode(byte[] arr, boolean isMultiLine, boolean isUrlSafe);\npublic static String decodeStrGbk(CharSequence source);\npublic static String decodeStr(CharSequence source);\npublic static String decodeStr(CharSequence source, String charset);\npublic static String decodeStr(CharSequence source, Charset charset);\npublic static File decodeToFile(CharSequence base64, File destFile);\npublic static void decodeToStream(CharSequence base64, OutputStream out, boolean isCloseOut);\npublic static byte[] decode(CharSequence base64);\npublic static byte[] decode(byte[] in);\npublic static boolean isBase64(CharSequence base64);\npublic static boolean isBase64(byte[] base64Bytes);",
        "public_field": "",
        "Method_statement": "isBase64(byte() base64Bytes)",
        "Method_name": "isBase64",
        "Class_declaration": "public class Base64 {\n",
        "constructors": "",
        "all_method_signature": "public static byte[] encode(byte[] arr, boolean lineSep);\npublic static byte[] encodeUrlSafe(byte[] arr, boolean lineSep);\npublic static String encode(CharSequence source);\npublic static String encodeUrlSafe(CharSequence source);\npublic static String encode(CharSequence source, String charset);\npublic static String encodeWithoutPadding(CharSequence source, String charset);\npublic static String encodeUrlSafe(CharSequence source, String charset);\npublic static String encode(CharSequence source, Charset charset);\npublic static String encodeUrlSafe(CharSequence source, Charset charset);\npublic static String encode(byte[] source);\npublic static String encodeWithoutPadding(byte[] source);\npublic static String encodeUrlSafe(byte[] source);\npublic static String encode(InputStream in);\npublic static String encodeUrlSafe(InputStream in);\npublic static String encode(File file);\npublic static String encodeUrlSafe(File file);\npublic static String encodeStr(byte[] arr, boolean isMultiLine, boolean isUrlSafe);\npublic static byte[] encode(byte[] arr, boolean isMultiLine, boolean isUrlSafe);\npublic static String decodeStrGbk(CharSequence source);\npublic static String decodeStr(CharSequence source);\npublic static String decodeStr(CharSequence source, String charset);\npublic static String decodeStr(CharSequence source, Charset charset);\npublic static File decodeToFile(CharSequence base64, File destFile);\npublic static void decodeToStream(CharSequence base64, OutputStream out, boolean isCloseOut);\npublic static byte[] decode(CharSequence base64);\npublic static byte[] decode(byte[] in);\npublic static boolean isBase64(CharSequence base64);\npublic static boolean isBase64(byte[] base64Bytes);\nprivate static boolean isWhiteSpace(byte byteToCheck);",
        "Class_name": "Base64",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/codec/Base64###isBase64",
        "Parameter_num": "1",
        "all_Import_statements": "import cn.hutool.core.io.FileUtil;\n\nimport cn.hutool.core.io.IoUtil;\n\nimport cn.hutool.core.util.CharsetUtil;\n\nimport cn.hutool.core.util.StrUtil;\n\nimport java.io.File;\n\nimport java.io.InputStream;\n\nimport java.io.OutputStream;\n\nimport java.nio.charset.Charset;\n",
        "comment": "\n\t * 检查是否为Base64\n\t *\n\t * @param base64Bytes Base64的bytes\n\t * @return 是否为Base64\n\t * @since 5.7.5\n\t ",
        "packageName": "cn.hutool.core.codec",
        "method_signature": "public static boolean isBase64(byte[] base64Bytes);",
        "Junit_version": "5",
        "returnType": "boolean"
    },
    {
        "Method_body": "public List<String[]> select(int m) {\n    final List<String[]> result = new ArrayList<>((int) count(this.datas.length, m));\n    select(this.datas, new String[m], 0, result);\n    return result;\n}",
        "all_field_declaration": "private static final long serialVersionUID = 1L;\nprivate final String[] datas;",
        "sub_project_name": "hutool-core",
        "lineNumbers": "3",
        "Filed": "private final String[] datas;",
        "Parameter_type": "int",
        "Import_statements": "import java.util.ArrayList;\nimport java.util.List;\n",
        "public_method_signature": "public Arrangement(String[] datas);\npublic static long count(int n);\npublic static long count(int n, int m);\npublic static long countAll(int n);\npublic List<String[]> select();\npublic List<String[]> select(int m);\npublic List<String[]> selectAll();",
        "public_field": "",
        "Method_statement": "select(int m)",
        "Method_name": "select",
        "Class_declaration": "public class Arrangement {\n",
        "constructors": "public Arrangement(String[] datas) {\n    this.datas = datas;\n}",
        "all_method_signature": "public Arrangement(String[] datas);\npublic static long count(int n);\npublic static long count(int n, int m);\npublic static long countAll(int n);\npublic List<String[]> select();\npublic List<String[]> select(int m);\npublic List<String[]> selectAll();\nprivate void select(String[] datas, String[] resultList, int resultIndex, List<String[]> result);",
        "Class_name": "Arrangement",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/math/Arrangement###select",
        "Parameter_num": "1",
        "all_Import_statements": "import java.io.Serializable;\n\nimport java.util.ArrayList;\n\nimport java.util.Arrays;\n\nimport java.util.List;\n\nimport cn.hutool.core.util.ArrayUtil;\n\nimport cn.hutool.core.util.NumberUtil;\n",
        "comment": "\n\t * 排列选择（从列表中选择m个排列）\n\t *\n\t * @param m 选择个数\n\t * @return 所有排列列表\n\t ",
        "packageName": "cn.hutool.core.math",
        "method_signature": "public List<String[]> select(int m);",
        "Junit_version": "5",
        "returnType": "List<String[]>"
    },
    {
        "Method_body": "public static boolean endWith(CharSequence str, CharSequence suffix, boolean ignoreCase, boolean ignoreEquals) {\n    if (null == str || null == suffix) {\n        if (ignoreEquals) {\n            return false;\n        }\n        return null == str && null == suffix;\n    }\n    final int strOffset = str.length() - suffix.length();\n    boolean isEndWith = str.toString().regionMatches(ignoreCase, strOffset, suffix.toString(), 0, suffix.length());\n    if (isEndWith) {\n        return (false == ignoreEquals) || (false == equals(str, suffix, ignoreCase));\n    }\n    return false;\n}",
        "all_field_declaration": "public static final int INDEX_NOT_FOUND = Finder.INDEX_NOT_FOUND;\n/**\n * 字符串常量：{@code \"null\"} <br>\n * 注意：{@code \"null\" != null}\n */\npublic static final String NULL = \"null\";\n/**\n * 字符串常量：空字符串 {@code \"\"}\n */\npublic static final String EMPTY = \"\";\n/**\n * 字符串常量：空格符 {@code \" \"}\n */\npublic static final String SPACE = \" \";",
        "sub_project_name": "hutool-core",
        "lineNumbers": "5",
        "Filed": "",
        "Parameter_type": "CharSequence,CharSequence,boolean,boolean",
        "Import_statements": "",
        "public_method_signature": "public static boolean isBlank(CharSequence str);\npublic static boolean isNotBlank(CharSequence str);\npublic static boolean hasBlank(CharSequence... strs);\npublic static boolean isAllBlank(CharSequence... strs);\npublic static boolean isEmpty(CharSequence str);\npublic static boolean isNotEmpty(CharSequence str);\npublic static String emptyIfNull(CharSequence str);\npublic static String nullToEmpty(CharSequence str);\npublic static String nullToDefault(CharSequence str, String defaultStr);\npublic static String emptyToDefault(CharSequence str, String defaultStr);\npublic static String blankToDefault(CharSequence str, String defaultStr);\npublic static String emptyToNull(CharSequence str);\npublic static boolean hasEmpty(CharSequence... strs);\npublic static boolean isAllEmpty(CharSequence... strs);\npublic static boolean isAllNotEmpty(CharSequence... args);\npublic static boolean isAllNotBlank(CharSequence... args);\npublic static boolean isNullOrUndefined(CharSequence str);\npublic static boolean isEmptyOrUndefined(CharSequence str);\npublic static boolean isBlankOrUndefined(CharSequence str);\npublic static String trim(CharSequence str);\npublic static String trimToEmpty(CharSequence str);\npublic static String trimToNull(CharSequence str);\npublic static String trimStart(CharSequence str);\npublic static String trimEnd(CharSequence str);\npublic static String trim(CharSequence str, int mode);\npublic static String trim(CharSequence str, int mode, Predicate<Character> predicate);\npublic static boolean startWith(CharSequence str, char c);\npublic static boolean startWith(CharSequence str, CharSequence prefix, boolean ignoreCase);\npublic static boolean startWith(CharSequence str, CharSequence prefix, boolean ignoreCase, boolean ignoreEquals);\npublic static boolean startWith(CharSequence str, CharSequence prefix);\npublic static boolean startWithIgnoreEquals(CharSequence str, CharSequence prefix);\npublic static boolean startWithIgnoreCase(CharSequence str, CharSequence prefix);\npublic static boolean startWithAny(CharSequence str, CharSequence... prefixes);\npublic static boolean startWithAnyIgnoreCase(final CharSequence str, final CharSequence... suffixes);\npublic static boolean endWith(CharSequence str, char c);\npublic static boolean endWith(CharSequence str, CharSequence suffix, boolean ignoreCase);\npublic static boolean endWith(CharSequence str, CharSequence suffix, boolean ignoreCase, boolean ignoreEquals);\npublic static boolean endWith(CharSequence str, CharSequence suffix);\npublic static boolean endWithIgnoreCase(CharSequence str, CharSequence suffix);\npublic static boolean endWithAny(CharSequence str, CharSequence... suffixes);\npublic static boolean endWithAnyIgnoreCase(CharSequence str, CharSequence... suffixes);\npublic static boolean contains(CharSequence str, char searchChar);\npublic static boolean contains(CharSequence str, CharSequence searchStr);\npublic static boolean containsAny(CharSequence str, CharSequence... testStrs);\npublic static boolean containsAny(CharSequence str, char... testChars);\npublic static boolean containsOnly(CharSequence str, char... testChars);\npublic static boolean containsAll(CharSequence str, CharSequence... testChars);\npublic static boolean containsBlank(CharSequence str);\npublic static String getContainsStr(CharSequence str, CharSequence... testStrs);\npublic static boolean containsIgnoreCase(CharSequence str, CharSequence testStr);\npublic static boolean containsAnyIgnoreCase(CharSequence str, CharSequence... testStrs);\npublic static String getContainsStrIgnoreCase(CharSequence str, CharSequence... testStrs);\npublic static int indexOf(CharSequence str, char searchChar);\npublic static int indexOf(CharSequence str, char searchChar, int start);\npublic static int indexOf(CharSequence text, char searchChar, int start, int end);\npublic static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr);\npublic static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int fromIndex);\npublic static int indexOf(CharSequence text, CharSequence searchStr, int from, boolean ignoreCase);\npublic static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr);\npublic static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr, int fromIndex);\npublic static int lastIndexOf(CharSequence text, CharSequence searchStr, int from, boolean ignoreCase);\npublic static int ordinalIndexOf(CharSequence str, CharSequence searchStr, int ordinal);\npublic static String removeAll(CharSequence str, CharSequence strToRemove);\npublic static String removeAny(CharSequence str, CharSequence... strsToRemove);\npublic static String removeAll(CharSequence str, char... chars);\npublic static String removeAllLineBreaks(CharSequence str);\npublic static String removePreAndLowerFirst(CharSequence str, int preLength);\npublic static String removePreAndLowerFirst(CharSequence str, CharSequence prefix);\npublic static String removePrefix(CharSequence str, CharSequence prefix);\npublic static String removePrefixIgnoreCase(CharSequence str, CharSequence prefix);\npublic static String removeSuffix(CharSequence str, CharSequence suffix);\npublic static String removeSufAndLowerFirst(CharSequence str, CharSequence suffix);\npublic static String removeSuffixIgnoreCase(CharSequence str, CharSequence suffix);\npublic static String cleanBlank(CharSequence str);\npublic static String strip(CharSequence str, CharSequence prefixOrSuffix);\npublic static String strip(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String stripIgnoreCase(CharSequence str, CharSequence prefixOrSuffix);\npublic static String stripIgnoreCase(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String addPrefixIfNot(CharSequence str, CharSequence prefix);\npublic static String addSuffixIfNot(CharSequence str, CharSequence suffix);\npublic static long[] splitToLong(CharSequence str, char separator);\npublic static long[] splitToLong(CharSequence str, CharSequence separator);\npublic static int[] splitToInt(CharSequence str, char separator);\npublic static int[] splitToInt(CharSequence str, CharSequence separator);\npublic static List<String> split(CharSequence str, char separator);\npublic static String[] splitToArray(CharSequence str, CharSequence separator);\npublic static String[] splitToArray(CharSequence str, char separator);\npublic static String[] splitToArray(CharSequence text, char separator, int limit);\npublic static List<String> split(CharSequence str, char separator, int limit);\npublic static List<String> splitTrim(CharSequence str, char separator);\npublic static List<String> splitTrim(CharSequence str, CharSequence separator);\npublic static List<String> splitTrim(CharSequence str, char separator, int limit);\npublic static List<String> splitTrim(CharSequence str, CharSequence separator, int limit);\npublic static List<String> split(CharSequence str, char separator, boolean isTrim, boolean ignoreEmpty);\npublic static List<String> split(CharSequence str, char separator, int limit, boolean isTrim, boolean ignoreEmpty);\npublic static List<R> split(CharSequence str, char separator, int limit, boolean ignoreEmpty, Function<String, R> mapping);\npublic static List<String> split(CharSequence str, CharSequence separator);\npublic static List<String> split(CharSequence str, CharSequence separator, boolean isTrim, boolean ignoreEmpty);\npublic static List<String> split(CharSequence str, CharSequence separator, int limit, boolean isTrim, boolean ignoreEmpty);\npublic static String[] split(CharSequence str, int len);\npublic static String[] cut(CharSequence str, int partLength);\npublic static String sub(CharSequence str, int fromIndexInclude, int toIndexExclude);\npublic static String subByCodePoint(CharSequence str, int fromIndex, int toIndex);\npublic static String subPreGbk(CharSequence str, int len, CharSequence suffix);\npublic static String subPreGbk(CharSequence str, int len, boolean halfUp);\npublic static String subPre(CharSequence string, int toIndexExclude);\npublic static String subSuf(CharSequence string, int fromIndex);\npublic static String subSufByLength(CharSequence string, int length);\npublic static String subWithLength(String input, int fromIndex, int length);\npublic static String subBefore(CharSequence string, CharSequence separator, boolean isLastSeparator);\npublic static String subBefore(CharSequence string, char separator, boolean isLastSeparator);\npublic static String subAfter(CharSequence string, CharSequence separator, boolean isLastSeparator);\npublic static String subAfter(CharSequence string, char separator, boolean isLastSeparator);\npublic static String subBetween(CharSequence str, CharSequence before, CharSequence after);\npublic static String subBetween(CharSequence str, CharSequence beforeAndAfter);\npublic static String[] subBetweenAll(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String[] subBetweenAll(CharSequence str, CharSequence prefixAndSuffix);\npublic static String repeat(char c, int count);\npublic static String repeat(CharSequence str, int count);\npublic static String repeatByLength(CharSequence str, int padLen);\npublic static String repeatAndJoin(CharSequence str, int count, CharSequence delimiter);\npublic static boolean equals(CharSequence str1, CharSequence str2);\npublic static boolean equalsIgnoreCase(CharSequence str1, CharSequence str2);\npublic static boolean equals(CharSequence str1, CharSequence str2, boolean ignoreCase);\npublic static boolean equalsAnyIgnoreCase(CharSequence str1, CharSequence... strs);\npublic static boolean equalsAny(CharSequence str1, CharSequence... strs);\npublic static boolean equalsAny(CharSequence str1, boolean ignoreCase, CharSequence... strs);\npublic static boolean equalsCharAt(CharSequence str, int position, char c);\npublic static boolean isSubEquals(CharSequence str1, int start1, CharSequence str2, boolean ignoreCase);\npublic static boolean isSubEquals(CharSequence str1, int start1, CharSequence str2, int start2, int length, boolean ignoreCase);\npublic static String format(CharSequence template, Object... params);\npublic static String indexedFormat(CharSequence pattern, Object... arguments);\npublic static byte[] utf8Bytes(CharSequence str);\npublic static byte[] bytes(CharSequence str);\npublic static byte[] bytes(CharSequence str, String charset);\npublic static byte[] bytes(CharSequence str, Charset charset);\npublic static ByteBuffer byteBuffer(CharSequence str, String charset);\npublic static String wrap(CharSequence str, CharSequence prefixAndSuffix);\npublic static String wrap(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String[] wrapAllWithPair(CharSequence prefixAndSuffix, CharSequence... strs);\npublic static String[] wrapAll(CharSequence prefix, CharSequence suffix, CharSequence... strs);\npublic static String wrapIfMissing(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String[] wrapAllWithPairIfMissing(CharSequence prefixAndSuffix, CharSequence... strs);\npublic static String[] wrapAllIfMissing(CharSequence prefix, CharSequence suffix, CharSequence... strs);\npublic static String unWrap(CharSequence str, String prefix, String suffix);\npublic static String unWrap(CharSequence str, char prefix, char suffix);\npublic static String unWrap(CharSequence str, char prefixAndSuffix);\npublic static boolean isWrap(CharSequence str, String prefix, String suffix);\npublic static boolean isWrap(CharSequence str, String wrapper);\npublic static boolean isWrap(CharSequence str, char wrapper);\npublic static boolean isWrap(CharSequence str, char prefixChar, char suffixChar);\npublic static String padPre(CharSequence str, int length, CharSequence padStr);\npublic static String padPre(CharSequence str, int length, char padChar);\npublic static String padAfter(CharSequence str, int length, char padChar);\npublic static String padAfter(CharSequence str, int length, CharSequence padStr);\npublic static String center(CharSequence str, final int size);\npublic static String center(CharSequence str, final int size, char padChar);\npublic static String center(CharSequence str, final int size, CharSequence padStr);\npublic static String str(CharSequence cs);\npublic static int count(CharSequence content, CharSequence strForSearch);\npublic static int count(CharSequence content, char charForSearch);\npublic static int compare(final CharSequence str1, final CharSequence str2, final boolean nullIsLess);\npublic static int compareIgnoreCase(CharSequence str1, CharSequence str2, boolean nullIsLess);\npublic static int compareVersion(CharSequence version1, CharSequence version2);\npublic static String appendIfMissing(CharSequence str, CharSequence suffix, CharSequence... suffixes);\npublic static String appendIfMissingIgnoreCase(CharSequence str, CharSequence suffix, CharSequence... suffixes);\npublic static String appendIfMissing(CharSequence str, CharSequence suffix, boolean ignoreCase, CharSequence... testSuffixes);\npublic static String prependIfMissing(CharSequence str, CharSequence prefix, CharSequence... prefixes);\npublic static String prependIfMissingIgnoreCase(CharSequence str, CharSequence prefix, CharSequence... prefixes);\npublic static String prependIfMissing(CharSequence str, CharSequence prefix, boolean ignoreCase, CharSequence... prefixes);\npublic static String replaceIgnoreCase(CharSequence str, CharSequence searchStr, CharSequence replacement);\npublic static String replace(CharSequence str, CharSequence searchStr, CharSequence replacement);\npublic static String replace(CharSequence str, CharSequence searchStr, CharSequence replacement, boolean ignoreCase);\npublic static String replace(CharSequence str, int fromIndex, CharSequence searchStr, CharSequence replacement, boolean ignoreCase);\npublic static String replace(CharSequence str, int startInclude, int endExclude, char replacedChar);\npublic static String replace(CharSequence str, int startInclude, int endExclude, CharSequence replacedStr);\npublic static String replace(CharSequence str, java.util.regex.Pattern pattern, Func1<java.util.regex.Matcher, String> replaceFun);\npublic static String replace(CharSequence str, String regex, Func1<java.util.regex.Matcher, String> replaceFun);\npublic static String replaceLast(CharSequence str, CharSequence searchStr, CharSequence replacedStr);\npublic static String replaceLast(CharSequence str, CharSequence searchStr, CharSequence replacedStr, boolean ignoreCase);\npublic static String replaceFirst(CharSequence str, CharSequence searchStr, CharSequence replacedStr);\npublic static String replaceFirst(CharSequence str, CharSequence searchStr, CharSequence replacedStr, boolean ignoreCase);\npublic static String hide(CharSequence str, int startInclude, int endExclude);\npublic static String desensitized(CharSequence str, DesensitizedUtil.DesensitizedType desensitizedType);\npublic static String replaceChars(CharSequence str, String chars, CharSequence replacedStr);\npublic static String replaceChars(CharSequence str, char[] chars, CharSequence replacedStr);\npublic static int length(CharSequence cs);\npublic static int byteLength(CharSequence cs, Charset charset);\npublic static int totalLength(CharSequence... strs);\npublic static String maxLength(CharSequence string, int length);\npublic static T firstNonNull(T... strs);\npublic static T firstNonEmpty(T... strs);\npublic static T firstNonBlank(T... strs);\npublic static String upperFirstAndAddPre(CharSequence str, String preString);\npublic static String upperFirst(CharSequence str);\npublic static String lowerFirst(CharSequence str);\npublic static String filter(CharSequence str, final Filter<Character> filter);\npublic static boolean isUpperCase(CharSequence str);\npublic static boolean isLowerCase(CharSequence str);\npublic static String swapCase(final String str);\npublic static String toUnderlineCase(CharSequence str);\npublic static String toSymbolCase(CharSequence str, char symbol);\npublic static String toCamelCase(CharSequence name);\npublic static String toCamelCase(CharSequence name, char symbol);\npublic static boolean isSurround(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static boolean isSurround(CharSequence str, char prefix, char suffix);\npublic static StringBuilder builder(CharSequence... strs);\npublic static StrBuilder strBuilder(CharSequence... strs);\npublic static String getGeneralField(CharSequence getOrSetMethodName);\npublic static String genSetter(CharSequence fieldName);\npublic static String genGetter(CharSequence fieldName);\npublic static String concat(boolean isNullToEmpty, CharSequence... strs);\npublic static String brief(CharSequence str, int maxLength);\npublic static String join(CharSequence conjunction, Object... objs);\npublic static String join(CharSequence conjunction, Iterable<T> iterable);\npublic static boolean isAllCharMatch(CharSequence value, Matcher<Character> matcher);\npublic static boolean isNumeric(CharSequence str);\npublic static String move(CharSequence str, int startInclude, int endExclude, int moveLength);\npublic static boolean isCharEquals(CharSequence str);\npublic static String normalize(CharSequence str);\npublic static String fixLength(CharSequence str, char fixedChar, int length);\npublic static boolean hasLetter(CharSequence str);\npublic static CharSequence commonPrefix(CharSequence str1, CharSequence str2);\npublic static CharSequence commonSuffix(CharSequence str1, CharSequence str2);",
        "public_field": "public static final int INDEX_NOT_FOUND = Finder.INDEX_NOT_FOUND;\n/**\n * 字符串常量：{@code \"null\"} <br>\n * 注意：{@code \"null\" != null}\n */\npublic static final String NULL = \"null\";\n/**\n * 字符串常量：空字符串 {@code \"\"}\n */\npublic static final String EMPTY = \"\";\n/**\n * 字符串常量：空格符 {@code \" \"}\n */\npublic static final String SPACE = \" \";",
        "Method_statement": "endWith(CharSequence str, CharSequence suffix, boolean ignoreCase, boolean ignoreEquals)",
        "Method_name": "endWith",
        "Class_declaration": "public class CharSequenceUtil {\n",
        "constructors": "",
        "all_method_signature": "public static boolean isBlank(CharSequence str);\npublic static boolean isNotBlank(CharSequence str);\npublic static boolean hasBlank(CharSequence... strs);\npublic static boolean isAllBlank(CharSequence... strs);\npublic static boolean isEmpty(CharSequence str);\npublic static boolean isNotEmpty(CharSequence str);\npublic static String emptyIfNull(CharSequence str);\npublic static String nullToEmpty(CharSequence str);\npublic static String nullToDefault(CharSequence str, String defaultStr);\npublic static String emptyToDefault(CharSequence str, String defaultStr);\npublic static String blankToDefault(CharSequence str, String defaultStr);\npublic static String emptyToNull(CharSequence str);\npublic static boolean hasEmpty(CharSequence... strs);\npublic static boolean isAllEmpty(CharSequence... strs);\npublic static boolean isAllNotEmpty(CharSequence... args);\npublic static boolean isAllNotBlank(CharSequence... args);\npublic static boolean isNullOrUndefined(CharSequence str);\npublic static boolean isEmptyOrUndefined(CharSequence str);\npublic static boolean isBlankOrUndefined(CharSequence str);\nprivate static boolean isNullOrUndefinedStr(CharSequence str);\npublic static String trim(CharSequence str);\npublic static String trimToEmpty(CharSequence str);\npublic static String trimToNull(CharSequence str);\npublic static String trimStart(CharSequence str);\npublic static String trimEnd(CharSequence str);\npublic static String trim(CharSequence str, int mode);\npublic static String trim(CharSequence str, int mode, Predicate<Character> predicate);\npublic static boolean startWith(CharSequence str, char c);\npublic static boolean startWith(CharSequence str, CharSequence prefix, boolean ignoreCase);\npublic static boolean startWith(CharSequence str, CharSequence prefix, boolean ignoreCase, boolean ignoreEquals);\npublic static boolean startWith(CharSequence str, CharSequence prefix);\npublic static boolean startWithIgnoreEquals(CharSequence str, CharSequence prefix);\npublic static boolean startWithIgnoreCase(CharSequence str, CharSequence prefix);\npublic static boolean startWithAny(CharSequence str, CharSequence... prefixes);\npublic static boolean startWithAnyIgnoreCase(final CharSequence str, final CharSequence... suffixes);\npublic static boolean endWith(CharSequence str, char c);\npublic static boolean endWith(CharSequence str, CharSequence suffix, boolean ignoreCase);\npublic static boolean endWith(CharSequence str, CharSequence suffix, boolean ignoreCase, boolean ignoreEquals);\npublic static boolean endWith(CharSequence str, CharSequence suffix);\npublic static boolean endWithIgnoreCase(CharSequence str, CharSequence suffix);\npublic static boolean endWithAny(CharSequence str, CharSequence... suffixes);\npublic static boolean endWithAnyIgnoreCase(CharSequence str, CharSequence... suffixes);\npublic static boolean contains(CharSequence str, char searchChar);\npublic static boolean contains(CharSequence str, CharSequence searchStr);\npublic static boolean containsAny(CharSequence str, CharSequence... testStrs);\npublic static boolean containsAny(CharSequence str, char... testChars);\npublic static boolean containsOnly(CharSequence str, char... testChars);\npublic static boolean containsAll(CharSequence str, CharSequence... testChars);\npublic static boolean containsBlank(CharSequence str);\npublic static String getContainsStr(CharSequence str, CharSequence... testStrs);\npublic static boolean containsIgnoreCase(CharSequence str, CharSequence testStr);\npublic static boolean containsAnyIgnoreCase(CharSequence str, CharSequence... testStrs);\npublic static String getContainsStrIgnoreCase(CharSequence str, CharSequence... testStrs);\npublic static int indexOf(CharSequence str, char searchChar);\npublic static int indexOf(CharSequence str, char searchChar, int start);\npublic static int indexOf(CharSequence text, char searchChar, int start, int end);\npublic static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr);\npublic static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int fromIndex);\npublic static int indexOf(CharSequence text, CharSequence searchStr, int from, boolean ignoreCase);\npublic static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr);\npublic static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr, int fromIndex);\npublic static int lastIndexOf(CharSequence text, CharSequence searchStr, int from, boolean ignoreCase);\npublic static int ordinalIndexOf(CharSequence str, CharSequence searchStr, int ordinal);\npublic static String removeAll(CharSequence str, CharSequence strToRemove);\npublic static String removeAny(CharSequence str, CharSequence... strsToRemove);\npublic static String removeAll(CharSequence str, char... chars);\npublic static String removeAllLineBreaks(CharSequence str);\npublic static String removePreAndLowerFirst(CharSequence str, int preLength);\npublic static String removePreAndLowerFirst(CharSequence str, CharSequence prefix);\npublic static String removePrefix(CharSequence str, CharSequence prefix);\npublic static String removePrefixIgnoreCase(CharSequence str, CharSequence prefix);\npublic static String removeSuffix(CharSequence str, CharSequence suffix);\npublic static String removeSufAndLowerFirst(CharSequence str, CharSequence suffix);\npublic static String removeSuffixIgnoreCase(CharSequence str, CharSequence suffix);\npublic static String cleanBlank(CharSequence str);\npublic static String strip(CharSequence str, CharSequence prefixOrSuffix);\npublic static String strip(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String stripIgnoreCase(CharSequence str, CharSequence prefixOrSuffix);\npublic static String stripIgnoreCase(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String addPrefixIfNot(CharSequence str, CharSequence prefix);\npublic static String addSuffixIfNot(CharSequence str, CharSequence suffix);\npublic static long[] splitToLong(CharSequence str, char separator);\npublic static long[] splitToLong(CharSequence str, CharSequence separator);\npublic static int[] splitToInt(CharSequence str, char separator);\npublic static int[] splitToInt(CharSequence str, CharSequence separator);\npublic static List<String> split(CharSequence str, char separator);\npublic static String[] splitToArray(CharSequence str, CharSequence separator);\npublic static String[] splitToArray(CharSequence str, char separator);\npublic static String[] splitToArray(CharSequence text, char separator, int limit);\npublic static List<String> split(CharSequence str, char separator, int limit);\npublic static List<String> splitTrim(CharSequence str, char separator);\npublic static List<String> splitTrim(CharSequence str, CharSequence separator);\npublic static List<String> splitTrim(CharSequence str, char separator, int limit);\npublic static List<String> splitTrim(CharSequence str, CharSequence separator, int limit);\npublic static List<String> split(CharSequence str, char separator, boolean isTrim, boolean ignoreEmpty);\npublic static List<String> split(CharSequence str, char separator, int limit, boolean isTrim, boolean ignoreEmpty);\npublic static List<R> split(CharSequence str, char separator, int limit, boolean ignoreEmpty, Function<String, R> mapping);\npublic static List<String> split(CharSequence str, CharSequence separator);\npublic static List<String> split(CharSequence str, CharSequence separator, boolean isTrim, boolean ignoreEmpty);\npublic static List<String> split(CharSequence str, CharSequence separator, int limit, boolean isTrim, boolean ignoreEmpty);\npublic static String[] split(CharSequence str, int len);\npublic static String[] cut(CharSequence str, int partLength);\npublic static String sub(CharSequence str, int fromIndexInclude, int toIndexExclude);\npublic static String subByCodePoint(CharSequence str, int fromIndex, int toIndex);\npublic static String subPreGbk(CharSequence str, int len, CharSequence suffix);\npublic static String subPreGbk(CharSequence str, int len, boolean halfUp);\npublic static String subPre(CharSequence string, int toIndexExclude);\npublic static String subSuf(CharSequence string, int fromIndex);\npublic static String subSufByLength(CharSequence string, int length);\npublic static String subWithLength(String input, int fromIndex, int length);\npublic static String subBefore(CharSequence string, CharSequence separator, boolean isLastSeparator);\npublic static String subBefore(CharSequence string, char separator, boolean isLastSeparator);\npublic static String subAfter(CharSequence string, CharSequence separator, boolean isLastSeparator);\npublic static String subAfter(CharSequence string, char separator, boolean isLastSeparator);\npublic static String subBetween(CharSequence str, CharSequence before, CharSequence after);\npublic static String subBetween(CharSequence str, CharSequence beforeAndAfter);\npublic static String[] subBetweenAll(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String[] subBetweenAll(CharSequence str, CharSequence prefixAndSuffix);\npublic static String repeat(char c, int count);\npublic static String repeat(CharSequence str, int count);\npublic static String repeatByLength(CharSequence str, int padLen);\npublic static String repeatAndJoin(CharSequence str, int count, CharSequence delimiter);\npublic static boolean equals(CharSequence str1, CharSequence str2);\npublic static boolean equalsIgnoreCase(CharSequence str1, CharSequence str2);\npublic static boolean equals(CharSequence str1, CharSequence str2, boolean ignoreCase);\npublic static boolean equalsAnyIgnoreCase(CharSequence str1, CharSequence... strs);\npublic static boolean equalsAny(CharSequence str1, CharSequence... strs);\npublic static boolean equalsAny(CharSequence str1, boolean ignoreCase, CharSequence... strs);\npublic static boolean equalsCharAt(CharSequence str, int position, char c);\npublic static boolean isSubEquals(CharSequence str1, int start1, CharSequence str2, boolean ignoreCase);\npublic static boolean isSubEquals(CharSequence str1, int start1, CharSequence str2, int start2, int length, boolean ignoreCase);\npublic static String format(CharSequence template, Object... params);\npublic static String indexedFormat(CharSequence pattern, Object... arguments);\npublic static byte[] utf8Bytes(CharSequence str);\npublic static byte[] bytes(CharSequence str);\npublic static byte[] bytes(CharSequence str, String charset);\npublic static byte[] bytes(CharSequence str, Charset charset);\npublic static ByteBuffer byteBuffer(CharSequence str, String charset);\npublic static String wrap(CharSequence str, CharSequence prefixAndSuffix);\npublic static String wrap(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String[] wrapAllWithPair(CharSequence prefixAndSuffix, CharSequence... strs);\npublic static String[] wrapAll(CharSequence prefix, CharSequence suffix, CharSequence... strs);\npublic static String wrapIfMissing(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String[] wrapAllWithPairIfMissing(CharSequence prefixAndSuffix, CharSequence... strs);\npublic static String[] wrapAllIfMissing(CharSequence prefix, CharSequence suffix, CharSequence... strs);\npublic static String unWrap(CharSequence str, String prefix, String suffix);\npublic static String unWrap(CharSequence str, char prefix, char suffix);\npublic static String unWrap(CharSequence str, char prefixAndSuffix);\npublic static boolean isWrap(CharSequence str, String prefix, String suffix);\npublic static boolean isWrap(CharSequence str, String wrapper);\npublic static boolean isWrap(CharSequence str, char wrapper);\npublic static boolean isWrap(CharSequence str, char prefixChar, char suffixChar);\npublic static String padPre(CharSequence str, int length, CharSequence padStr);\npublic static String padPre(CharSequence str, int length, char padChar);\npublic static String padAfter(CharSequence str, int length, char padChar);\npublic static String padAfter(CharSequence str, int length, CharSequence padStr);\npublic static String center(CharSequence str, final int size);\npublic static String center(CharSequence str, final int size, char padChar);\npublic static String center(CharSequence str, final int size, CharSequence padStr);\npublic static String str(CharSequence cs);\npublic static int count(CharSequence content, CharSequence strForSearch);\npublic static int count(CharSequence content, char charForSearch);\npublic static int compare(final CharSequence str1, final CharSequence str2, final boolean nullIsLess);\npublic static int compareIgnoreCase(CharSequence str1, CharSequence str2, boolean nullIsLess);\npublic static int compareVersion(CharSequence version1, CharSequence version2);\npublic static String appendIfMissing(CharSequence str, CharSequence suffix, CharSequence... suffixes);\npublic static String appendIfMissingIgnoreCase(CharSequence str, CharSequence suffix, CharSequence... suffixes);\npublic static String appendIfMissing(CharSequence str, CharSequence suffix, boolean ignoreCase, CharSequence... testSuffixes);\npublic static String prependIfMissing(CharSequence str, CharSequence prefix, CharSequence... prefixes);\npublic static String prependIfMissingIgnoreCase(CharSequence str, CharSequence prefix, CharSequence... prefixes);\npublic static String prependIfMissing(CharSequence str, CharSequence prefix, boolean ignoreCase, CharSequence... prefixes);\npublic static String replaceIgnoreCase(CharSequence str, CharSequence searchStr, CharSequence replacement);\npublic static String replace(CharSequence str, CharSequence searchStr, CharSequence replacement);\npublic static String replace(CharSequence str, CharSequence searchStr, CharSequence replacement, boolean ignoreCase);\npublic static String replace(CharSequence str, int fromIndex, CharSequence searchStr, CharSequence replacement, boolean ignoreCase);\npublic static String replace(CharSequence str, int startInclude, int endExclude, char replacedChar);\npublic static String replace(CharSequence str, int startInclude, int endExclude, CharSequence replacedStr);\npublic static String replace(CharSequence str, java.util.regex.Pattern pattern, Func1<java.util.regex.Matcher, String> replaceFun);\npublic static String replace(CharSequence str, String regex, Func1<java.util.regex.Matcher, String> replaceFun);\npublic static String replaceLast(CharSequence str, CharSequence searchStr, CharSequence replacedStr);\npublic static String replaceLast(CharSequence str, CharSequence searchStr, CharSequence replacedStr, boolean ignoreCase);\npublic static String replaceFirst(CharSequence str, CharSequence searchStr, CharSequence replacedStr);\npublic static String replaceFirst(CharSequence str, CharSequence searchStr, CharSequence replacedStr, boolean ignoreCase);\npublic static String hide(CharSequence str, int startInclude, int endExclude);\npublic static String desensitized(CharSequence str, DesensitizedUtil.DesensitizedType desensitizedType);\npublic static String replaceChars(CharSequence str, String chars, CharSequence replacedStr);\npublic static String replaceChars(CharSequence str, char[] chars, CharSequence replacedStr);\npublic static int length(CharSequence cs);\npublic static int byteLength(CharSequence cs, Charset charset);\npublic static int totalLength(CharSequence... strs);\npublic static String maxLength(CharSequence string, int length);\npublic static T firstNonNull(T... strs);\npublic static T firstNonEmpty(T... strs);\npublic static T firstNonBlank(T... strs);\npublic static String upperFirstAndAddPre(CharSequence str, String preString);\npublic static String upperFirst(CharSequence str);\npublic static String lowerFirst(CharSequence str);\npublic static String filter(CharSequence str, final Filter<Character> filter);\npublic static boolean isUpperCase(CharSequence str);\npublic static boolean isLowerCase(CharSequence str);\npublic static String swapCase(final String str);\npublic static String toUnderlineCase(CharSequence str);\npublic static String toSymbolCase(CharSequence str, char symbol);\npublic static String toCamelCase(CharSequence name);\npublic static String toCamelCase(CharSequence name, char symbol);\npublic static boolean isSurround(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static boolean isSurround(CharSequence str, char prefix, char suffix);\npublic static StringBuilder builder(CharSequence... strs);\npublic static StrBuilder strBuilder(CharSequence... strs);\npublic static String getGeneralField(CharSequence getOrSetMethodName);\npublic static String genSetter(CharSequence fieldName);\npublic static String genGetter(CharSequence fieldName);\npublic static String concat(boolean isNullToEmpty, CharSequence... strs);\npublic static String brief(CharSequence str, int maxLength);\npublic static String join(CharSequence conjunction, Object... objs);\npublic static String join(CharSequence conjunction, Iterable<T> iterable);\npublic static boolean isAllCharMatch(CharSequence value, Matcher<Character> matcher);\npublic static boolean isNumeric(CharSequence str);\npublic static String move(CharSequence str, int startInclude, int endExclude, int moveLength);\npublic static boolean isCharEquals(CharSequence str);\npublic static String normalize(CharSequence str);\npublic static String fixLength(CharSequence str, char fixedChar, int length);\npublic static boolean hasLetter(CharSequence str);\npublic static CharSequence commonPrefix(CharSequence str1, CharSequence str2);\npublic static CharSequence commonSuffix(CharSequence str1, CharSequence str2);",
        "Class_name": "CharSequenceUtil",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/text/CharSequenceUtil###endWith",
        "Parameter_num": "4",
        "all_Import_statements": "import cn.hutool.core.collection.CollUtil;\n\nimport cn.hutool.core.comparator.VersionComparator;\n\nimport cn.hutool.core.convert.Convert;\n\nimport cn.hutool.core.lang.Assert;\n\nimport cn.hutool.core.lang.Filter;\n\nimport cn.hutool.core.lang.Matcher;\n\nimport cn.hutool.core.lang.func.Func1;\n\nimport cn.hutool.core.text.finder.CharFinder;\n\nimport cn.hutool.core.text.finder.Finder;\n\nimport cn.hutool.core.text.finder.StrFinder;\n\nimport cn.hutool.core.util.ArrayUtil;\n\nimport cn.hutool.core.util.CharUtil;\n\nimport cn.hutool.core.util.CharsetUtil;\n\nimport cn.hutool.core.util.DesensitizedUtil;\n\nimport cn.hutool.core.util.NumberUtil;\n\nimport cn.hutool.core.util.ReUtil;\n\nimport cn.hutool.core.util.StrUtil;\n\nimport java.nio.ByteBuffer;\n\nimport java.nio.charset.Charset;\n\nimport java.text.MessageFormat;\n\nimport java.text.Normalizer;\n\nimport java.util.HashSet;\n\nimport java.util.LinkedList;\n\nimport java.util.List;\n\nimport java.util.Set;\n\nimport java.util.function.Function;\n\nimport java.util.function.Predicate;\n",
        "comment": "\n\t * 是否以指定字符串结尾<br>\n\t * 如果给定的字符串和开头字符串都为null则返回true，否则任意一个值为null返回false\n\t *\n\t * @param str          被监测字符串\n\t * @param suffix       结尾字符串\n\t * @param ignoreCase   是否忽略大小写\n\t * @param ignoreEquals 是否忽略字符串相等的情况\n\t * @return 是否以指定字符串结尾\n\t * @since 5.8.0\n\t ",
        "packageName": "cn.hutool.core.text",
        "method_signature": "public static boolean endWith(CharSequence str, CharSequence suffix, boolean ignoreCase, boolean ignoreEquals);",
        "Junit_version": "5",
        "returnType": "boolean"
    },
    {
        "Method_body": "public long betweenYear(boolean isReset) {\n    final Calendar beginCal = DateUtil.calendar(begin);\n    final Calendar endCal = DateUtil.calendar(end);\n    int result = endCal.get(Calendar.YEAR) - beginCal.get(Calendar.YEAR);\n    if (false == isReset) {\n        if (Calendar.FEBRUARY == beginCal.get(Calendar.MONTH) && Calendar.FEBRUARY == endCal.get(Calendar.MONTH)) {\n            if (beginCal.get(Calendar.DAY_OF_MONTH) == beginCal.getActualMaximum(Calendar.DAY_OF_MONTH) && endCal.get(Calendar.DAY_OF_MONTH) == endCal.getActualMaximum(Calendar.DAY_OF_MONTH)) {\n                beginCal.set(Calendar.DAY_OF_MONTH, 1);\n                endCal.set(Calendar.DAY_OF_MONTH, 1);\n            }\n        }\n        endCal.set(Calendar.YEAR, beginCal.get(Calendar.YEAR));\n        long between = endCal.getTimeInMillis() - beginCal.getTimeInMillis();\n        if (between < 0) {\n            return result - 1;\n        }\n    }\n    return result;\n}",
        "all_field_declaration": "private static final long serialVersionUID = 1L;\n/**\n * 开始日期\n */\nprivate final Date begin;\n/**\n * 结束日期\n */\nprivate final Date end;",
        "sub_project_name": "hutool-core",
        "lineNumbers": "5",
        "Filed": "private final Date begin;private final Date end;",
        "Parameter_type": "boolean",
        "Import_statements": "import java.util.Calendar;\nimport java.util.Date;\n",
        "public_method_signature": "public static DateBetween create(Date begin, Date end);\npublic static DateBetween create(Date begin, Date end, boolean isAbs);\npublic DateBetween(Date begin, Date end);\npublic DateBetween(Date begin, Date end, boolean isAbs);\npublic long between(DateUnit unit);\npublic long betweenMonth(boolean isReset);\npublic long betweenYear(boolean isReset);\npublic String toString(DateUnit unit, BetweenFormatter.Level level);\npublic String toString(BetweenFormatter.Level level);\npublic String toString();",
        "public_field": "",
        "Method_statement": "betweenYear(boolean isReset)",
        "Method_name": "betweenYear",
        "Class_declaration": "public class DateBetween {\n",
        "constructors": "public DateBetween(Date begin, Date end) {\n    this(begin, end, true);\n}public DateBetween(Date begin, Date end, boolean isAbs) {\n    Assert.notNull(begin, \"Begin date is null !\");\n    Assert.notNull(end, \"End date is null !\");\n    if (isAbs && begin.after(end)) {\n        this.begin = end;\n        this.end = begin;\n    } else {\n        this.begin = begin;\n        this.end = end;\n    }\n}",
        "all_method_signature": "public static DateBetween create(Date begin, Date end);\npublic static DateBetween create(Date begin, Date end, boolean isAbs);\npublic DateBetween(Date begin, Date end);\npublic DateBetween(Date begin, Date end, boolean isAbs);\npublic long between(DateUnit unit);\npublic long betweenMonth(boolean isReset);\npublic long betweenYear(boolean isReset);\npublic String toString(DateUnit unit, BetweenFormatter.Level level);\npublic String toString(BetweenFormatter.Level level);\npublic String toString();",
        "Class_name": "DateBetween",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/date/DateBetween###betweenYear",
        "Parameter_num": "1",
        "all_Import_statements": "import cn.hutool.core.lang.Assert;\n\nimport java.io.Serializable;\n\nimport java.util.Calendar;\n\nimport java.util.Date;\n",
        "comment": "\n\t * 计算两个日期相差年数<br>\n\t * 在非重置情况下，如果起始日期的月大于结束日期的月，年数要少算1（不足1年）\n\t *\n\t * @param isReset 是否重置时间为起始时间（重置月天时分秒）\n\t * @return 相差年数\n\t * @since 3.0.8\n\t ",
        "packageName": "cn.hutool.core.date",
        "method_signature": "public long betweenYear(boolean isReset);",
        "Junit_version": "5",
        "returnType": "long"
    },
    {
        "Method_body": "@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\npublic static <T> int compare(T o1, T o2, boolean isNullGreater) {\n    if (o1 == o2) {\n        return 0;\n    } else if (null == o1) {\n        return isNullGreater ? 1 : -1;\n    } else if (null == o2) {\n        return isNullGreater ? -1 : 1;\n    }\n    if (o1 instanceof Comparable && o2 instanceof Comparable) {\n        return ((Comparable) o1).compareTo(o2);\n    }\n    if (o1.equals(o2)) {\n        return 0;\n    }\n    int result = Integer.compare(o1.hashCode(), o2.hashCode());\n    if (0 == result) {\n        result = compare(o1.toString(), o2.toString());\n    }\n    return result;\n}",
        "all_field_declaration": "",
        "sub_project_name": "hutool-core",
        "lineNumbers": "6",
        "Filed": "",
        "Parameter_type": "T,T,boolean",
        "Import_statements": "",
        "public_method_signature": "public static Comparator<E> naturalComparator();\npublic static int compare(T c1, T c2, Comparator<T> comparator);\npublic static int compare(T c1, T c2);\npublic static int compare(T c1, T c2, boolean isNullGreater);\npublic static int compare(T o1, T o2, boolean isNullGreater);\npublic static Comparator<T> comparingPinyin(Function<T, String> keyExtractor);\npublic static Comparator<T> comparingPinyin(Function<T, String> keyExtractor, boolean reverse);\npublic static Comparator<T> comparingIndexed(Function<? super T, ? extends U> keyExtractor, U... objs);\npublic static Comparator<T> comparingIndexed(Function<? super T, ? extends U> keyExtractor, boolean atEndIfMiss, U... objs);",
        "public_field": "",
        "Method_statement": "compare(T o1, T o2, boolean isNullGreater)",
        "Method_name": "compare",
        "Class_declaration": "public class CompareUtil {\n",
        "constructors": "",
        "all_method_signature": "public static Comparator<E> naturalComparator();\npublic static int compare(T c1, T c2, Comparator<T> comparator);\npublic static int compare(T c1, T c2);\npublic static int compare(T c1, T c2, boolean isNullGreater);\npublic static int compare(T o1, T o2, boolean isNullGreater);\npublic static Comparator<T> comparingPinyin(Function<T, String> keyExtractor);\npublic static Comparator<T> comparingPinyin(Function<T, String> keyExtractor, boolean reverse);\npublic static Comparator<T> comparingIndexed(Function<? super T, ? extends U> keyExtractor, U... objs);\npublic static Comparator<T> comparingIndexed(Function<? super T, ? extends U> keyExtractor, boolean atEndIfMiss, U... objs);",
        "Class_name": "CompareUtil",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/comparator/CompareUtil###compare",
        "Parameter_num": "3",
        "all_Import_statements": "import java.util.Comparator;\n\nimport java.util.Objects;\n\nimport java.util.function.Function;\n",
        "comment": "\n\t * 自然比较两个对象的大小，比较规则如下：\n\t *\n\t * <pre>\n\t * 1、如果实现Comparable调用compareTo比较\n\t * 2、o1.equals(o2)返回0\n\t * 3、比较hashCode值\n\t * 4、比较toString值\n\t * </pre>\n\t *\n\t * @param <T>           被比较对象类型\n\t * @param o1            对象1\n\t * @param o2            对象2\n\t * @param isNullGreater null值是否做为最大值\n\t * @return 比较结果，如果o1 &lt; o2，返回数小于0，o1==o2返回0，o1 &gt; o2 大于0\n\t ",
        "packageName": "cn.hutool.core.comparator",
        "method_signature": "public static int compare(T o1, T o2, boolean isNullGreater);",
        "Junit_version": "5",
        "returnType": "int"
    },
    {
        "Method_body": "public static byte[] readBytes(ByteBuffer buffer, int maxLength) {\n    final int remaining = buffer.remaining();\n    if (maxLength > remaining) {\n        maxLength = remaining;\n    }\n    byte[] ab = new byte[maxLength];\n    buffer.get(ab);\n    return ab;\n}",
        "all_field_declaration": "",
        "sub_project_name": "hutool-core",
        "lineNumbers": "5",
        "Filed": "",
        "Parameter_type": "ByteBuffer,int",
        "Import_statements": "import java.nio.ByteBuffer;\n",
        "public_method_signature": "public static ByteBuffer copy(ByteBuffer src, int start, int end);\npublic static ByteBuffer copy(ByteBuffer src, ByteBuffer dest);\npublic static ByteBuffer copy(ByteBuffer src, ByteBuffer dest, int length);\npublic static ByteBuffer copy(ByteBuffer src, int srcStart, ByteBuffer dest, int destStart, int length);\npublic static String readUtf8Str(ByteBuffer buffer);\npublic static String readStr(ByteBuffer buffer, Charset charset);\npublic static byte[] readBytes(ByteBuffer buffer);\npublic static byte[] readBytes(ByteBuffer buffer, int maxLength);\npublic static byte[] readBytes(ByteBuffer buffer, int start, int end);\npublic static int lineEnd(ByteBuffer buffer);\npublic static int lineEnd(ByteBuffer buffer, int maxLength);\npublic static String readLine(ByteBuffer buffer, Charset charset);\npublic static ByteBuffer create(byte[] data);\npublic static ByteBuffer create(CharSequence data, Charset charset);\npublic static ByteBuffer createUtf8(CharSequence data);\npublic static CharBuffer createCharBuffer(int capacity);",
        "public_field": "",
        "Method_statement": "readBytes(ByteBuffer buffer, int maxLength)",
        "Method_name": "readBytes",
        "Class_declaration": "public class BufferUtil {\n",
        "constructors": "",
        "all_method_signature": "public static ByteBuffer copy(ByteBuffer src, int start, int end);\npublic static ByteBuffer copy(ByteBuffer src, ByteBuffer dest);\npublic static ByteBuffer copy(ByteBuffer src, ByteBuffer dest, int length);\npublic static ByteBuffer copy(ByteBuffer src, int srcStart, ByteBuffer dest, int destStart, int length);\npublic static String readUtf8Str(ByteBuffer buffer);\npublic static String readStr(ByteBuffer buffer, Charset charset);\npublic static byte[] readBytes(ByteBuffer buffer);\npublic static byte[] readBytes(ByteBuffer buffer, int maxLength);\npublic static byte[] readBytes(ByteBuffer buffer, int start, int end);\npublic static int lineEnd(ByteBuffer buffer);\npublic static int lineEnd(ByteBuffer buffer, int maxLength);\npublic static String readLine(ByteBuffer buffer, Charset charset);\npublic static ByteBuffer create(byte[] data);\npublic static ByteBuffer create(CharSequence data, Charset charset);\npublic static ByteBuffer createUtf8(CharSequence data);\npublic static CharBuffer createCharBuffer(int capacity);",
        "Class_name": "BufferUtil",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/io/BufferUtil###readBytes",
        "Parameter_num": "2",
        "all_Import_statements": "import cn.hutool.core.util.CharsetUtil;\n\nimport cn.hutool.core.util.StrUtil;\n\nimport java.nio.ByteBuffer;\n\nimport java.nio.CharBuffer;\n\nimport java.nio.charset.Charset;\n",
        "comment": "\n\t * 读取指定长度的bytes<br>\n\t * 如果长度不足，则读取剩余部分，此时buffer必须为读模式\n\t *\n\t * @param buffer    ByteBuffer\n\t * @param maxLength 最大长度\n\t * @return bytes\n\t ",
        "packageName": "cn.hutool.core.io",
        "method_signature": "public static byte[] readBytes(ByteBuffer buffer, int maxLength);",
        "Junit_version": "5",
        "returnType": "byte[]"
    },
    {
        "Method_body": "public static int hash32(byte[] data) {\n    int len = data.length;\n    if (len <= 24) {\n        return len <= 12 ? (len <= 4 ? hash32Len0to4(data) : hash32Len5to12(data)) : hash32Len13to24(data);\n    }\n    int h = len, g = c1 * len, f = g;\n    int a0 = rotate32(fetch32(data, len - 4) * c1, 17) * c2;\n    int a1 = rotate32(fetch32(data, len - 8) * c1, 17) * c2;\n    int a2 = rotate32(fetch32(data, len - 16) * c1, 17) * c2;\n    int a3 = rotate32(fetch32(data, len - 12) * c1, 17) * c2;\n    int a4 = rotate32(fetch32(data, len - 20) * c1, 17) * c2;\n    h ^= a0;\n    h = rotate32(h, 19);\n    h = h * 5 + 0xe6546b64;\n    h ^= a2;\n    h = rotate32(h, 19);\n    h = h * 5 + 0xe6546b64;\n    g ^= a1;\n    g = rotate32(g, 19);\n    g = g * 5 + 0xe6546b64;\n    g ^= a3;\n    g = rotate32(g, 19);\n    g = g * 5 + 0xe6546b64;\n    f += a4;\n    f = rotate32(f, 19);\n    f = f * 5 + 0xe6546b64;\n    int iters = (len - 1) / 20;\n    int pos = 0;\n    do {\n        a0 = rotate32(fetch32(data, pos) * c1, 17) * c2;\n        a1 = fetch32(data, pos + 4);\n        a2 = rotate32(fetch32(data, pos + 8) * c1, 17) * c2;\n        a3 = rotate32(fetch32(data, pos + 12) * c1, 17) * c2;\n        a4 = fetch32(data, pos + 16);\n        h ^= a0;\n        h = rotate32(h, 18);\n        h = h * 5 + 0xe6546b64;\n        f += a1;\n        f = rotate32(f, 19);\n        f = f * c1;\n        g += a2;\n        g = rotate32(g, 18);\n        g = g * 5 + 0xe6546b64;\n        h ^= a3 + a1;\n        h = rotate32(h, 19);\n        h = h * 5 + 0xe6546b64;\n        g ^= a4;\n        g = Integer.reverseBytes(g) * 5;\n        h += a4 * 5;\n        h = Integer.reverseBytes(h);\n        f += a0;\n        int swapValue = f;\n        f = g;\n        g = h;\n        h = swapValue;\n        pos += 20;\n    } while (--iters != 0);\n    g = rotate32(g, 11) * c1;\n    g = rotate32(g, 17) * c1;\n    f = rotate32(f, 11) * c1;\n    f = rotate32(f, 17) * c1;\n    h = rotate32(h + g, 19);\n    h = h * 5 + 0xe6546b64;\n    h = rotate32(h, 17) * c1;\n    h = rotate32(h + f, 19);\n    h = h * 5 + 0xe6546b64;\n    h = rotate32(h, 17) * c1;\n    return h;\n}",
        "all_field_declaration": "// Some primes between 2^63 and 2^64 for various uses.\nprivate static final long k0 = 0xc3a5c85c97cb3127L;\nprivate static final long k1 = 0xb492b66fbe98f273L;\nprivate static final long k2 = 0x9ae16a3b2f90404fL;\nprivate static final long kMul = 0x9ddfea08eb382d69L;\n// Magic numbers for 32-bit hashing.  Copied from Murmur3.\nprivate static final int c1 = 0xcc9e2d51;\nprivate static final int c2 = 0x1b873593;",
        "sub_project_name": "hutool-core",
        "lineNumbers": "37",
        "Filed": "private static final int c1 = 0xcc9e2d51;private static final int c2 = 0x1b873593;",
        "Parameter_type": "byte[]",
        "Import_statements": "",
        "public_method_signature": "public static int hash32(byte[] data);\npublic static long hash64(byte[] data);\npublic static long hash64(byte[] data, long seed0, long seed1);\npublic static long hash64(byte[] data, long seed);\npublic static Number128 hash128(byte[] data);\npublic static Number128 hash128(byte[] data, Number128 seed);",
        "public_field": "",
        "Method_statement": "hash32(byte() data)",
        "Method_name": "hash32",
        "Class_declaration": "public class CityHash {\n",
        "constructors": "",
        "all_method_signature": "public static int hash32(byte[] data);\npublic static long hash64(byte[] data);\npublic static long hash64(byte[] data, long seed0, long seed1);\npublic static long hash64(byte[] data, long seed);\npublic static Number128 hash128(byte[] data);\npublic static Number128 hash128(byte[] data, Number128 seed);\nprivate static Number128 hash128(final byte[] byteArray, int start, final Number128 seed);\nprivate static int hash32Len0to4(final byte[] byteArray);\nprivate static int hash32Len5to12(final byte[] byteArray);\nprivate static int hash32Len13to24(byte[] byteArray);\nprivate static long hashLen0to16(byte[] byteArray);\nprivate static long hashLen17to32(byte[] byteArray);\nprivate static long hashLen33to64(byte[] byteArray);\nprivate static long fetch64(byte[] byteArray, int start);\nprivate static int fetch32(byte[] byteArray, final int start);\nprivate static long rotate64(long val, int shift);\nprivate static int rotate32(int val, int shift);\nprivate static long hashLen16(long u, long v, long mul);\nprivate static long hashLen16(long u, long v);\nprivate static long hash128to64(final Number128 number128);\nprivate static long shiftMix(long val);\nprivate static int fmix(int h);\nprivate static int mur(int a, int h);\nprivate static Number128 weakHashLen32WithSeeds(long w, long x, long y, long z, long a, long b);\nprivate static Number128 weakHashLen32WithSeeds(byte[] byteArray, int start, long a, long b);\nprivate static Number128 cityMurmur(final byte[] byteArray, Number128 seed);",
        "Class_name": "CityHash",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/lang/hash/CityHash###hash32",
        "Parameter_num": "1",
        "all_Import_statements": "import cn.hutool.core.util.ByteUtil;\n\nimport java.util.Arrays;\n",
        "comment": "\n\t * 计算32位City Hash值\n\t *\n\t * @param data 数据\n\t * @return hash值\n\t ",
        "packageName": "cn.hutool.core.lang.hash",
        "method_signature": "public static int hash32(byte[] data);",
        "Junit_version": "5",
        "returnType": "int"
    },
    {
        "Method_body": "public Map<String, String> extractUriTemplateVariables(String pattern, String path) {\n    Map<String, String> variables = new LinkedHashMap<>();\n    boolean result = doMatch(pattern, path, true, variables);\n    if (!result) {\n        throw new IllegalStateException(\"Pattern \\\"\" + pattern + \"\\\" is not a match for \\\"\" + path + \"\\\"\");\n    }\n    return variables;\n}",
        "all_field_declaration": "/**\n * Default path separator: \"/\".\n */\npublic static final String DEFAULT_PATH_SEPARATOR = StrUtil.SLASH;\nprivate static final int CACHE_TURNOFF_THRESHOLD = 65536;\nprivate static final Pattern VARIABLE_PATTERN = Pattern.compile(\"\\\\{[^/]+?}\");\nprivate static final char[] WILDCARD_CHARS = { '*', '?', '{' };\nprivate String pathSeparator;\nprivate PathSeparatorPatternCache pathSeparatorPatternCache;\nprivate boolean caseSensitive = true;\nprivate boolean trimTokens = false;\nprivate volatile Boolean cachePatterns;\nprivate final Map<String, String[]> tokenizedPatternCache = new SafeConcurrentHashMap<>(256);\nprivate final Map<String, AntPathStringMatcher> stringMatcherCache = new SafeConcurrentHashMap<>(256);",
        "sub_project_name": "hutool-core",
        "lineNumbers": "4",
        "Filed": "",
        "Parameter_type": "String,String",
        "Import_statements": "import java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.regex.Pattern;\n",
        "public_method_signature": "public AntPathMatcher();\npublic AntPathMatcher(String pathSeparator);\npublic AntPathMatcher setPathSeparator(String pathSeparator);\npublic AntPathMatcher setCaseSensitive(boolean caseSensitive);\npublic AntPathMatcher setTrimTokens(boolean trimTokens);\npublic AntPathMatcher setCachePatterns(boolean cachePatterns);\npublic boolean isPattern(String path);\npublic boolean match(String pattern, String path);\npublic boolean matchStart(String pattern, String path);\npublic String extractPathWithinPattern(String pattern, String path);\npublic Map<String, String> extractUriTemplateVariables(String pattern, String path);\npublic String combine(String pattern1, String pattern2);\npublic Comparator<String> getPatternComparator(String path);",
        "public_field": "/**\n * Default path separator: \"/\".\n */\npublic static final String DEFAULT_PATH_SEPARATOR = StrUtil.SLASH;",
        "Method_statement": "extractUriTemplateVariables(String pattern, String path)",
        "Method_name": "extractUriTemplateVariables",
        "Class_declaration": "public class AntPathMatcher {\n",
        "constructors": "public AntPathMatcher() {\n    this(DEFAULT_PATH_SEPARATOR);\n}public AntPathMatcher(String pathSeparator) {\n    if (null == pathSeparator) {\n        pathSeparator = DEFAULT_PATH_SEPARATOR;\n    }\n    setPathSeparator(pathSeparator);\n}",
        "all_method_signature": "public AntPathMatcher();\npublic AntPathMatcher(String pathSeparator);\npublic AntPathMatcher setPathSeparator(String pathSeparator);\npublic AntPathMatcher setCaseSensitive(boolean caseSensitive);\npublic AntPathMatcher setTrimTokens(boolean trimTokens);\npublic AntPathMatcher setCachePatterns(boolean cachePatterns);\npublic boolean isPattern(String path);\npublic boolean match(String pattern, String path);\npublic boolean matchStart(String pattern, String path);\nprotected boolean doMatch(String pattern, String path, boolean fullMatch, Map<String, String> uriTemplateVariables);\nprivate boolean isPotentialMatch(String path, String[] pattDirs);\nprivate int skipSegment(String path, int pos, String prefix);\nprivate int skipSeparator(String path, int pos, String separator);\nprivate boolean isWildcardChar(char c);\nprotected String[] tokenizePattern(String pattern);\nprivate void deactivatePatternCache();\nprotected String[] tokenizePath(String path);\nprivate boolean notMatchStrings(String pattern, String str, Map<String, String> uriTemplateVariables);\nprotected AntPathStringMatcher getStringMatcher(String pattern);\npublic String extractPathWithinPattern(String pattern, String path);\npublic Map<String, String> extractUriTemplateVariables(String pattern, String path);\npublic String combine(String pattern1, String pattern2);\nprivate String concat(String path1, String path2);\npublic Comparator<String> getPatternComparator(String path);",
        "Class_name": "AntPathMatcher",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/text/AntPathMatcher###extractUriTemplateVariables",
        "Parameter_num": "2",
        "all_Import_statements": "import cn.hutool.core.map.SafeConcurrentHashMap;\n\nimport cn.hutool.core.util.StrUtil;\n\nimport java.util.ArrayList;\n\nimport java.util.Comparator;\n\nimport java.util.LinkedHashMap;\n\nimport java.util.List;\n\nimport java.util.Map;\n\nimport java.util.regex.Matcher;\n\nimport java.util.regex.Pattern;\n",
        "comment": "",
        "packageName": "cn.hutool.core.text",
        "method_signature": "public Map<String, String> extractUriTemplateVariables(String pattern, String path);",
        "Junit_version": "5",
        "returnType": "Map<String,String>"
    },
    {
        "Method_body": "public static <T> Collection<T> union(Collection<T> coll1, Collection<T> coll2) {\n    if (isEmpty(coll1) && isEmpty(coll2)) {\n        return new ArrayList<>();\n    }\n    if (isEmpty(coll1)) {\n        return new ArrayList<>(coll2);\n    } else if (isEmpty(coll2)) {\n        return new ArrayList<>(coll1);\n    }\n    final ArrayList<T> list = new ArrayList<>(Math.max(coll1.size(), coll2.size()));\n    final Map<T, Integer> map1 = countMap(coll1);\n    final Map<T, Integer> map2 = countMap(coll2);\n    final Set<T> elts = newHashSet(coll2);\n    elts.addAll(coll1);\n    int m;\n    for (T t : elts) {\n        m = Math.max(Convert.toInt(map1.get(t), 0), Convert.toInt(map2.get(t), 0));\n        for (int i = 0; i < m; i++) {\n            list.add(t);\n        }\n    }\n    return list;\n}",
        "all_field_declaration": "",
        "sub_project_name": "hutool-core",
        "lineNumbers": "10",
        "Filed": "",
        "Parameter_type": "Collection<T>,Collection<T>",
        "Import_statements": "import cn.hutool.core.convert.Convert;\n",
        "public_method_signature": "public static Set<T> emptyIfNull(Set<T> set);\npublic static List<T> emptyIfNull(List<T> list);\npublic static Collection<T> union(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> union(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Set<T> unionDistinct(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static List<T> unionAll(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Collection<T> intersection(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> intersection(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Set<T> intersectionDistinct(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Collection<T> disjunction(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> subtract(Collection<T> coll1, Collection<T> coll2);\npublic static List<T> subtractToList(Collection<T> coll1, Collection<T> coll2);\npublic static boolean contains(Collection<?> collection, Object value);\npublic static boolean safeContains(Collection<?> collection, Object value);\npublic static boolean contains(Collection<T> collection, Predicate<? super T> containFunc);\npublic static boolean containsAny(Collection<?> coll1, Collection<?> coll2);\npublic static boolean containsAll(Collection<?> coll1, Collection<?> coll2);\npublic static Map<T, Integer> countMap(Iterable<T> collection);\npublic static String join(Iterable<T> iterable, CharSequence conjunction, Function<T, ? extends CharSequence> func);\npublic static String join(Iterable<T> iterable, CharSequence conjunction);\npublic static String join(Iterable<T> iterable, CharSequence conjunction, String prefix, String suffix);\npublic static String join(Iterator<T> iterator, CharSequence conjunction);\npublic static List<T> popPart(Stack<T> surplusAlaDatas, int partSize);\npublic static List<T> popPart(Deque<T> surplusAlaDatas, int partSize);\npublic static HashSet<T> newHashSet(T... ts);\npublic static LinkedHashSet<T> newLinkedHashSet(T... ts);\npublic static HashSet<T> set(boolean isSorted, T... ts);\npublic static HashSet<T> newHashSet(Collection<T> collection);\npublic static HashSet<T> newHashSet(boolean isSorted, Collection<T> collection);\npublic static HashSet<T> newHashSet(boolean isSorted, Iterator<T> iter);\npublic static HashSet<T> newHashSet(boolean isSorted, Enumeration<T> enumeration);\npublic static List<T> list(boolean isLinked);\npublic static List<T> list(boolean isLinked, T... values);\npublic static List<T> list(boolean isLinked, Collection<T> collection);\npublic static List<T> list(boolean isLinked, Iterable<T> iterable);\npublic static List<T> list(boolean isLinked, Iterator<T> iter);\npublic static List<T> list(boolean isLinked, Enumeration<T> enumeration);\npublic static ArrayList<T> newArrayList(T... values);\npublic static ArrayList<T> toList(T... values);\npublic static ArrayList<T> newArrayList(Collection<T> collection);\npublic static ArrayList<T> newArrayList(Iterable<T> iterable);\npublic static ArrayList<T> newArrayList(Iterator<T> iterator);\npublic static ArrayList<T> newArrayList(Enumeration<T> enumeration);\npublic static LinkedList<T> newLinkedList(T... values);\npublic static CopyOnWriteArrayList<T> newCopyOnWriteArrayList(Collection<T> collection);\npublic static BlockingQueue<T> newBlockingQueue(int capacity, boolean isLinked);\npublic static Collection<T> create(Class<?> collectionType);\npublic static Collection<T> create(Class<?> collectionType, Class<T> elementType);\npublic static ArrayList<T> distinct(Collection<T> collection);\npublic static List<T> distinct(Collection<T> collection, Function<T, K> uniqueGenerator, boolean override);\npublic static List<T> sub(List<T> list, int start, int end);\npublic static List<T> sub(List<T> list, int start, int end, int step);\npublic static List<T> sub(Collection<T> collection, int start, int end);\npublic static List<T> sub(Collection<T> collection, int start, int end, int step);\npublic static List<List<T>> splitList(List<T> list, int size);\npublic static List<List<T>> split(Collection<T> collection, int size);\npublic static Collection<T> edit(Collection<T> collection, Editor<T> editor);\npublic static Collection<T> filterNew(Collection<T> collection, Filter<T> filter);\npublic static T removeAny(T collection, E... elesRemoved);\npublic static T filter(T collection, final Filter<E> filter);\npublic static T removeNull(T collection);\npublic static T removeEmpty(T collection);\npublic static T removeBlank(T collection);\npublic static T removeWithAddIf(T targetCollection, T resultCollection, Predicate<? super E> predicate);\npublic static List<E> removeWithAddIf(T targetCollection, Predicate<? super E> predicate);\npublic static List<Object> extract(Iterable<?> collection, Editor<Object> editor);\npublic static List<Object> extract(Iterable<?> collection, Editor<Object> editor, boolean ignoreNull);\npublic static List<R> map(Iterable<T> collection, Function<? super T, ? extends R> func, boolean ignoreNull);\npublic static List<Object> getFieldValues(Iterable<?> collection, final String fieldName);\npublic static List<Object> getFieldValues(Iterable<?> collection, final String fieldName, boolean ignoreNull);\npublic static List<T> getFieldValues(Iterable<?> collection, final String fieldName, final Class<T> elementType);\npublic static Map<K, V> fieldValueMap(Iterable<V> iterable, String fieldName);\npublic static Map<K, V> fieldValueAsMap(Iterable<?> iterable, String fieldNameForKey, String fieldNameForValue);\npublic static T findOne(Iterable<T> collection, Filter<T> filter);\npublic static T findOneByField(Iterable<T> collection, final String fieldName, final Object fieldValue);\npublic static int count(Iterable<T> iterable, Matcher<T> matcher);\npublic static int indexOf(Collection<T> collection, Matcher<T> matcher);\npublic static int lastIndexOf(Collection<T> collection, Matcher<T> matcher);\npublic static int[] indexOfAll(Collection<T> collection, Matcher<T> matcher);\npublic static boolean isEmpty(Collection<?> collection);\npublic static T defaultIfEmpty(T collection, T defaultCollection);\npublic static T defaultIfEmpty(T collection, Supplier<? extends T> supplier);\npublic static boolean isEmpty(Iterable<?> iterable);\npublic static boolean isEmpty(Iterator<?> Iterator);\npublic static boolean isEmpty(Enumeration<?> enumeration);\npublic static boolean isEmpty(Map<?, ?> map);\npublic static boolean isNotEmpty(Collection<?> collection);\npublic static boolean isNotEmpty(Iterable<?> iterable);\npublic static boolean isNotEmpty(Iterator<?> Iterator);\npublic static boolean isNotEmpty(Enumeration<?> enumeration);\npublic static boolean hasNull(Iterable<?> iterable);\npublic static boolean isNotEmpty(Map<?, ?> map);\npublic static Map<String, String> zip(String keys, String values, String delimiter, boolean isOrder);\npublic static Map<String, String> zip(String keys, String values, String delimiter);\npublic static Map<K, V> zip(Collection<K> keys, Collection<V> values);\npublic static HashMap<K, V> toMap(Iterable<Entry<K, V>> entryIter);\npublic static HashMap<Object, Object> toMap(Object[] array);\npublic static TreeSet<T> toTreeSet(Collection<T> collection, Comparator<T> comparator);\npublic static Enumeration<E> asEnumeration(Iterator<E> iter);\npublic static Iterator<E> asIterator(Enumeration<E> e);\npublic static Iterable<E> asIterable(final Iterator<E> iter);\npublic static Collection<E> toCollection(Iterable<E> iterable);\npublic static Map<K, List<V>> toListMap(Iterable<? extends Map<K, V>> mapList);\npublic static List<Map<K, V>> toMapList(Map<K, ? extends Iterable<V>> listMap);\npublic static Map<K, V> toMap(Iterable<V> values, Map<K, V> map, Func1<V, K> keyFunc);\npublic static Map<K, V> toMap(Iterable<E> values, Map<K, V> map, Func1<E, K> keyFunc, Func1<E, V> valueFunc);\npublic static boolean addIfAbsent(Collection<T> collection, S object);\npublic static Collection<T> addAll(Collection<T> collection, Object value);\npublic static Collection<T> addAll(Collection<T> collection, Object value, Type elementType);\npublic static Collection<T> addAll(Collection<T> collection, Iterator<T> iterator);\npublic static Collection<T> addAll(Collection<T> collection, Iterable<T> iterable);\npublic static Collection<T> addAll(Collection<T> collection, Enumeration<T> enumeration);\npublic static Collection<T> addAll(Collection<T> collection, T[] values);\npublic static List<T> addAllIfNotContains(List<T> list, List<T> otherList);\npublic static T get(Collection<T> collection, int index);\npublic static List<T> getAny(Collection<T> collection, int... indexes);\npublic static T getFirst(Iterable<T> iterable);\npublic static T getFirst(Iterator<T> iterator);\npublic static T getLast(Collection<T> collection);\npublic static Class<?> getElementType(Iterable<?> iterable);\npublic static Class<?> getElementType(Iterator<?> iterator);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, K... keys);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, Iterable<K> keys);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, Iterator<K> keys);\npublic static List<T> sortPageAll(int pageNo, int pageSize, Comparator<T> comparator, Collection<T>... colls);\npublic static List<T> page(int pageNo, int pageSize, List<T> list);\npublic static List<T> sort(Collection<T> collection, Comparator<? super T> comparator);\npublic static List<T> sort(List<T> list, Comparator<? super T> c);\npublic static List<T> sortByProperty(Collection<T> collection, String property);\npublic static List<T> sortByProperty(List<T> list, String property);\npublic static List<String> sortByPinyin(Collection<String> collection);\npublic static List<String> sortByPinyin(List<String> list);\npublic static TreeMap<K, V> sort(Map<K, V> map, Comparator<? super K> comparator);\npublic static LinkedHashMap<K, V> sortToMap(Collection<Map.Entry<K, V>> entryCollection, Comparator<Map.Entry<K, V>> comparator);\npublic static LinkedHashMap<K, V> sortByEntry(Map<K, V> map, Comparator<Map.Entry<K, V>> comparator);\npublic static List<Entry<K, V>> sortEntryToList(Collection<Entry<K, V>> collection);\npublic static void forEach(Iterable<T> iterable, Consumer<T> consumer);\npublic static void forEach(Iterator<T> iterator, Consumer<T> consumer);\npublic static void forEach(Enumeration<T> enumeration, Consumer<T> consumer);\npublic static void forEach(Map<K, V> map, KVConsumer<K, V> kvConsumer);\npublic static List<List<T>> group(Collection<T> collection, Hash32<T> hash);\npublic static List<List<T>> groupByField(Collection<T> collection, final String fieldName);\npublic static List<T> reverse(List<T> list);\npublic static List<T> reverseNew(List<T> list);\npublic static List<T> setOrAppend(List<T> list, int index, T element);\npublic static Set<K> keySet(Collection<Map<K, ?>> mapCollection);\npublic static List<V> values(Collection<Map<?, V>> mapCollection);\npublic static T max(Collection<T> coll);\npublic static T min(Collection<T> coll);\npublic static Collection<T> unmodifiable(Collection<? extends T> c);\npublic static T empty(Class<?> collectionClass);\npublic static void clear(Collection<?>... collections);\npublic static void padLeft(List<T> list, int minLen, T padObj);\npublic static void padRight(Collection<T> list, int minLen, T padObj);\npublic static Collection<T> trans(Collection<F> collection, Function<? super F, ? extends T> function);\npublic static void setValueByMap(Iterable<E> iterable, Map<K, V> map, Function<E, K> keyGenerate, BiConsumer<E, V> biConsumer);\npublic static int size(final Object object);\npublic static boolean isEqualList(final Collection<?> list1, final Collection<?> list2);",
        "public_field": "",
        "Method_statement": "union(Collection<T> coll1, Collection<T> coll2)",
        "Method_name": "union",
        "Class_declaration": "public class CollUtil {\n",
        "constructors": "",
        "all_method_signature": "public static Set<T> emptyIfNull(Set<T> set);\npublic static List<T> emptyIfNull(List<T> list);\npublic static Collection<T> union(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> union(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Set<T> unionDistinct(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static List<T> unionAll(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Collection<T> intersection(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> intersection(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Set<T> intersectionDistinct(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Collection<T> disjunction(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> subtract(Collection<T> coll1, Collection<T> coll2);\npublic static List<T> subtractToList(Collection<T> coll1, Collection<T> coll2);\npublic static boolean contains(Collection<?> collection, Object value);\npublic static boolean safeContains(Collection<?> collection, Object value);\npublic static boolean contains(Collection<T> collection, Predicate<? super T> containFunc);\npublic static boolean containsAny(Collection<?> coll1, Collection<?> coll2);\npublic static boolean containsAll(Collection<?> coll1, Collection<?> coll2);\npublic static Map<T, Integer> countMap(Iterable<T> collection);\npublic static String join(Iterable<T> iterable, CharSequence conjunction, Function<T, ? extends CharSequence> func);\npublic static String join(Iterable<T> iterable, CharSequence conjunction);\npublic static String join(Iterable<T> iterable, CharSequence conjunction, String prefix, String suffix);\npublic static String join(Iterator<T> iterator, CharSequence conjunction);\npublic static List<T> popPart(Stack<T> surplusAlaDatas, int partSize);\npublic static List<T> popPart(Deque<T> surplusAlaDatas, int partSize);\npublic static HashSet<T> newHashSet(T... ts);\npublic static LinkedHashSet<T> newLinkedHashSet(T... ts);\npublic static HashSet<T> set(boolean isSorted, T... ts);\npublic static HashSet<T> newHashSet(Collection<T> collection);\npublic static HashSet<T> newHashSet(boolean isSorted, Collection<T> collection);\npublic static HashSet<T> newHashSet(boolean isSorted, Iterator<T> iter);\npublic static HashSet<T> newHashSet(boolean isSorted, Enumeration<T> enumeration);\npublic static List<T> list(boolean isLinked);\npublic static List<T> list(boolean isLinked, T... values);\npublic static List<T> list(boolean isLinked, Collection<T> collection);\npublic static List<T> list(boolean isLinked, Iterable<T> iterable);\npublic static List<T> list(boolean isLinked, Iterator<T> iter);\npublic static List<T> list(boolean isLinked, Enumeration<T> enumeration);\npublic static ArrayList<T> newArrayList(T... values);\npublic static ArrayList<T> toList(T... values);\npublic static ArrayList<T> newArrayList(Collection<T> collection);\npublic static ArrayList<T> newArrayList(Iterable<T> iterable);\npublic static ArrayList<T> newArrayList(Iterator<T> iterator);\npublic static ArrayList<T> newArrayList(Enumeration<T> enumeration);\npublic static LinkedList<T> newLinkedList(T... values);\npublic static CopyOnWriteArrayList<T> newCopyOnWriteArrayList(Collection<T> collection);\npublic static BlockingQueue<T> newBlockingQueue(int capacity, boolean isLinked);\npublic static Collection<T> create(Class<?> collectionType);\npublic static Collection<T> create(Class<?> collectionType, Class<T> elementType);\npublic static ArrayList<T> distinct(Collection<T> collection);\npublic static List<T> distinct(Collection<T> collection, Function<T, K> uniqueGenerator, boolean override);\npublic static List<T> sub(List<T> list, int start, int end);\npublic static List<T> sub(List<T> list, int start, int end, int step);\npublic static List<T> sub(Collection<T> collection, int start, int end);\npublic static List<T> sub(Collection<T> collection, int start, int end, int step);\npublic static List<List<T>> splitList(List<T> list, int size);\npublic static List<List<T>> split(Collection<T> collection, int size);\npublic static Collection<T> edit(Collection<T> collection, Editor<T> editor);\npublic static Collection<T> filterNew(Collection<T> collection, Filter<T> filter);\npublic static T removeAny(T collection, E... elesRemoved);\npublic static T filter(T collection, final Filter<E> filter);\npublic static T removeNull(T collection);\npublic static T removeEmpty(T collection);\npublic static T removeBlank(T collection);\npublic static T removeWithAddIf(T targetCollection, T resultCollection, Predicate<? super E> predicate);\npublic static List<E> removeWithAddIf(T targetCollection, Predicate<? super E> predicate);\npublic static List<Object> extract(Iterable<?> collection, Editor<Object> editor);\npublic static List<Object> extract(Iterable<?> collection, Editor<Object> editor, boolean ignoreNull);\npublic static List<R> map(Iterable<T> collection, Function<? super T, ? extends R> func, boolean ignoreNull);\npublic static List<Object> getFieldValues(Iterable<?> collection, final String fieldName);\npublic static List<Object> getFieldValues(Iterable<?> collection, final String fieldName, boolean ignoreNull);\npublic static List<T> getFieldValues(Iterable<?> collection, final String fieldName, final Class<T> elementType);\npublic static Map<K, V> fieldValueMap(Iterable<V> iterable, String fieldName);\npublic static Map<K, V> fieldValueAsMap(Iterable<?> iterable, String fieldNameForKey, String fieldNameForValue);\npublic static T findOne(Iterable<T> collection, Filter<T> filter);\npublic static T findOneByField(Iterable<T> collection, final String fieldName, final Object fieldValue);\npublic static int count(Iterable<T> iterable, Matcher<T> matcher);\npublic static int indexOf(Collection<T> collection, Matcher<T> matcher);\npublic static int lastIndexOf(Collection<T> collection, Matcher<T> matcher);\npublic static int[] indexOfAll(Collection<T> collection, Matcher<T> matcher);\npublic static boolean isEmpty(Collection<?> collection);\npublic static T defaultIfEmpty(T collection, T defaultCollection);\npublic static T defaultIfEmpty(T collection, Supplier<? extends T> supplier);\npublic static boolean isEmpty(Iterable<?> iterable);\npublic static boolean isEmpty(Iterator<?> Iterator);\npublic static boolean isEmpty(Enumeration<?> enumeration);\npublic static boolean isEmpty(Map<?, ?> map);\npublic static boolean isNotEmpty(Collection<?> collection);\npublic static boolean isNotEmpty(Iterable<?> iterable);\npublic static boolean isNotEmpty(Iterator<?> Iterator);\npublic static boolean isNotEmpty(Enumeration<?> enumeration);\npublic static boolean hasNull(Iterable<?> iterable);\npublic static boolean isNotEmpty(Map<?, ?> map);\npublic static Map<String, String> zip(String keys, String values, String delimiter, boolean isOrder);\npublic static Map<String, String> zip(String keys, String values, String delimiter);\npublic static Map<K, V> zip(Collection<K> keys, Collection<V> values);\npublic static HashMap<K, V> toMap(Iterable<Entry<K, V>> entryIter);\npublic static HashMap<Object, Object> toMap(Object[] array);\npublic static TreeSet<T> toTreeSet(Collection<T> collection, Comparator<T> comparator);\npublic static Enumeration<E> asEnumeration(Iterator<E> iter);\npublic static Iterator<E> asIterator(Enumeration<E> e);\npublic static Iterable<E> asIterable(final Iterator<E> iter);\npublic static Collection<E> toCollection(Iterable<E> iterable);\npublic static Map<K, List<V>> toListMap(Iterable<? extends Map<K, V>> mapList);\npublic static List<Map<K, V>> toMapList(Map<K, ? extends Iterable<V>> listMap);\npublic static Map<K, V> toMap(Iterable<V> values, Map<K, V> map, Func1<V, K> keyFunc);\npublic static Map<K, V> toMap(Iterable<E> values, Map<K, V> map, Func1<E, K> keyFunc, Func1<E, V> valueFunc);\npublic static boolean addIfAbsent(Collection<T> collection, S object);\npublic static Collection<T> addAll(Collection<T> collection, Object value);\npublic static Collection<T> addAll(Collection<T> collection, Object value, Type elementType);\npublic static Collection<T> addAll(Collection<T> collection, Iterator<T> iterator);\npublic static Collection<T> addAll(Collection<T> collection, Iterable<T> iterable);\npublic static Collection<T> addAll(Collection<T> collection, Enumeration<T> enumeration);\npublic static Collection<T> addAll(Collection<T> collection, T[] values);\npublic static List<T> addAllIfNotContains(List<T> list, List<T> otherList);\npublic static T get(Collection<T> collection, int index);\npublic static List<T> getAny(Collection<T> collection, int... indexes);\npublic static T getFirst(Iterable<T> iterable);\npublic static T getFirst(Iterator<T> iterator);\npublic static T getLast(Collection<T> collection);\npublic static Class<?> getElementType(Iterable<?> iterable);\npublic static Class<?> getElementType(Iterator<?> iterator);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, K... keys);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, Iterable<K> keys);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, Iterator<K> keys);\npublic static List<T> sortPageAll(int pageNo, int pageSize, Comparator<T> comparator, Collection<T>... colls);\npublic static List<T> page(int pageNo, int pageSize, List<T> list);\npublic static List<T> sort(Collection<T> collection, Comparator<? super T> comparator);\npublic static List<T> sort(List<T> list, Comparator<? super T> c);\npublic static List<T> sortByProperty(Collection<T> collection, String property);\npublic static List<T> sortByProperty(List<T> list, String property);\npublic static List<String> sortByPinyin(Collection<String> collection);\npublic static List<String> sortByPinyin(List<String> list);\npublic static TreeMap<K, V> sort(Map<K, V> map, Comparator<? super K> comparator);\npublic static LinkedHashMap<K, V> sortToMap(Collection<Map.Entry<K, V>> entryCollection, Comparator<Map.Entry<K, V>> comparator);\npublic static LinkedHashMap<K, V> sortByEntry(Map<K, V> map, Comparator<Map.Entry<K, V>> comparator);\npublic static List<Entry<K, V>> sortEntryToList(Collection<Entry<K, V>> collection);\npublic static void forEach(Iterable<T> iterable, Consumer<T> consumer);\npublic static void forEach(Iterator<T> iterator, Consumer<T> consumer);\npublic static void forEach(Enumeration<T> enumeration, Consumer<T> consumer);\npublic static void forEach(Map<K, V> map, KVConsumer<K, V> kvConsumer);\npublic static List<List<T>> group(Collection<T> collection, Hash32<T> hash);\npublic static List<List<T>> groupByField(Collection<T> collection, final String fieldName);\npublic static List<T> reverse(List<T> list);\npublic static List<T> reverseNew(List<T> list);\npublic static List<T> setOrAppend(List<T> list, int index, T element);\npublic static Set<K> keySet(Collection<Map<K, ?>> mapCollection);\npublic static List<V> values(Collection<Map<?, V>> mapCollection);\npublic static T max(Collection<T> coll);\npublic static T min(Collection<T> coll);\npublic static Collection<T> unmodifiable(Collection<? extends T> c);\npublic static T empty(Class<?> collectionClass);\npublic static void clear(Collection<?>... collections);\npublic static void padLeft(List<T> list, int minLen, T padObj);\npublic static void padRight(Collection<T> list, int minLen, T padObj);\npublic static Collection<T> trans(Collection<F> collection, Function<? super F, ? extends T> function);\npublic static void setValueByMap(Iterable<E> iterable, Map<K, V> map, Function<E, K> keyGenerate, BiConsumer<E, V> biConsumer);\npublic static int size(final Object object);\npublic static boolean isEqualList(final Collection<?> list1, final Collection<?> list2);",
        "Class_name": "CollUtil",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/collection/CollUtil###union",
        "Parameter_num": "2",
        "all_Import_statements": "import cn.hutool.core.bean.BeanUtil;\n\nimport cn.hutool.core.comparator.CompareUtil;\n\nimport cn.hutool.core.comparator.PinyinComparator;\n\nimport cn.hutool.core.comparator.PropertyComparator;\n\nimport cn.hutool.core.convert.Convert;\n\nimport cn.hutool.core.convert.ConverterRegistry;\n\nimport cn.hutool.core.exceptions.UtilException;\n\nimport cn.hutool.core.lang.Assert;\n\nimport cn.hutool.core.lang.Editor;\n\nimport cn.hutool.core.lang.Filter;\n\nimport cn.hutool.core.lang.Matcher;\n\nimport cn.hutool.core.lang.func.Func1;\n\nimport cn.hutool.core.lang.hash.Hash32;\n\nimport cn.hutool.core.map.MapUtil;\n\nimport cn.hutool.core.util.*;\n\nimport java.io.Serializable;\n\nimport java.lang.reflect.Type;\n\nimport java.util.*;\n\nimport java.util.Map.Entry;\n\nimport java.util.concurrent.ArrayBlockingQueue;\n\nimport java.util.concurrent.BlockingQueue;\n\nimport java.util.concurrent.CopyOnWriteArrayList;\n\nimport java.util.concurrent.LinkedBlockingDeque;\n\nimport java.util.function.BiConsumer;\n\nimport java.util.function.Function;\n\nimport java.util.function.Predicate;\n\nimport java.util.function.Supplier;\n",
        "comment": "\n\t * 两个集合的并集<br>\n\t * 针对一个集合中存在多个相同元素的情况，计算两个集合中此元素的个数，保留最多的个数<br>\n\t * 例如：集合1：[a, b, c, c, c]，集合2：[a, b, c, c]<br>\n\t * 结果：[a, b, c, c, c]，此结果中只保留了三个c\n\t *\n\t * @param <T>   集合元素类型\n\t * @param coll1 集合1\n\t * @param coll2 集合2\n\t * @return 并集的集合，返回 {@link ArrayList}\n\t ",
        "packageName": "cn.hutool.core.collection",
        "method_signature": "public static Collection<T> union(Collection<T> coll1, Collection<T> coll2);",
        "Junit_version": "5",
        "returnType": "Collection<T>"
    },
    {
        "Method_body": "public static Coordinate gcj02ToBd09(double lng, double lat) {\n    double z = Math.sqrt(lng * lng + lat * lat) + 0.00002 * Math.sin(lat * X_PI);\n    double theta = Math.atan2(lat, lng) + 0.000003 * Math.cos(lng * X_PI);\n    double bd_lng = z * Math.cos(theta) + 0.0065;\n    double bd_lat = z * Math.sin(theta) + 0.006;\n    return new Coordinate(bd_lng, bd_lat);\n}",
        "all_field_declaration": "/**\n * 坐标转换参数：(火星坐标系与百度坐标系转换的中间量)\n */\npublic static final double X_PI = 3.1415926535897932384626433832795 * 3000.0 / 180.0;\n/**\n * 坐标转换参数：π\n */\npublic static final double PI = 3.1415926535897932384626433832795D;\n/**\n * 地球半径（Krasovsky 1940）\n */\npublic static final double RADIUS = 6378245.0D;\n/**\n * 修正参数（偏率ee）\n */\npublic static final double CORRECTION_PARAM = 0.00669342162296594323D;",
        "sub_project_name": "hutool-core",
        "lineNumbers": "5",
        "Filed": "public static final double X_PI = 3.1415926535897932384626433832795 * 3000.0 / 180.0;public static final double PI = 3.1415926535897932384626433832795D;",
        "Parameter_type": "double,double",
        "Import_statements": "",
        "public_method_signature": "public static boolean outOfChina(double lng, double lat);\npublic static Coordinate wgs84ToGcj02(double lng, double lat);\npublic static Coordinate wgs84ToBd09(double lng, double lat);\npublic static Coordinate gcj02ToWgs84(double lng, double lat);\npublic static Coordinate gcj02ToBd09(double lng, double lat);\npublic static Coordinate bd09ToGcj02(double lng, double lat);\npublic static Coordinate bd09toWgs84(double lng, double lat);\npublic static Coordinate wgs84ToMercator(double lng, double lat);\npublic static Coordinate mercatorToWgs84(double mercatorX, double mercatorY);",
        "public_field": "/**\n * 坐标转换参数：(火星坐标系与百度坐标系转换的中间量)\n */\npublic static final double X_PI = 3.1415926535897932384626433832795 * 3000.0 / 180.0;\n/**\n * 坐标转换参数：π\n */\npublic static final double PI = 3.1415926535897932384626433832795D;\n/**\n * 地球半径（Krasovsky 1940）\n */\npublic static final double RADIUS = 6378245.0D;\n/**\n * 修正参数（偏率ee）\n */\npublic static final double CORRECTION_PARAM = 0.00669342162296594323D;",
        "Method_statement": "gcj02ToBd09(double lng, double lat)",
        "Method_name": "gcj02ToBd09",
        "Class_declaration": "public class CoordinateUtil {\n",
        "constructors": "",
        "all_method_signature": "public static boolean outOfChina(double lng, double lat);\npublic static Coordinate wgs84ToGcj02(double lng, double lat);\npublic static Coordinate wgs84ToBd09(double lng, double lat);\npublic static Coordinate gcj02ToWgs84(double lng, double lat);\npublic static Coordinate gcj02ToBd09(double lng, double lat);\npublic static Coordinate bd09ToGcj02(double lng, double lat);\npublic static Coordinate bd09toWgs84(double lng, double lat);\npublic static Coordinate wgs84ToMercator(double lng, double lat);\npublic static Coordinate mercatorToWgs84(double mercatorX, double mercatorY);\nprivate static Coordinate offset(double lng, double lat, boolean isPlus);\nprivate static double transLng(double lng, double lat);\nprivate static double transLat(double lng, double lat);",
        "Class_name": "CoordinateUtil",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/util/CoordinateUtil###gcj02ToBd09",
        "Parameter_num": "2",
        "all_Import_statements": "import java.io.Serializable;\n\nimport java.util.Objects;\n",
        "comment": "\n\t * 火星坐标系 (GCJ-02) 与百度坐标系 (BD-09) 的转换\n\t *\n\t * @param lng 经度值\n\t * @param lat 纬度值\n\t * @return BD-09 坐标\n\t ",
        "packageName": "cn.hutool.core.util",
        "method_signature": "public static Coordinate gcj02ToBd09(double lng, double lat);",
        "Junit_version": "5",
        "returnType": "Coordinate"
    },
    {
        "Method_body": "public static Object[] wrap(Object obj) {\n    if (null == obj) {\n        return null;\n    }\n    if (isArray(obj)) {\n        try {\n            return (Object[]) obj;\n        } catch (Exception e) {\n            final String className = obj.getClass().getComponentType().getName();\n            switch(className) {\n                case \"long\":\n                    return wrap((long[]) obj);\n                case \"int\":\n                    return wrap((int[]) obj);\n                case \"short\":\n                    return wrap((short[]) obj);\n                case \"char\":\n                    return wrap((char[]) obj);\n                case \"byte\":\n                    return wrap((byte[]) obj);\n                case \"boolean\":\n                    return wrap((boolean[]) obj);\n                case \"float\":\n                    return wrap((float[]) obj);\n                case \"double\":\n                    return wrap((double[]) obj);\n                default:\n                    throw new UtilException(e);\n            }\n        }\n    }\n    throw new UtilException(StrUtil.format(\"[{}] is not Array!\", obj.getClass()));\n}",
        "all_field_declaration": "",
        "sub_project_name": "hutool-core",
        "lineNumbers": "3",
        "Filed": "",
        "Parameter_type": "Object",
        "Import_statements": "import cn.hutool.core.exceptions.UtilException;\nimport java.lang.reflect.Array;\n",
        "public_method_signature": "public static boolean isEmpty(T[] array);\npublic static T[] defaultIfEmpty(T[] array, T[] defaultArray);\npublic static boolean isEmpty(Object array);\npublic static boolean isNotEmpty(T[] array);\npublic static boolean isNotEmpty(Object array);\npublic static boolean hasNull(T... array);\npublic static boolean isAllNull(T... array);\npublic static T firstNonNull(T... array);\npublic static T firstMatch(Matcher<T> matcher, T... array);\npublic static int matchIndex(Matcher<T> matcher, T... array);\npublic static int matchIndex(Matcher<T> matcher, int beginIndexInclude, T... array);\npublic static T[] newArray(Class<?> componentType, int newSize);\npublic static Object[] newArray(int newSize);\npublic static Class<?> getComponentType(Object array);\npublic static Class<?> getComponentType(Class<?> arrayClass);\npublic static Class<?> getArrayType(Class<?> componentType);\npublic static Object[] cast(Class<?> type, Object arrayObj) throws NullPointerException, IllegalArgumentException;\npublic static T[] append(T[] buffer, T... newElements);\npublic static Object append(Object array, T... newElements);\npublic static T[] setOrAppend(T[] buffer, int index, T value);\npublic static Object setOrAppend(Object array, int index, Object value);\npublic static T[] replace(T[] buffer, int index, T... values);\npublic static T[] insert(T[] buffer, int index, T... newElements);\npublic static Object insert(Object array, int index, T... newElements);\npublic static T[] resize(T[] data, int newSize, Class<?> componentType);\npublic static Object resize(Object array, int newSize);\npublic static T[] resize(T[] buffer, int newSize);\npublic static T[] addAll(T[]... arrays);\npublic static Object copy(Object src, int srcPos, Object dest, int destPos, int length);\npublic static Object copy(Object src, Object dest, int length);\npublic static T[] clone(T[] array);\npublic static T clone(final T obj);\npublic static T[] edit(T[] array, Editor<T> editor);\npublic static T[] filter(T[] array, Filter<T> filter);\npublic static T[] removeNull(T[] array);\npublic static T[] removeEmpty(T[] array);\npublic static T[] removeBlank(T[] array);\npublic static String[] nullToEmpty(String[] array);\npublic static Map<K, V> zip(K[] keys, V[] values, boolean isOrder);\npublic static Map<K, V> zip(K[] keys, V[] values);\npublic static int indexOf(T[] array, Object value, int beginIndexInclude);\npublic static int indexOf(T[] array, Object value);\npublic static int indexOfIgnoreCase(CharSequence[] array, CharSequence value);\npublic static int lastIndexOf(T[] array, Object value);\npublic static int lastIndexOf(T[] array, Object value, int endInclude);\npublic static boolean contains(T[] array, T value);\npublic static boolean containsAny(T[] array, T... values);\npublic static boolean containsAll(T[] array, T... values);\npublic static boolean containsIgnoreCase(CharSequence[] array, CharSequence value);\npublic static Object[] wrap(Object obj);\npublic static boolean isArray(Object obj);\npublic static T get(Object array, int index);\npublic static T[] getAny(Object array, int... indexes);\npublic static T[] sub(T[] array, int start, int end);\npublic static Object[] sub(Object array, int start, int end);\npublic static Object[] sub(Object array, int start, int end, int step);\npublic static String toString(Object obj);\npublic static int length(Object array) throws IllegalArgumentException;\npublic static String join(T[] array, CharSequence conjunction);\npublic static String join(T[] array, CharSequence delimiter, String prefix, String suffix);\npublic static String join(T[] array, CharSequence conjunction, Editor<T> editor);\npublic static String join(Object array, CharSequence conjunction);\npublic static byte[] toArray(ByteBuffer bytebuffer);\npublic static T[] toArray(Iterator<T> iterator, Class<T> componentType);\npublic static T[] toArray(Iterable<T> iterable, Class<T> componentType);\npublic static T[] toArray(Collection<T> collection, Class<T> componentType);\npublic static T[] remove(T[] array, int index) throws IllegalArgumentException;\npublic static T[] removeEle(T[] array, T element) throws IllegalArgumentException;\npublic static T[] reverse(T[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static T[] reverse(T[] array);\npublic static T min(T[] numberArray);\npublic static T min(T[] numberArray, Comparator<T> comparator);\npublic static T max(T[] numberArray);\npublic static T max(T[] numberArray, Comparator<T> comparator);\npublic static T[] shuffle(T[] array);\npublic static T[] shuffle(T[] array, Random random);\npublic static T[] swap(T[] array, int index1, int index2);\npublic static Object swap(Object array, int index1, int index2);\npublic static int emptyCount(Object... args);\npublic static boolean hasEmpty(Object... args);\npublic static boolean isAllEmpty(Object... args);\npublic static boolean isAllNotEmpty(Object... args);\npublic static boolean isAllNotNull(T... array);\npublic static T[] distinct(T[] array);\npublic static T[] distinct(T[] array, Function<T, K> uniqueGenerator, boolean override);\npublic static R[] map(T[] array, Class<R> targetComponentType, Function<? super T, ? extends R> func);\npublic static R[] map(Object array, Class<R> targetComponentType, Function<? super T, ? extends R> func);\npublic static List<R> map(T[] array, Function<? super T, ? extends R> func);\npublic static Set<R> mapToSet(T[] array, Function<? super T, ? extends R> func);\npublic static boolean equals(Object array1, Object array2);\npublic static boolean isSub(T[] array, T[] subArray);\npublic static int indexOfSub(T[] array, T[] subArray);\npublic static int indexOfSub(T[] array, int beginInclude, T[] subArray);\npublic static int lastIndexOfSub(T[] array, T[] subArray);\npublic static int lastIndexOfSub(T[] array, int endInclude, T[] subArray);\npublic static boolean isSorted(T[] array, Comparator<? super T> comparator);\npublic static boolean isSorted(T[] array);\npublic static boolean isSortedASC(T[] array);\npublic static boolean isSortedDESC(T[] array);",
        "public_field": "",
        "Method_statement": "wrap(Object obj)",
        "Method_name": "wrap",
        "Class_declaration": "public class ArrayUtil {\n",
        "constructors": "",
        "all_method_signature": "public static boolean isEmpty(T[] array);\npublic static T[] defaultIfEmpty(T[] array, T[] defaultArray);\npublic static boolean isEmpty(Object array);\npublic static boolean isNotEmpty(T[] array);\npublic static boolean isNotEmpty(Object array);\npublic static boolean hasNull(T... array);\npublic static boolean isAllNull(T... array);\npublic static T firstNonNull(T... array);\npublic static T firstMatch(Matcher<T> matcher, T... array);\npublic static int matchIndex(Matcher<T> matcher, T... array);\npublic static int matchIndex(Matcher<T> matcher, int beginIndexInclude, T... array);\npublic static T[] newArray(Class<?> componentType, int newSize);\npublic static Object[] newArray(int newSize);\npublic static Class<?> getComponentType(Object array);\npublic static Class<?> getComponentType(Class<?> arrayClass);\npublic static Class<?> getArrayType(Class<?> componentType);\npublic static Object[] cast(Class<?> type, Object arrayObj) throws NullPointerException, IllegalArgumentException;\npublic static T[] append(T[] buffer, T... newElements);\npublic static Object append(Object array, T... newElements);\npublic static T[] setOrAppend(T[] buffer, int index, T value);\npublic static Object setOrAppend(Object array, int index, Object value);\npublic static T[] replace(T[] buffer, int index, T... values);\npublic static T[] insert(T[] buffer, int index, T... newElements);\npublic static Object insert(Object array, int index, T... newElements);\npublic static T[] resize(T[] data, int newSize, Class<?> componentType);\npublic static Object resize(Object array, int newSize);\npublic static T[] resize(T[] buffer, int newSize);\npublic static T[] addAll(T[]... arrays);\npublic static Object copy(Object src, int srcPos, Object dest, int destPos, int length);\npublic static Object copy(Object src, Object dest, int length);\npublic static T[] clone(T[] array);\npublic static T clone(final T obj);\npublic static T[] edit(T[] array, Editor<T> editor);\npublic static T[] filter(T[] array, Filter<T> filter);\npublic static T[] removeNull(T[] array);\npublic static T[] removeEmpty(T[] array);\npublic static T[] removeBlank(T[] array);\npublic static String[] nullToEmpty(String[] array);\npublic static Map<K, V> zip(K[] keys, V[] values, boolean isOrder);\npublic static Map<K, V> zip(K[] keys, V[] values);\npublic static int indexOf(T[] array, Object value, int beginIndexInclude);\npublic static int indexOf(T[] array, Object value);\npublic static int indexOfIgnoreCase(CharSequence[] array, CharSequence value);\npublic static int lastIndexOf(T[] array, Object value);\npublic static int lastIndexOf(T[] array, Object value, int endInclude);\npublic static boolean contains(T[] array, T value);\npublic static boolean containsAny(T[] array, T... values);\npublic static boolean containsAll(T[] array, T... values);\npublic static boolean containsIgnoreCase(CharSequence[] array, CharSequence value);\npublic static Object[] wrap(Object obj);\npublic static boolean isArray(Object obj);\npublic static T get(Object array, int index);\npublic static T[] getAny(Object array, int... indexes);\npublic static T[] sub(T[] array, int start, int end);\npublic static Object[] sub(Object array, int start, int end);\npublic static Object[] sub(Object array, int start, int end, int step);\npublic static String toString(Object obj);\npublic static int length(Object array) throws IllegalArgumentException;\npublic static String join(T[] array, CharSequence conjunction);\npublic static String join(T[] array, CharSequence delimiter, String prefix, String suffix);\npublic static String join(T[] array, CharSequence conjunction, Editor<T> editor);\npublic static String join(Object array, CharSequence conjunction);\npublic static byte[] toArray(ByteBuffer bytebuffer);\npublic static T[] toArray(Iterator<T> iterator, Class<T> componentType);\npublic static T[] toArray(Iterable<T> iterable, Class<T> componentType);\npublic static T[] toArray(Collection<T> collection, Class<T> componentType);\npublic static T[] remove(T[] array, int index) throws IllegalArgumentException;\npublic static T[] removeEle(T[] array, T element) throws IllegalArgumentException;\npublic static T[] reverse(T[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static T[] reverse(T[] array);\npublic static T min(T[] numberArray);\npublic static T min(T[] numberArray, Comparator<T> comparator);\npublic static T max(T[] numberArray);\npublic static T max(T[] numberArray, Comparator<T> comparator);\npublic static T[] shuffle(T[] array);\npublic static T[] shuffle(T[] array, Random random);\npublic static T[] swap(T[] array, int index1, int index2);\npublic static Object swap(Object array, int index1, int index2);\npublic static int emptyCount(Object... args);\npublic static boolean hasEmpty(Object... args);\npublic static boolean isAllEmpty(Object... args);\npublic static boolean isAllNotEmpty(Object... args);\npublic static boolean isAllNotNull(T... array);\npublic static T[] distinct(T[] array);\npublic static T[] distinct(T[] array, Function<T, K> uniqueGenerator, boolean override);\npublic static R[] map(T[] array, Class<R> targetComponentType, Function<? super T, ? extends R> func);\npublic static R[] map(Object array, Class<R> targetComponentType, Function<? super T, ? extends R> func);\npublic static List<R> map(T[] array, Function<? super T, ? extends R> func);\npublic static Set<R> mapToSet(T[] array, Function<? super T, ? extends R> func);\npublic static boolean equals(Object array1, Object array2);\npublic static boolean isSub(T[] array, T[] subArray);\npublic static int indexOfSub(T[] array, T[] subArray);\npublic static int indexOfSub(T[] array, int beginInclude, T[] subArray);\npublic static int lastIndexOfSub(T[] array, T[] subArray);\npublic static int lastIndexOfSub(T[] array, int endInclude, T[] subArray);\npublic static boolean isSorted(T[] array, Comparator<? super T> comparator);\npublic static boolean isSorted(T[] array);\npublic static boolean isSortedASC(T[] array);\npublic static boolean isSortedDESC(T[] array);",
        "Class_name": "ArrayUtil",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/util/ArrayUtil###wrap",
        "Parameter_num": "1",
        "all_Import_statements": "import cn.hutool.core.collection.CollUtil;\n\nimport cn.hutool.core.collection.CollectionUtil;\n\nimport cn.hutool.core.collection.UniqueKeySet;\n\nimport cn.hutool.core.comparator.CompareUtil;\n\nimport cn.hutool.core.convert.Convert;\n\nimport cn.hutool.core.exceptions.UtilException;\n\nimport cn.hutool.core.lang.Assert;\n\nimport cn.hutool.core.lang.Editor;\n\nimport cn.hutool.core.lang.Filter;\n\nimport cn.hutool.core.lang.Matcher;\n\nimport cn.hutool.core.map.MapUtil;\n\nimport cn.hutool.core.text.StrJoiner;\n\nimport java.lang.reflect.Array;\n\nimport java.nio.ByteBuffer;\n\nimport java.util.ArrayList;\n\nimport java.util.Arrays;\n\nimport java.util.Collection;\n\nimport java.util.Collections;\n\nimport java.util.Comparator;\n\nimport java.util.Iterator;\n\nimport java.util.LinkedHashSet;\n\nimport java.util.List;\n\nimport java.util.Map;\n\nimport java.util.Random;\n\nimport java.util.Set;\n\nimport java.util.function.Function;\n\nimport java.util.stream.Collectors;\n",
        "comment": "\n\t * 包装数组对象\n\t *\n\t * @param obj 对象，可以是对象数组或者基本类型数组\n\t * @return 包装类型数组或对象数组\n\t * @throws UtilException 对象为非数组\n\t ",
        "packageName": "cn.hutool.core.util",
        "method_signature": "public static Object[] wrap(Object obj);",
        "Junit_version": "5",
        "returnType": "Object[]"
    },
    {
        "Method_body": "public static Charset detect(int bufferSize, InputStream in, Charset... charsets) {\n    if (ArrayUtil.isEmpty(charsets)) {\n        charsets = DEFAULT_CHARSETS;\n    }\n    final byte[] buffer = new byte[bufferSize];\n    try {\n        while (in.read(buffer) > -1) {\n            for (Charset charset : charsets) {\n                final CharsetDecoder decoder = charset.newDecoder();\n                if (identify(buffer, decoder)) {\n                    return charset;\n                }\n            }\n        }\n    } catch (IOException e) {\n        throw new IORuntimeException(e);\n    } finally {\n        IoUtil.close(in);\n    }\n    return null;\n}",
        "all_field_declaration": "/**\n * 默认的参与测试的编码\n */\nprivate static final Charset[] DEFAULT_CHARSETS;",
        "sub_project_name": "hutool-core",
        "lineNumbers": "4",
        "Filed": "private static final Charset[] DEFAULT_CHARSETS;",
        "Parameter_type": "int,InputStream,Charset",
        "Import_statements": "import cn.hutool.core.util.ArrayUtil;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDecoder;\n",
        "public_method_signature": "public static Charset detect(File file, Charset... charsets);\npublic static Charset detect(InputStream in, Charset... charsets);\npublic static Charset detect(int bufferSize, InputStream in, Charset... charsets);",
        "public_field": "",
        "Method_statement": "detect(int bufferSize, InputStream in, Charset... charsets)",
        "Method_name": "detect",
        "Class_declaration": "public class CharsetDetector {\n",
        "constructors": "",
        "all_method_signature": "public static Charset detect(File file, Charset... charsets);\npublic static Charset detect(InputStream in, Charset... charsets);\npublic static Charset detect(int bufferSize, InputStream in, Charset... charsets);\nprivate static boolean identify(byte[] bytes, CharsetDecoder decoder);",
        "Class_name": "CharsetDetector",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/io/CharsetDetector###detect",
        "Parameter_num": "3",
        "all_Import_statements": "import cn.hutool.core.convert.Convert;\n\nimport cn.hutool.core.util.ArrayUtil;\n\nimport java.io.File;\n\nimport java.io.IOException;\n\nimport java.io.InputStream;\n\nimport java.nio.ByteBuffer;\n\nimport java.nio.charset.CharacterCodingException;\n\nimport java.nio.charset.Charset;\n\nimport java.nio.charset.CharsetDecoder;\n",
        "comment": "\n\t * 探测编码<br>\n\t * 注意：此方法会读取流的一部分，然后关闭流，如重复使用流，请使用支持reset方法的流\n\t *\n\t * @param bufferSize 自定义缓存大小，即每次检查的长度\n\t * @param in         流，使用后关闭此流\n\t * @param charsets   需要测试用的编码，null或空使用默认的编码数组\n\t * @return 编码\n\t * @since 5.7.10\n\t ",
        "packageName": "cn.hutool.core.io",
        "method_signature": "public static Charset detect(int bufferSize, InputStream in, Charset... charsets);",
        "Junit_version": "5",
        "returnType": "Charset"
    },
    {
        "Method_body": "public static char toCloseChar(char c) {\n    int result = c;\n    if (c >= '1' && c <= '9') {\n        result = '①' + c - '1';\n    } else if (c >= 'A' && c <= 'Z') {\n        result = 'Ⓐ' + c - 'A';\n    } else if (c >= 'a' && c <= 'z') {\n        result = 'ⓐ' + c - 'a';\n    }\n    return (char) result;\n}",
        "all_field_declaration": "",
        "sub_project_name": "hutool-core",
        "lineNumbers": "3",
        "Filed": "",
        "Parameter_type": "char",
        "Import_statements": "",
        "public_method_signature": "public static boolean isAscii(char ch);\npublic static boolean isAsciiPrintable(char ch);\npublic static boolean isAsciiControl(final char ch);\npublic static boolean isLetter(char ch);\npublic static boolean isLetterUpper(final char ch);\npublic static boolean isLetterLower(final char ch);\npublic static boolean isNumber(char ch);\npublic static boolean isHexChar(char c);\npublic static boolean isLetterOrNumber(final char ch);\npublic static String toString(char c);\npublic static boolean isCharClass(Class<?> clazz);\npublic static boolean isChar(Object value);\npublic static boolean isBlankChar(char c);\npublic static boolean isBlankChar(int c);\npublic static boolean isEmoji(char c);\npublic static boolean isFileSeparator(char c);\npublic static boolean equals(char c1, char c2, boolean caseInsensitive);\npublic static int getType(int c);\npublic static int digit16(int b);\npublic static char toCloseChar(char c);\npublic static char toCloseByNumber(int number);",
        "public_field": "",
        "Method_statement": "toCloseChar(char c)",
        "Method_name": "toCloseChar",
        "Class_declaration": "public class CharUtil {\n",
        "constructors": "",
        "all_method_signature": "public static boolean isAscii(char ch);\npublic static boolean isAsciiPrintable(char ch);\npublic static boolean isAsciiControl(final char ch);\npublic static boolean isLetter(char ch);\npublic static boolean isLetterUpper(final char ch);\npublic static boolean isLetterLower(final char ch);\npublic static boolean isNumber(char ch);\npublic static boolean isHexChar(char c);\npublic static boolean isLetterOrNumber(final char ch);\npublic static String toString(char c);\npublic static boolean isCharClass(Class<?> clazz);\npublic static boolean isChar(Object value);\npublic static boolean isBlankChar(char c);\npublic static boolean isBlankChar(int c);\npublic static boolean isEmoji(char c);\npublic static boolean isFileSeparator(char c);\npublic static boolean equals(char c1, char c2, boolean caseInsensitive);\npublic static int getType(int c);\npublic static int digit16(int b);\npublic static char toCloseChar(char c);\npublic static char toCloseByNumber(int number);",
        "Class_name": "CharUtil",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/util/CharUtil###toCloseChar",
        "Parameter_num": "1",
        "all_Import_statements": "import cn.hutool.core.text.ASCIIStrCache;\n\nimport cn.hutool.core.text.CharPool;\n",
        "comment": "\n\t * 将字母、数字转换为带圈的字符：\n\t * <pre>\n\t *     '1' -》 '①'\n\t *     'A' -》 'Ⓐ'\n\t *     'a' -》 'ⓐ'\n\t * </pre>\n\t * <p>\n\t * 获取带圈数字 /封闭式字母数字 ，从1-20,超过1-20报错\n\t *\n\t * @param c 被转换的字符，如果字符不支持转换，返回原字符\n\t * @return 转换后的字符\n\t * @see <a href=\"https://en.wikipedia.org/wiki/List_of_Unicode_characters#Unicode_symbols\">Unicode_symbols</a>\n\t * @see <a href=\"https://en.wikipedia.org/wiki/Enclosed_Alphanumerics\">Alphanumerics</a>\n\t * @since 5.6.2\n\t ",
        "packageName": "cn.hutool.core.util",
        "method_signature": "public static char toCloseChar(char c);",
        "Junit_version": "5",
        "returnType": "char"
    },
    {
        "Method_body": "public static String removeSuffixIgnoreCase(CharSequence str, CharSequence suffix) {\n    if (isEmpty(str) || isEmpty(suffix)) {\n        return str(str);\n    }\n    final String str2 = str.toString();\n    if (endWithIgnoreCase(str, suffix)) {\n        return subPre(str2, str2.length() - suffix.length());\n    }\n    return str2;\n}",
        "all_field_declaration": "public static final int INDEX_NOT_FOUND = Finder.INDEX_NOT_FOUND;\n/**\n * 字符串常量：{@code \"null\"} <br>\n * 注意：{@code \"null\" != null}\n */\npublic static final String NULL = \"null\";\n/**\n * 字符串常量：空字符串 {@code \"\"}\n */\npublic static final String EMPTY = \"\";\n/**\n * 字符串常量：空格符 {@code \" \"}\n */\npublic static final String SPACE = \" \";",
        "sub_project_name": "hutool-core",
        "lineNumbers": "4",
        "Filed": "",
        "Parameter_type": "CharSequence,CharSequence",
        "Import_statements": "",
        "public_method_signature": "public static boolean isBlank(CharSequence str);\npublic static boolean isNotBlank(CharSequence str);\npublic static boolean hasBlank(CharSequence... strs);\npublic static boolean isAllBlank(CharSequence... strs);\npublic static boolean isEmpty(CharSequence str);\npublic static boolean isNotEmpty(CharSequence str);\npublic static String emptyIfNull(CharSequence str);\npublic static String nullToEmpty(CharSequence str);\npublic static String nullToDefault(CharSequence str, String defaultStr);\npublic static String emptyToDefault(CharSequence str, String defaultStr);\npublic static String blankToDefault(CharSequence str, String defaultStr);\npublic static String emptyToNull(CharSequence str);\npublic static boolean hasEmpty(CharSequence... strs);\npublic static boolean isAllEmpty(CharSequence... strs);\npublic static boolean isAllNotEmpty(CharSequence... args);\npublic static boolean isAllNotBlank(CharSequence... args);\npublic static boolean isNullOrUndefined(CharSequence str);\npublic static boolean isEmptyOrUndefined(CharSequence str);\npublic static boolean isBlankOrUndefined(CharSequence str);\npublic static String trim(CharSequence str);\npublic static String trimToEmpty(CharSequence str);\npublic static String trimToNull(CharSequence str);\npublic static String trimStart(CharSequence str);\npublic static String trimEnd(CharSequence str);\npublic static String trim(CharSequence str, int mode);\npublic static String trim(CharSequence str, int mode, Predicate<Character> predicate);\npublic static boolean startWith(CharSequence str, char c);\npublic static boolean startWith(CharSequence str, CharSequence prefix, boolean ignoreCase);\npublic static boolean startWith(CharSequence str, CharSequence prefix, boolean ignoreCase, boolean ignoreEquals);\npublic static boolean startWith(CharSequence str, CharSequence prefix);\npublic static boolean startWithIgnoreEquals(CharSequence str, CharSequence prefix);\npublic static boolean startWithIgnoreCase(CharSequence str, CharSequence prefix);\npublic static boolean startWithAny(CharSequence str, CharSequence... prefixes);\npublic static boolean startWithAnyIgnoreCase(final CharSequence str, final CharSequence... suffixes);\npublic static boolean endWith(CharSequence str, char c);\npublic static boolean endWith(CharSequence str, CharSequence suffix, boolean ignoreCase);\npublic static boolean endWith(CharSequence str, CharSequence suffix, boolean ignoreCase, boolean ignoreEquals);\npublic static boolean endWith(CharSequence str, CharSequence suffix);\npublic static boolean endWithIgnoreCase(CharSequence str, CharSequence suffix);\npublic static boolean endWithAny(CharSequence str, CharSequence... suffixes);\npublic static boolean endWithAnyIgnoreCase(CharSequence str, CharSequence... suffixes);\npublic static boolean contains(CharSequence str, char searchChar);\npublic static boolean contains(CharSequence str, CharSequence searchStr);\npublic static boolean containsAny(CharSequence str, CharSequence... testStrs);\npublic static boolean containsAny(CharSequence str, char... testChars);\npublic static boolean containsOnly(CharSequence str, char... testChars);\npublic static boolean containsAll(CharSequence str, CharSequence... testChars);\npublic static boolean containsBlank(CharSequence str);\npublic static String getContainsStr(CharSequence str, CharSequence... testStrs);\npublic static boolean containsIgnoreCase(CharSequence str, CharSequence testStr);\npublic static boolean containsAnyIgnoreCase(CharSequence str, CharSequence... testStrs);\npublic static String getContainsStrIgnoreCase(CharSequence str, CharSequence... testStrs);\npublic static int indexOf(CharSequence str, char searchChar);\npublic static int indexOf(CharSequence str, char searchChar, int start);\npublic static int indexOf(CharSequence text, char searchChar, int start, int end);\npublic static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr);\npublic static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int fromIndex);\npublic static int indexOf(CharSequence text, CharSequence searchStr, int from, boolean ignoreCase);\npublic static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr);\npublic static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr, int fromIndex);\npublic static int lastIndexOf(CharSequence text, CharSequence searchStr, int from, boolean ignoreCase);\npublic static int ordinalIndexOf(CharSequence str, CharSequence searchStr, int ordinal);\npublic static String removeAll(CharSequence str, CharSequence strToRemove);\npublic static String removeAny(CharSequence str, CharSequence... strsToRemove);\npublic static String removeAll(CharSequence str, char... chars);\npublic static String removeAllLineBreaks(CharSequence str);\npublic static String removePreAndLowerFirst(CharSequence str, int preLength);\npublic static String removePreAndLowerFirst(CharSequence str, CharSequence prefix);\npublic static String removePrefix(CharSequence str, CharSequence prefix);\npublic static String removePrefixIgnoreCase(CharSequence str, CharSequence prefix);\npublic static String removeSuffix(CharSequence str, CharSequence suffix);\npublic static String removeSufAndLowerFirst(CharSequence str, CharSequence suffix);\npublic static String removeSuffixIgnoreCase(CharSequence str, CharSequence suffix);\npublic static String cleanBlank(CharSequence str);\npublic static String strip(CharSequence str, CharSequence prefixOrSuffix);\npublic static String strip(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String stripIgnoreCase(CharSequence str, CharSequence prefixOrSuffix);\npublic static String stripIgnoreCase(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String addPrefixIfNot(CharSequence str, CharSequence prefix);\npublic static String addSuffixIfNot(CharSequence str, CharSequence suffix);\npublic static long[] splitToLong(CharSequence str, char separator);\npublic static long[] splitToLong(CharSequence str, CharSequence separator);\npublic static int[] splitToInt(CharSequence str, char separator);\npublic static int[] splitToInt(CharSequence str, CharSequence separator);\npublic static List<String> split(CharSequence str, char separator);\npublic static String[] splitToArray(CharSequence str, CharSequence separator);\npublic static String[] splitToArray(CharSequence str, char separator);\npublic static String[] splitToArray(CharSequence text, char separator, int limit);\npublic static List<String> split(CharSequence str, char separator, int limit);\npublic static List<String> splitTrim(CharSequence str, char separator);\npublic static List<String> splitTrim(CharSequence str, CharSequence separator);\npublic static List<String> splitTrim(CharSequence str, char separator, int limit);\npublic static List<String> splitTrim(CharSequence str, CharSequence separator, int limit);\npublic static List<String> split(CharSequence str, char separator, boolean isTrim, boolean ignoreEmpty);\npublic static List<String> split(CharSequence str, char separator, int limit, boolean isTrim, boolean ignoreEmpty);\npublic static List<R> split(CharSequence str, char separator, int limit, boolean ignoreEmpty, Function<String, R> mapping);\npublic static List<String> split(CharSequence str, CharSequence separator);\npublic static List<String> split(CharSequence str, CharSequence separator, boolean isTrim, boolean ignoreEmpty);\npublic static List<String> split(CharSequence str, CharSequence separator, int limit, boolean isTrim, boolean ignoreEmpty);\npublic static String[] split(CharSequence str, int len);\npublic static String[] cut(CharSequence str, int partLength);\npublic static String sub(CharSequence str, int fromIndexInclude, int toIndexExclude);\npublic static String subByCodePoint(CharSequence str, int fromIndex, int toIndex);\npublic static String subPreGbk(CharSequence str, int len, CharSequence suffix);\npublic static String subPreGbk(CharSequence str, int len, boolean halfUp);\npublic static String subPre(CharSequence string, int toIndexExclude);\npublic static String subSuf(CharSequence string, int fromIndex);\npublic static String subSufByLength(CharSequence string, int length);\npublic static String subWithLength(String input, int fromIndex, int length);\npublic static String subBefore(CharSequence string, CharSequence separator, boolean isLastSeparator);\npublic static String subBefore(CharSequence string, char separator, boolean isLastSeparator);\npublic static String subAfter(CharSequence string, CharSequence separator, boolean isLastSeparator);\npublic static String subAfter(CharSequence string, char separator, boolean isLastSeparator);\npublic static String subBetween(CharSequence str, CharSequence before, CharSequence after);\npublic static String subBetween(CharSequence str, CharSequence beforeAndAfter);\npublic static String[] subBetweenAll(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String[] subBetweenAll(CharSequence str, CharSequence prefixAndSuffix);\npublic static String repeat(char c, int count);\npublic static String repeat(CharSequence str, int count);\npublic static String repeatByLength(CharSequence str, int padLen);\npublic static String repeatAndJoin(CharSequence str, int count, CharSequence delimiter);\npublic static boolean equals(CharSequence str1, CharSequence str2);\npublic static boolean equalsIgnoreCase(CharSequence str1, CharSequence str2);\npublic static boolean equals(CharSequence str1, CharSequence str2, boolean ignoreCase);\npublic static boolean equalsAnyIgnoreCase(CharSequence str1, CharSequence... strs);\npublic static boolean equalsAny(CharSequence str1, CharSequence... strs);\npublic static boolean equalsAny(CharSequence str1, boolean ignoreCase, CharSequence... strs);\npublic static boolean equalsCharAt(CharSequence str, int position, char c);\npublic static boolean isSubEquals(CharSequence str1, int start1, CharSequence str2, boolean ignoreCase);\npublic static boolean isSubEquals(CharSequence str1, int start1, CharSequence str2, int start2, int length, boolean ignoreCase);\npublic static String format(CharSequence template, Object... params);\npublic static String indexedFormat(CharSequence pattern, Object... arguments);\npublic static byte[] utf8Bytes(CharSequence str);\npublic static byte[] bytes(CharSequence str);\npublic static byte[] bytes(CharSequence str, String charset);\npublic static byte[] bytes(CharSequence str, Charset charset);\npublic static ByteBuffer byteBuffer(CharSequence str, String charset);\npublic static String wrap(CharSequence str, CharSequence prefixAndSuffix);\npublic static String wrap(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String[] wrapAllWithPair(CharSequence prefixAndSuffix, CharSequence... strs);\npublic static String[] wrapAll(CharSequence prefix, CharSequence suffix, CharSequence... strs);\npublic static String wrapIfMissing(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String[] wrapAllWithPairIfMissing(CharSequence prefixAndSuffix, CharSequence... strs);\npublic static String[] wrapAllIfMissing(CharSequence prefix, CharSequence suffix, CharSequence... strs);\npublic static String unWrap(CharSequence str, String prefix, String suffix);\npublic static String unWrap(CharSequence str, char prefix, char suffix);\npublic static String unWrap(CharSequence str, char prefixAndSuffix);\npublic static boolean isWrap(CharSequence str, String prefix, String suffix);\npublic static boolean isWrap(CharSequence str, String wrapper);\npublic static boolean isWrap(CharSequence str, char wrapper);\npublic static boolean isWrap(CharSequence str, char prefixChar, char suffixChar);\npublic static String padPre(CharSequence str, int length, CharSequence padStr);\npublic static String padPre(CharSequence str, int length, char padChar);\npublic static String padAfter(CharSequence str, int length, char padChar);\npublic static String padAfter(CharSequence str, int length, CharSequence padStr);\npublic static String center(CharSequence str, final int size);\npublic static String center(CharSequence str, final int size, char padChar);\npublic static String center(CharSequence str, final int size, CharSequence padStr);\npublic static String str(CharSequence cs);\npublic static int count(CharSequence content, CharSequence strForSearch);\npublic static int count(CharSequence content, char charForSearch);\npublic static int compare(final CharSequence str1, final CharSequence str2, final boolean nullIsLess);\npublic static int compareIgnoreCase(CharSequence str1, CharSequence str2, boolean nullIsLess);\npublic static int compareVersion(CharSequence version1, CharSequence version2);\npublic static String appendIfMissing(CharSequence str, CharSequence suffix, CharSequence... suffixes);\npublic static String appendIfMissingIgnoreCase(CharSequence str, CharSequence suffix, CharSequence... suffixes);\npublic static String appendIfMissing(CharSequence str, CharSequence suffix, boolean ignoreCase, CharSequence... testSuffixes);\npublic static String prependIfMissing(CharSequence str, CharSequence prefix, CharSequence... prefixes);\npublic static String prependIfMissingIgnoreCase(CharSequence str, CharSequence prefix, CharSequence... prefixes);\npublic static String prependIfMissing(CharSequence str, CharSequence prefix, boolean ignoreCase, CharSequence... prefixes);\npublic static String replaceIgnoreCase(CharSequence str, CharSequence searchStr, CharSequence replacement);\npublic static String replace(CharSequence str, CharSequence searchStr, CharSequence replacement);\npublic static String replace(CharSequence str, CharSequence searchStr, CharSequence replacement, boolean ignoreCase);\npublic static String replace(CharSequence str, int fromIndex, CharSequence searchStr, CharSequence replacement, boolean ignoreCase);\npublic static String replace(CharSequence str, int startInclude, int endExclude, char replacedChar);\npublic static String replace(CharSequence str, int startInclude, int endExclude, CharSequence replacedStr);\npublic static String replace(CharSequence str, java.util.regex.Pattern pattern, Func1<java.util.regex.Matcher, String> replaceFun);\npublic static String replace(CharSequence str, String regex, Func1<java.util.regex.Matcher, String> replaceFun);\npublic static String replaceLast(CharSequence str, CharSequence searchStr, CharSequence replacedStr);\npublic static String replaceLast(CharSequence str, CharSequence searchStr, CharSequence replacedStr, boolean ignoreCase);\npublic static String replaceFirst(CharSequence str, CharSequence searchStr, CharSequence replacedStr);\npublic static String replaceFirst(CharSequence str, CharSequence searchStr, CharSequence replacedStr, boolean ignoreCase);\npublic static String hide(CharSequence str, int startInclude, int endExclude);\npublic static String desensitized(CharSequence str, DesensitizedUtil.DesensitizedType desensitizedType);\npublic static String replaceChars(CharSequence str, String chars, CharSequence replacedStr);\npublic static String replaceChars(CharSequence str, char[] chars, CharSequence replacedStr);\npublic static int length(CharSequence cs);\npublic static int byteLength(CharSequence cs, Charset charset);\npublic static int totalLength(CharSequence... strs);\npublic static String maxLength(CharSequence string, int length);\npublic static T firstNonNull(T... strs);\npublic static T firstNonEmpty(T... strs);\npublic static T firstNonBlank(T... strs);\npublic static String upperFirstAndAddPre(CharSequence str, String preString);\npublic static String upperFirst(CharSequence str);\npublic static String lowerFirst(CharSequence str);\npublic static String filter(CharSequence str, final Filter<Character> filter);\npublic static boolean isUpperCase(CharSequence str);\npublic static boolean isLowerCase(CharSequence str);\npublic static String swapCase(final String str);\npublic static String toUnderlineCase(CharSequence str);\npublic static String toSymbolCase(CharSequence str, char symbol);\npublic static String toCamelCase(CharSequence name);\npublic static String toCamelCase(CharSequence name, char symbol);\npublic static boolean isSurround(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static boolean isSurround(CharSequence str, char prefix, char suffix);\npublic static StringBuilder builder(CharSequence... strs);\npublic static StrBuilder strBuilder(CharSequence... strs);\npublic static String getGeneralField(CharSequence getOrSetMethodName);\npublic static String genSetter(CharSequence fieldName);\npublic static String genGetter(CharSequence fieldName);\npublic static String concat(boolean isNullToEmpty, CharSequence... strs);\npublic static String brief(CharSequence str, int maxLength);\npublic static String join(CharSequence conjunction, Object... objs);\npublic static String join(CharSequence conjunction, Iterable<T> iterable);\npublic static boolean isAllCharMatch(CharSequence value, Matcher<Character> matcher);\npublic static boolean isNumeric(CharSequence str);\npublic static String move(CharSequence str, int startInclude, int endExclude, int moveLength);\npublic static boolean isCharEquals(CharSequence str);\npublic static String normalize(CharSequence str);\npublic static String fixLength(CharSequence str, char fixedChar, int length);\npublic static boolean hasLetter(CharSequence str);\npublic static CharSequence commonPrefix(CharSequence str1, CharSequence str2);\npublic static CharSequence commonSuffix(CharSequence str1, CharSequence str2);",
        "public_field": "public static final int INDEX_NOT_FOUND = Finder.INDEX_NOT_FOUND;\n/**\n * 字符串常量：{@code \"null\"} <br>\n * 注意：{@code \"null\" != null}\n */\npublic static final String NULL = \"null\";\n/**\n * 字符串常量：空字符串 {@code \"\"}\n */\npublic static final String EMPTY = \"\";\n/**\n * 字符串常量：空格符 {@code \" \"}\n */\npublic static final String SPACE = \" \";",
        "Method_statement": "removeSuffixIgnoreCase(CharSequence str, CharSequence suffix)",
        "Method_name": "removeSuffixIgnoreCase",
        "Class_declaration": "public class CharSequenceUtil {\n",
        "constructors": "",
        "all_method_signature": "public static boolean isBlank(CharSequence str);\npublic static boolean isNotBlank(CharSequence str);\npublic static boolean hasBlank(CharSequence... strs);\npublic static boolean isAllBlank(CharSequence... strs);\npublic static boolean isEmpty(CharSequence str);\npublic static boolean isNotEmpty(CharSequence str);\npublic static String emptyIfNull(CharSequence str);\npublic static String nullToEmpty(CharSequence str);\npublic static String nullToDefault(CharSequence str, String defaultStr);\npublic static String emptyToDefault(CharSequence str, String defaultStr);\npublic static String blankToDefault(CharSequence str, String defaultStr);\npublic static String emptyToNull(CharSequence str);\npublic static boolean hasEmpty(CharSequence... strs);\npublic static boolean isAllEmpty(CharSequence... strs);\npublic static boolean isAllNotEmpty(CharSequence... args);\npublic static boolean isAllNotBlank(CharSequence... args);\npublic static boolean isNullOrUndefined(CharSequence str);\npublic static boolean isEmptyOrUndefined(CharSequence str);\npublic static boolean isBlankOrUndefined(CharSequence str);\nprivate static boolean isNullOrUndefinedStr(CharSequence str);\npublic static String trim(CharSequence str);\npublic static String trimToEmpty(CharSequence str);\npublic static String trimToNull(CharSequence str);\npublic static String trimStart(CharSequence str);\npublic static String trimEnd(CharSequence str);\npublic static String trim(CharSequence str, int mode);\npublic static String trim(CharSequence str, int mode, Predicate<Character> predicate);\npublic static boolean startWith(CharSequence str, char c);\npublic static boolean startWith(CharSequence str, CharSequence prefix, boolean ignoreCase);\npublic static boolean startWith(CharSequence str, CharSequence prefix, boolean ignoreCase, boolean ignoreEquals);\npublic static boolean startWith(CharSequence str, CharSequence prefix);\npublic static boolean startWithIgnoreEquals(CharSequence str, CharSequence prefix);\npublic static boolean startWithIgnoreCase(CharSequence str, CharSequence prefix);\npublic static boolean startWithAny(CharSequence str, CharSequence... prefixes);\npublic static boolean startWithAnyIgnoreCase(final CharSequence str, final CharSequence... suffixes);\npublic static boolean endWith(CharSequence str, char c);\npublic static boolean endWith(CharSequence str, CharSequence suffix, boolean ignoreCase);\npublic static boolean endWith(CharSequence str, CharSequence suffix, boolean ignoreCase, boolean ignoreEquals);\npublic static boolean endWith(CharSequence str, CharSequence suffix);\npublic static boolean endWithIgnoreCase(CharSequence str, CharSequence suffix);\npublic static boolean endWithAny(CharSequence str, CharSequence... suffixes);\npublic static boolean endWithAnyIgnoreCase(CharSequence str, CharSequence... suffixes);\npublic static boolean contains(CharSequence str, char searchChar);\npublic static boolean contains(CharSequence str, CharSequence searchStr);\npublic static boolean containsAny(CharSequence str, CharSequence... testStrs);\npublic static boolean containsAny(CharSequence str, char... testChars);\npublic static boolean containsOnly(CharSequence str, char... testChars);\npublic static boolean containsAll(CharSequence str, CharSequence... testChars);\npublic static boolean containsBlank(CharSequence str);\npublic static String getContainsStr(CharSequence str, CharSequence... testStrs);\npublic static boolean containsIgnoreCase(CharSequence str, CharSequence testStr);\npublic static boolean containsAnyIgnoreCase(CharSequence str, CharSequence... testStrs);\npublic static String getContainsStrIgnoreCase(CharSequence str, CharSequence... testStrs);\npublic static int indexOf(CharSequence str, char searchChar);\npublic static int indexOf(CharSequence str, char searchChar, int start);\npublic static int indexOf(CharSequence text, char searchChar, int start, int end);\npublic static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr);\npublic static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int fromIndex);\npublic static int indexOf(CharSequence text, CharSequence searchStr, int from, boolean ignoreCase);\npublic static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr);\npublic static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr, int fromIndex);\npublic static int lastIndexOf(CharSequence text, CharSequence searchStr, int from, boolean ignoreCase);\npublic static int ordinalIndexOf(CharSequence str, CharSequence searchStr, int ordinal);\npublic static String removeAll(CharSequence str, CharSequence strToRemove);\npublic static String removeAny(CharSequence str, CharSequence... strsToRemove);\npublic static String removeAll(CharSequence str, char... chars);\npublic static String removeAllLineBreaks(CharSequence str);\npublic static String removePreAndLowerFirst(CharSequence str, int preLength);\npublic static String removePreAndLowerFirst(CharSequence str, CharSequence prefix);\npublic static String removePrefix(CharSequence str, CharSequence prefix);\npublic static String removePrefixIgnoreCase(CharSequence str, CharSequence prefix);\npublic static String removeSuffix(CharSequence str, CharSequence suffix);\npublic static String removeSufAndLowerFirst(CharSequence str, CharSequence suffix);\npublic static String removeSuffixIgnoreCase(CharSequence str, CharSequence suffix);\npublic static String cleanBlank(CharSequence str);\npublic static String strip(CharSequence str, CharSequence prefixOrSuffix);\npublic static String strip(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String stripIgnoreCase(CharSequence str, CharSequence prefixOrSuffix);\npublic static String stripIgnoreCase(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String addPrefixIfNot(CharSequence str, CharSequence prefix);\npublic static String addSuffixIfNot(CharSequence str, CharSequence suffix);\npublic static long[] splitToLong(CharSequence str, char separator);\npublic static long[] splitToLong(CharSequence str, CharSequence separator);\npublic static int[] splitToInt(CharSequence str, char separator);\npublic static int[] splitToInt(CharSequence str, CharSequence separator);\npublic static List<String> split(CharSequence str, char separator);\npublic static String[] splitToArray(CharSequence str, CharSequence separator);\npublic static String[] splitToArray(CharSequence str, char separator);\npublic static String[] splitToArray(CharSequence text, char separator, int limit);\npublic static List<String> split(CharSequence str, char separator, int limit);\npublic static List<String> splitTrim(CharSequence str, char separator);\npublic static List<String> splitTrim(CharSequence str, CharSequence separator);\npublic static List<String> splitTrim(CharSequence str, char separator, int limit);\npublic static List<String> splitTrim(CharSequence str, CharSequence separator, int limit);\npublic static List<String> split(CharSequence str, char separator, boolean isTrim, boolean ignoreEmpty);\npublic static List<String> split(CharSequence str, char separator, int limit, boolean isTrim, boolean ignoreEmpty);\npublic static List<R> split(CharSequence str, char separator, int limit, boolean ignoreEmpty, Function<String, R> mapping);\npublic static List<String> split(CharSequence str, CharSequence separator);\npublic static List<String> split(CharSequence str, CharSequence separator, boolean isTrim, boolean ignoreEmpty);\npublic static List<String> split(CharSequence str, CharSequence separator, int limit, boolean isTrim, boolean ignoreEmpty);\npublic static String[] split(CharSequence str, int len);\npublic static String[] cut(CharSequence str, int partLength);\npublic static String sub(CharSequence str, int fromIndexInclude, int toIndexExclude);\npublic static String subByCodePoint(CharSequence str, int fromIndex, int toIndex);\npublic static String subPreGbk(CharSequence str, int len, CharSequence suffix);\npublic static String subPreGbk(CharSequence str, int len, boolean halfUp);\npublic static String subPre(CharSequence string, int toIndexExclude);\npublic static String subSuf(CharSequence string, int fromIndex);\npublic static String subSufByLength(CharSequence string, int length);\npublic static String subWithLength(String input, int fromIndex, int length);\npublic static String subBefore(CharSequence string, CharSequence separator, boolean isLastSeparator);\npublic static String subBefore(CharSequence string, char separator, boolean isLastSeparator);\npublic static String subAfter(CharSequence string, CharSequence separator, boolean isLastSeparator);\npublic static String subAfter(CharSequence string, char separator, boolean isLastSeparator);\npublic static String subBetween(CharSequence str, CharSequence before, CharSequence after);\npublic static String subBetween(CharSequence str, CharSequence beforeAndAfter);\npublic static String[] subBetweenAll(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String[] subBetweenAll(CharSequence str, CharSequence prefixAndSuffix);\npublic static String repeat(char c, int count);\npublic static String repeat(CharSequence str, int count);\npublic static String repeatByLength(CharSequence str, int padLen);\npublic static String repeatAndJoin(CharSequence str, int count, CharSequence delimiter);\npublic static boolean equals(CharSequence str1, CharSequence str2);\npublic static boolean equalsIgnoreCase(CharSequence str1, CharSequence str2);\npublic static boolean equals(CharSequence str1, CharSequence str2, boolean ignoreCase);\npublic static boolean equalsAnyIgnoreCase(CharSequence str1, CharSequence... strs);\npublic static boolean equalsAny(CharSequence str1, CharSequence... strs);\npublic static boolean equalsAny(CharSequence str1, boolean ignoreCase, CharSequence... strs);\npublic static boolean equalsCharAt(CharSequence str, int position, char c);\npublic static boolean isSubEquals(CharSequence str1, int start1, CharSequence str2, boolean ignoreCase);\npublic static boolean isSubEquals(CharSequence str1, int start1, CharSequence str2, int start2, int length, boolean ignoreCase);\npublic static String format(CharSequence template, Object... params);\npublic static String indexedFormat(CharSequence pattern, Object... arguments);\npublic static byte[] utf8Bytes(CharSequence str);\npublic static byte[] bytes(CharSequence str);\npublic static byte[] bytes(CharSequence str, String charset);\npublic static byte[] bytes(CharSequence str, Charset charset);\npublic static ByteBuffer byteBuffer(CharSequence str, String charset);\npublic static String wrap(CharSequence str, CharSequence prefixAndSuffix);\npublic static String wrap(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String[] wrapAllWithPair(CharSequence prefixAndSuffix, CharSequence... strs);\npublic static String[] wrapAll(CharSequence prefix, CharSequence suffix, CharSequence... strs);\npublic static String wrapIfMissing(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String[] wrapAllWithPairIfMissing(CharSequence prefixAndSuffix, CharSequence... strs);\npublic static String[] wrapAllIfMissing(CharSequence prefix, CharSequence suffix, CharSequence... strs);\npublic static String unWrap(CharSequence str, String prefix, String suffix);\npublic static String unWrap(CharSequence str, char prefix, char suffix);\npublic static String unWrap(CharSequence str, char prefixAndSuffix);\npublic static boolean isWrap(CharSequence str, String prefix, String suffix);\npublic static boolean isWrap(CharSequence str, String wrapper);\npublic static boolean isWrap(CharSequence str, char wrapper);\npublic static boolean isWrap(CharSequence str, char prefixChar, char suffixChar);\npublic static String padPre(CharSequence str, int length, CharSequence padStr);\npublic static String padPre(CharSequence str, int length, char padChar);\npublic static String padAfter(CharSequence str, int length, char padChar);\npublic static String padAfter(CharSequence str, int length, CharSequence padStr);\npublic static String center(CharSequence str, final int size);\npublic static String center(CharSequence str, final int size, char padChar);\npublic static String center(CharSequence str, final int size, CharSequence padStr);\npublic static String str(CharSequence cs);\npublic static int count(CharSequence content, CharSequence strForSearch);\npublic static int count(CharSequence content, char charForSearch);\npublic static int compare(final CharSequence str1, final CharSequence str2, final boolean nullIsLess);\npublic static int compareIgnoreCase(CharSequence str1, CharSequence str2, boolean nullIsLess);\npublic static int compareVersion(CharSequence version1, CharSequence version2);\npublic static String appendIfMissing(CharSequence str, CharSequence suffix, CharSequence... suffixes);\npublic static String appendIfMissingIgnoreCase(CharSequence str, CharSequence suffix, CharSequence... suffixes);\npublic static String appendIfMissing(CharSequence str, CharSequence suffix, boolean ignoreCase, CharSequence... testSuffixes);\npublic static String prependIfMissing(CharSequence str, CharSequence prefix, CharSequence... prefixes);\npublic static String prependIfMissingIgnoreCase(CharSequence str, CharSequence prefix, CharSequence... prefixes);\npublic static String prependIfMissing(CharSequence str, CharSequence prefix, boolean ignoreCase, CharSequence... prefixes);\npublic static String replaceIgnoreCase(CharSequence str, CharSequence searchStr, CharSequence replacement);\npublic static String replace(CharSequence str, CharSequence searchStr, CharSequence replacement);\npublic static String replace(CharSequence str, CharSequence searchStr, CharSequence replacement, boolean ignoreCase);\npublic static String replace(CharSequence str, int fromIndex, CharSequence searchStr, CharSequence replacement, boolean ignoreCase);\npublic static String replace(CharSequence str, int startInclude, int endExclude, char replacedChar);\npublic static String replace(CharSequence str, int startInclude, int endExclude, CharSequence replacedStr);\npublic static String replace(CharSequence str, java.util.regex.Pattern pattern, Func1<java.util.regex.Matcher, String> replaceFun);\npublic static String replace(CharSequence str, String regex, Func1<java.util.regex.Matcher, String> replaceFun);\npublic static String replaceLast(CharSequence str, CharSequence searchStr, CharSequence replacedStr);\npublic static String replaceLast(CharSequence str, CharSequence searchStr, CharSequence replacedStr, boolean ignoreCase);\npublic static String replaceFirst(CharSequence str, CharSequence searchStr, CharSequence replacedStr);\npublic static String replaceFirst(CharSequence str, CharSequence searchStr, CharSequence replacedStr, boolean ignoreCase);\npublic static String hide(CharSequence str, int startInclude, int endExclude);\npublic static String desensitized(CharSequence str, DesensitizedUtil.DesensitizedType desensitizedType);\npublic static String replaceChars(CharSequence str, String chars, CharSequence replacedStr);\npublic static String replaceChars(CharSequence str, char[] chars, CharSequence replacedStr);\npublic static int length(CharSequence cs);\npublic static int byteLength(CharSequence cs, Charset charset);\npublic static int totalLength(CharSequence... strs);\npublic static String maxLength(CharSequence string, int length);\npublic static T firstNonNull(T... strs);\npublic static T firstNonEmpty(T... strs);\npublic static T firstNonBlank(T... strs);\npublic static String upperFirstAndAddPre(CharSequence str, String preString);\npublic static String upperFirst(CharSequence str);\npublic static String lowerFirst(CharSequence str);\npublic static String filter(CharSequence str, final Filter<Character> filter);\npublic static boolean isUpperCase(CharSequence str);\npublic static boolean isLowerCase(CharSequence str);\npublic static String swapCase(final String str);\npublic static String toUnderlineCase(CharSequence str);\npublic static String toSymbolCase(CharSequence str, char symbol);\npublic static String toCamelCase(CharSequence name);\npublic static String toCamelCase(CharSequence name, char symbol);\npublic static boolean isSurround(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static boolean isSurround(CharSequence str, char prefix, char suffix);\npublic static StringBuilder builder(CharSequence... strs);\npublic static StrBuilder strBuilder(CharSequence... strs);\npublic static String getGeneralField(CharSequence getOrSetMethodName);\npublic static String genSetter(CharSequence fieldName);\npublic static String genGetter(CharSequence fieldName);\npublic static String concat(boolean isNullToEmpty, CharSequence... strs);\npublic static String brief(CharSequence str, int maxLength);\npublic static String join(CharSequence conjunction, Object... objs);\npublic static String join(CharSequence conjunction, Iterable<T> iterable);\npublic static boolean isAllCharMatch(CharSequence value, Matcher<Character> matcher);\npublic static boolean isNumeric(CharSequence str);\npublic static String move(CharSequence str, int startInclude, int endExclude, int moveLength);\npublic static boolean isCharEquals(CharSequence str);\npublic static String normalize(CharSequence str);\npublic static String fixLength(CharSequence str, char fixedChar, int length);\npublic static boolean hasLetter(CharSequence str);\npublic static CharSequence commonPrefix(CharSequence str1, CharSequence str2);\npublic static CharSequence commonSuffix(CharSequence str1, CharSequence str2);",
        "Class_name": "CharSequenceUtil",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/text/CharSequenceUtil###removeSuffixIgnoreCase",
        "Parameter_num": "2",
        "all_Import_statements": "import cn.hutool.core.collection.CollUtil;\n\nimport cn.hutool.core.comparator.VersionComparator;\n\nimport cn.hutool.core.convert.Convert;\n\nimport cn.hutool.core.lang.Assert;\n\nimport cn.hutool.core.lang.Filter;\n\nimport cn.hutool.core.lang.Matcher;\n\nimport cn.hutool.core.lang.func.Func1;\n\nimport cn.hutool.core.text.finder.CharFinder;\n\nimport cn.hutool.core.text.finder.Finder;\n\nimport cn.hutool.core.text.finder.StrFinder;\n\nimport cn.hutool.core.util.ArrayUtil;\n\nimport cn.hutool.core.util.CharUtil;\n\nimport cn.hutool.core.util.CharsetUtil;\n\nimport cn.hutool.core.util.DesensitizedUtil;\n\nimport cn.hutool.core.util.NumberUtil;\n\nimport cn.hutool.core.util.ReUtil;\n\nimport cn.hutool.core.util.StrUtil;\n\nimport java.nio.ByteBuffer;\n\nimport java.nio.charset.Charset;\n\nimport java.text.MessageFormat;\n\nimport java.text.Normalizer;\n\nimport java.util.HashSet;\n\nimport java.util.LinkedList;\n\nimport java.util.List;\n\nimport java.util.Set;\n\nimport java.util.function.Function;\n\nimport java.util.function.Predicate;\n",
        "comment": "\n\t * 忽略大小写去掉指定后缀\n\t *\n\t * @param str    字符串\n\t * @param suffix 后缀\n\t * @return 切掉后的字符串，若后缀不是 suffix， 返回原字符串\n\t ",
        "packageName": "cn.hutool.core.text",
        "method_signature": "public static String removeSuffixIgnoreCase(CharSequence str, CharSequence suffix);",
        "Junit_version": "5",
        "returnType": "String"
    },
    {
        "Method_body": "public static String removePrefixIgnoreCase(CharSequence str, CharSequence prefix) {\n    if (isEmpty(str) || isEmpty(prefix)) {\n        return str(str);\n    }\n    final String str2 = str.toString();\n    if (startWithIgnoreCase(str, prefix)) {\n        return subSuf(str2, prefix.length());\n    }\n    return str2;\n}",
        "all_field_declaration": "public static final int INDEX_NOT_FOUND = Finder.INDEX_NOT_FOUND;\n/**\n * 字符串常量：{@code \"null\"} <br>\n * 注意：{@code \"null\" != null}\n */\npublic static final String NULL = \"null\";\n/**\n * 字符串常量：空字符串 {@code \"\"}\n */\npublic static final String EMPTY = \"\";\n/**\n * 字符串常量：空格符 {@code \" \"}\n */\npublic static final String SPACE = \" \";",
        "sub_project_name": "hutool-core",
        "lineNumbers": "4",
        "Filed": "",
        "Parameter_type": "CharSequence,CharSequence",
        "Import_statements": "",
        "public_method_signature": "public static boolean isBlank(CharSequence str);\npublic static boolean isNotBlank(CharSequence str);\npublic static boolean hasBlank(CharSequence... strs);\npublic static boolean isAllBlank(CharSequence... strs);\npublic static boolean isEmpty(CharSequence str);\npublic static boolean isNotEmpty(CharSequence str);\npublic static String emptyIfNull(CharSequence str);\npublic static String nullToEmpty(CharSequence str);\npublic static String nullToDefault(CharSequence str, String defaultStr);\npublic static String emptyToDefault(CharSequence str, String defaultStr);\npublic static String blankToDefault(CharSequence str, String defaultStr);\npublic static String emptyToNull(CharSequence str);\npublic static boolean hasEmpty(CharSequence... strs);\npublic static boolean isAllEmpty(CharSequence... strs);\npublic static boolean isAllNotEmpty(CharSequence... args);\npublic static boolean isAllNotBlank(CharSequence... args);\npublic static boolean isNullOrUndefined(CharSequence str);\npublic static boolean isEmptyOrUndefined(CharSequence str);\npublic static boolean isBlankOrUndefined(CharSequence str);\npublic static String trim(CharSequence str);\npublic static String trimToEmpty(CharSequence str);\npublic static String trimToNull(CharSequence str);\npublic static String trimStart(CharSequence str);\npublic static String trimEnd(CharSequence str);\npublic static String trim(CharSequence str, int mode);\npublic static String trim(CharSequence str, int mode, Predicate<Character> predicate);\npublic static boolean startWith(CharSequence str, char c);\npublic static boolean startWith(CharSequence str, CharSequence prefix, boolean ignoreCase);\npublic static boolean startWith(CharSequence str, CharSequence prefix, boolean ignoreCase, boolean ignoreEquals);\npublic static boolean startWith(CharSequence str, CharSequence prefix);\npublic static boolean startWithIgnoreEquals(CharSequence str, CharSequence prefix);\npublic static boolean startWithIgnoreCase(CharSequence str, CharSequence prefix);\npublic static boolean startWithAny(CharSequence str, CharSequence... prefixes);\npublic static boolean startWithAnyIgnoreCase(final CharSequence str, final CharSequence... suffixes);\npublic static boolean endWith(CharSequence str, char c);\npublic static boolean endWith(CharSequence str, CharSequence suffix, boolean ignoreCase);\npublic static boolean endWith(CharSequence str, CharSequence suffix, boolean ignoreCase, boolean ignoreEquals);\npublic static boolean endWith(CharSequence str, CharSequence suffix);\npublic static boolean endWithIgnoreCase(CharSequence str, CharSequence suffix);\npublic static boolean endWithAny(CharSequence str, CharSequence... suffixes);\npublic static boolean endWithAnyIgnoreCase(CharSequence str, CharSequence... suffixes);\npublic static boolean contains(CharSequence str, char searchChar);\npublic static boolean contains(CharSequence str, CharSequence searchStr);\npublic static boolean containsAny(CharSequence str, CharSequence... testStrs);\npublic static boolean containsAny(CharSequence str, char... testChars);\npublic static boolean containsOnly(CharSequence str, char... testChars);\npublic static boolean containsAll(CharSequence str, CharSequence... testChars);\npublic static boolean containsBlank(CharSequence str);\npublic static String getContainsStr(CharSequence str, CharSequence... testStrs);\npublic static boolean containsIgnoreCase(CharSequence str, CharSequence testStr);\npublic static boolean containsAnyIgnoreCase(CharSequence str, CharSequence... testStrs);\npublic static String getContainsStrIgnoreCase(CharSequence str, CharSequence... testStrs);\npublic static int indexOf(CharSequence str, char searchChar);\npublic static int indexOf(CharSequence str, char searchChar, int start);\npublic static int indexOf(CharSequence text, char searchChar, int start, int end);\npublic static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr);\npublic static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int fromIndex);\npublic static int indexOf(CharSequence text, CharSequence searchStr, int from, boolean ignoreCase);\npublic static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr);\npublic static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr, int fromIndex);\npublic static int lastIndexOf(CharSequence text, CharSequence searchStr, int from, boolean ignoreCase);\npublic static int ordinalIndexOf(CharSequence str, CharSequence searchStr, int ordinal);\npublic static String removeAll(CharSequence str, CharSequence strToRemove);\npublic static String removeAny(CharSequence str, CharSequence... strsToRemove);\npublic static String removeAll(CharSequence str, char... chars);\npublic static String removeAllLineBreaks(CharSequence str);\npublic static String removePreAndLowerFirst(CharSequence str, int preLength);\npublic static String removePreAndLowerFirst(CharSequence str, CharSequence prefix);\npublic static String removePrefix(CharSequence str, CharSequence prefix);\npublic static String removePrefixIgnoreCase(CharSequence str, CharSequence prefix);\npublic static String removeSuffix(CharSequence str, CharSequence suffix);\npublic static String removeSufAndLowerFirst(CharSequence str, CharSequence suffix);\npublic static String removeSuffixIgnoreCase(CharSequence str, CharSequence suffix);\npublic static String cleanBlank(CharSequence str);\npublic static String strip(CharSequence str, CharSequence prefixOrSuffix);\npublic static String strip(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String stripIgnoreCase(CharSequence str, CharSequence prefixOrSuffix);\npublic static String stripIgnoreCase(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String addPrefixIfNot(CharSequence str, CharSequence prefix);\npublic static String addSuffixIfNot(CharSequence str, CharSequence suffix);\npublic static long[] splitToLong(CharSequence str, char separator);\npublic static long[] splitToLong(CharSequence str, CharSequence separator);\npublic static int[] splitToInt(CharSequence str, char separator);\npublic static int[] splitToInt(CharSequence str, CharSequence separator);\npublic static List<String> split(CharSequence str, char separator);\npublic static String[] splitToArray(CharSequence str, CharSequence separator);\npublic static String[] splitToArray(CharSequence str, char separator);\npublic static String[] splitToArray(CharSequence text, char separator, int limit);\npublic static List<String> split(CharSequence str, char separator, int limit);\npublic static List<String> splitTrim(CharSequence str, char separator);\npublic static List<String> splitTrim(CharSequence str, CharSequence separator);\npublic static List<String> splitTrim(CharSequence str, char separator, int limit);\npublic static List<String> splitTrim(CharSequence str, CharSequence separator, int limit);\npublic static List<String> split(CharSequence str, char separator, boolean isTrim, boolean ignoreEmpty);\npublic static List<String> split(CharSequence str, char separator, int limit, boolean isTrim, boolean ignoreEmpty);\npublic static List<R> split(CharSequence str, char separator, int limit, boolean ignoreEmpty, Function<String, R> mapping);\npublic static List<String> split(CharSequence str, CharSequence separator);\npublic static List<String> split(CharSequence str, CharSequence separator, boolean isTrim, boolean ignoreEmpty);\npublic static List<String> split(CharSequence str, CharSequence separator, int limit, boolean isTrim, boolean ignoreEmpty);\npublic static String[] split(CharSequence str, int len);\npublic static String[] cut(CharSequence str, int partLength);\npublic static String sub(CharSequence str, int fromIndexInclude, int toIndexExclude);\npublic static String subByCodePoint(CharSequence str, int fromIndex, int toIndex);\npublic static String subPreGbk(CharSequence str, int len, CharSequence suffix);\npublic static String subPreGbk(CharSequence str, int len, boolean halfUp);\npublic static String subPre(CharSequence string, int toIndexExclude);\npublic static String subSuf(CharSequence string, int fromIndex);\npublic static String subSufByLength(CharSequence string, int length);\npublic static String subWithLength(String input, int fromIndex, int length);\npublic static String subBefore(CharSequence string, CharSequence separator, boolean isLastSeparator);\npublic static String subBefore(CharSequence string, char separator, boolean isLastSeparator);\npublic static String subAfter(CharSequence string, CharSequence separator, boolean isLastSeparator);\npublic static String subAfter(CharSequence string, char separator, boolean isLastSeparator);\npublic static String subBetween(CharSequence str, CharSequence before, CharSequence after);\npublic static String subBetween(CharSequence str, CharSequence beforeAndAfter);\npublic static String[] subBetweenAll(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String[] subBetweenAll(CharSequence str, CharSequence prefixAndSuffix);\npublic static String repeat(char c, int count);\npublic static String repeat(CharSequence str, int count);\npublic static String repeatByLength(CharSequence str, int padLen);\npublic static String repeatAndJoin(CharSequence str, int count, CharSequence delimiter);\npublic static boolean equals(CharSequence str1, CharSequence str2);\npublic static boolean equalsIgnoreCase(CharSequence str1, CharSequence str2);\npublic static boolean equals(CharSequence str1, CharSequence str2, boolean ignoreCase);\npublic static boolean equalsAnyIgnoreCase(CharSequence str1, CharSequence... strs);\npublic static boolean equalsAny(CharSequence str1, CharSequence... strs);\npublic static boolean equalsAny(CharSequence str1, boolean ignoreCase, CharSequence... strs);\npublic static boolean equalsCharAt(CharSequence str, int position, char c);\npublic static boolean isSubEquals(CharSequence str1, int start1, CharSequence str2, boolean ignoreCase);\npublic static boolean isSubEquals(CharSequence str1, int start1, CharSequence str2, int start2, int length, boolean ignoreCase);\npublic static String format(CharSequence template, Object... params);\npublic static String indexedFormat(CharSequence pattern, Object... arguments);\npublic static byte[] utf8Bytes(CharSequence str);\npublic static byte[] bytes(CharSequence str);\npublic static byte[] bytes(CharSequence str, String charset);\npublic static byte[] bytes(CharSequence str, Charset charset);\npublic static ByteBuffer byteBuffer(CharSequence str, String charset);\npublic static String wrap(CharSequence str, CharSequence prefixAndSuffix);\npublic static String wrap(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String[] wrapAllWithPair(CharSequence prefixAndSuffix, CharSequence... strs);\npublic static String[] wrapAll(CharSequence prefix, CharSequence suffix, CharSequence... strs);\npublic static String wrapIfMissing(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String[] wrapAllWithPairIfMissing(CharSequence prefixAndSuffix, CharSequence... strs);\npublic static String[] wrapAllIfMissing(CharSequence prefix, CharSequence suffix, CharSequence... strs);\npublic static String unWrap(CharSequence str, String prefix, String suffix);\npublic static String unWrap(CharSequence str, char prefix, char suffix);\npublic static String unWrap(CharSequence str, char prefixAndSuffix);\npublic static boolean isWrap(CharSequence str, String prefix, String suffix);\npublic static boolean isWrap(CharSequence str, String wrapper);\npublic static boolean isWrap(CharSequence str, char wrapper);\npublic static boolean isWrap(CharSequence str, char prefixChar, char suffixChar);\npublic static String padPre(CharSequence str, int length, CharSequence padStr);\npublic static String padPre(CharSequence str, int length, char padChar);\npublic static String padAfter(CharSequence str, int length, char padChar);\npublic static String padAfter(CharSequence str, int length, CharSequence padStr);\npublic static String center(CharSequence str, final int size);\npublic static String center(CharSequence str, final int size, char padChar);\npublic static String center(CharSequence str, final int size, CharSequence padStr);\npublic static String str(CharSequence cs);\npublic static int count(CharSequence content, CharSequence strForSearch);\npublic static int count(CharSequence content, char charForSearch);\npublic static int compare(final CharSequence str1, final CharSequence str2, final boolean nullIsLess);\npublic static int compareIgnoreCase(CharSequence str1, CharSequence str2, boolean nullIsLess);\npublic static int compareVersion(CharSequence version1, CharSequence version2);\npublic static String appendIfMissing(CharSequence str, CharSequence suffix, CharSequence... suffixes);\npublic static String appendIfMissingIgnoreCase(CharSequence str, CharSequence suffix, CharSequence... suffixes);\npublic static String appendIfMissing(CharSequence str, CharSequence suffix, boolean ignoreCase, CharSequence... testSuffixes);\npublic static String prependIfMissing(CharSequence str, CharSequence prefix, CharSequence... prefixes);\npublic static String prependIfMissingIgnoreCase(CharSequence str, CharSequence prefix, CharSequence... prefixes);\npublic static String prependIfMissing(CharSequence str, CharSequence prefix, boolean ignoreCase, CharSequence... prefixes);\npublic static String replaceIgnoreCase(CharSequence str, CharSequence searchStr, CharSequence replacement);\npublic static String replace(CharSequence str, CharSequence searchStr, CharSequence replacement);\npublic static String replace(CharSequence str, CharSequence searchStr, CharSequence replacement, boolean ignoreCase);\npublic static String replace(CharSequence str, int fromIndex, CharSequence searchStr, CharSequence replacement, boolean ignoreCase);\npublic static String replace(CharSequence str, int startInclude, int endExclude, char replacedChar);\npublic static String replace(CharSequence str, int startInclude, int endExclude, CharSequence replacedStr);\npublic static String replace(CharSequence str, java.util.regex.Pattern pattern, Func1<java.util.regex.Matcher, String> replaceFun);\npublic static String replace(CharSequence str, String regex, Func1<java.util.regex.Matcher, String> replaceFun);\npublic static String replaceLast(CharSequence str, CharSequence searchStr, CharSequence replacedStr);\npublic static String replaceLast(CharSequence str, CharSequence searchStr, CharSequence replacedStr, boolean ignoreCase);\npublic static String replaceFirst(CharSequence str, CharSequence searchStr, CharSequence replacedStr);\npublic static String replaceFirst(CharSequence str, CharSequence searchStr, CharSequence replacedStr, boolean ignoreCase);\npublic static String hide(CharSequence str, int startInclude, int endExclude);\npublic static String desensitized(CharSequence str, DesensitizedUtil.DesensitizedType desensitizedType);\npublic static String replaceChars(CharSequence str, String chars, CharSequence replacedStr);\npublic static String replaceChars(CharSequence str, char[] chars, CharSequence replacedStr);\npublic static int length(CharSequence cs);\npublic static int byteLength(CharSequence cs, Charset charset);\npublic static int totalLength(CharSequence... strs);\npublic static String maxLength(CharSequence string, int length);\npublic static T firstNonNull(T... strs);\npublic static T firstNonEmpty(T... strs);\npublic static T firstNonBlank(T... strs);\npublic static String upperFirstAndAddPre(CharSequence str, String preString);\npublic static String upperFirst(CharSequence str);\npublic static String lowerFirst(CharSequence str);\npublic static String filter(CharSequence str, final Filter<Character> filter);\npublic static boolean isUpperCase(CharSequence str);\npublic static boolean isLowerCase(CharSequence str);\npublic static String swapCase(final String str);\npublic static String toUnderlineCase(CharSequence str);\npublic static String toSymbolCase(CharSequence str, char symbol);\npublic static String toCamelCase(CharSequence name);\npublic static String toCamelCase(CharSequence name, char symbol);\npublic static boolean isSurround(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static boolean isSurround(CharSequence str, char prefix, char suffix);\npublic static StringBuilder builder(CharSequence... strs);\npublic static StrBuilder strBuilder(CharSequence... strs);\npublic static String getGeneralField(CharSequence getOrSetMethodName);\npublic static String genSetter(CharSequence fieldName);\npublic static String genGetter(CharSequence fieldName);\npublic static String concat(boolean isNullToEmpty, CharSequence... strs);\npublic static String brief(CharSequence str, int maxLength);\npublic static String join(CharSequence conjunction, Object... objs);\npublic static String join(CharSequence conjunction, Iterable<T> iterable);\npublic static boolean isAllCharMatch(CharSequence value, Matcher<Character> matcher);\npublic static boolean isNumeric(CharSequence str);\npublic static String move(CharSequence str, int startInclude, int endExclude, int moveLength);\npublic static boolean isCharEquals(CharSequence str);\npublic static String normalize(CharSequence str);\npublic static String fixLength(CharSequence str, char fixedChar, int length);\npublic static boolean hasLetter(CharSequence str);\npublic static CharSequence commonPrefix(CharSequence str1, CharSequence str2);\npublic static CharSequence commonSuffix(CharSequence str1, CharSequence str2);",
        "public_field": "public static final int INDEX_NOT_FOUND = Finder.INDEX_NOT_FOUND;\n/**\n * 字符串常量：{@code \"null\"} <br>\n * 注意：{@code \"null\" != null}\n */\npublic static final String NULL = \"null\";\n/**\n * 字符串常量：空字符串 {@code \"\"}\n */\npublic static final String EMPTY = \"\";\n/**\n * 字符串常量：空格符 {@code \" \"}\n */\npublic static final String SPACE = \" \";",
        "Method_statement": "removePrefixIgnoreCase(CharSequence str, CharSequence prefix)",
        "Method_name": "removePrefixIgnoreCase",
        "Class_declaration": "public class CharSequenceUtil {\n",
        "constructors": "",
        "all_method_signature": "public static boolean isBlank(CharSequence str);\npublic static boolean isNotBlank(CharSequence str);\npublic static boolean hasBlank(CharSequence... strs);\npublic static boolean isAllBlank(CharSequence... strs);\npublic static boolean isEmpty(CharSequence str);\npublic static boolean isNotEmpty(CharSequence str);\npublic static String emptyIfNull(CharSequence str);\npublic static String nullToEmpty(CharSequence str);\npublic static String nullToDefault(CharSequence str, String defaultStr);\npublic static String emptyToDefault(CharSequence str, String defaultStr);\npublic static String blankToDefault(CharSequence str, String defaultStr);\npublic static String emptyToNull(CharSequence str);\npublic static boolean hasEmpty(CharSequence... strs);\npublic static boolean isAllEmpty(CharSequence... strs);\npublic static boolean isAllNotEmpty(CharSequence... args);\npublic static boolean isAllNotBlank(CharSequence... args);\npublic static boolean isNullOrUndefined(CharSequence str);\npublic static boolean isEmptyOrUndefined(CharSequence str);\npublic static boolean isBlankOrUndefined(CharSequence str);\nprivate static boolean isNullOrUndefinedStr(CharSequence str);\npublic static String trim(CharSequence str);\npublic static String trimToEmpty(CharSequence str);\npublic static String trimToNull(CharSequence str);\npublic static String trimStart(CharSequence str);\npublic static String trimEnd(CharSequence str);\npublic static String trim(CharSequence str, int mode);\npublic static String trim(CharSequence str, int mode, Predicate<Character> predicate);\npublic static boolean startWith(CharSequence str, char c);\npublic static boolean startWith(CharSequence str, CharSequence prefix, boolean ignoreCase);\npublic static boolean startWith(CharSequence str, CharSequence prefix, boolean ignoreCase, boolean ignoreEquals);\npublic static boolean startWith(CharSequence str, CharSequence prefix);\npublic static boolean startWithIgnoreEquals(CharSequence str, CharSequence prefix);\npublic static boolean startWithIgnoreCase(CharSequence str, CharSequence prefix);\npublic static boolean startWithAny(CharSequence str, CharSequence... prefixes);\npublic static boolean startWithAnyIgnoreCase(final CharSequence str, final CharSequence... suffixes);\npublic static boolean endWith(CharSequence str, char c);\npublic static boolean endWith(CharSequence str, CharSequence suffix, boolean ignoreCase);\npublic static boolean endWith(CharSequence str, CharSequence suffix, boolean ignoreCase, boolean ignoreEquals);\npublic static boolean endWith(CharSequence str, CharSequence suffix);\npublic static boolean endWithIgnoreCase(CharSequence str, CharSequence suffix);\npublic static boolean endWithAny(CharSequence str, CharSequence... suffixes);\npublic static boolean endWithAnyIgnoreCase(CharSequence str, CharSequence... suffixes);\npublic static boolean contains(CharSequence str, char searchChar);\npublic static boolean contains(CharSequence str, CharSequence searchStr);\npublic static boolean containsAny(CharSequence str, CharSequence... testStrs);\npublic static boolean containsAny(CharSequence str, char... testChars);\npublic static boolean containsOnly(CharSequence str, char... testChars);\npublic static boolean containsAll(CharSequence str, CharSequence... testChars);\npublic static boolean containsBlank(CharSequence str);\npublic static String getContainsStr(CharSequence str, CharSequence... testStrs);\npublic static boolean containsIgnoreCase(CharSequence str, CharSequence testStr);\npublic static boolean containsAnyIgnoreCase(CharSequence str, CharSequence... testStrs);\npublic static String getContainsStrIgnoreCase(CharSequence str, CharSequence... testStrs);\npublic static int indexOf(CharSequence str, char searchChar);\npublic static int indexOf(CharSequence str, char searchChar, int start);\npublic static int indexOf(CharSequence text, char searchChar, int start, int end);\npublic static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr);\npublic static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int fromIndex);\npublic static int indexOf(CharSequence text, CharSequence searchStr, int from, boolean ignoreCase);\npublic static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr);\npublic static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr, int fromIndex);\npublic static int lastIndexOf(CharSequence text, CharSequence searchStr, int from, boolean ignoreCase);\npublic static int ordinalIndexOf(CharSequence str, CharSequence searchStr, int ordinal);\npublic static String removeAll(CharSequence str, CharSequence strToRemove);\npublic static String removeAny(CharSequence str, CharSequence... strsToRemove);\npublic static String removeAll(CharSequence str, char... chars);\npublic static String removeAllLineBreaks(CharSequence str);\npublic static String removePreAndLowerFirst(CharSequence str, int preLength);\npublic static String removePreAndLowerFirst(CharSequence str, CharSequence prefix);\npublic static String removePrefix(CharSequence str, CharSequence prefix);\npublic static String removePrefixIgnoreCase(CharSequence str, CharSequence prefix);\npublic static String removeSuffix(CharSequence str, CharSequence suffix);\npublic static String removeSufAndLowerFirst(CharSequence str, CharSequence suffix);\npublic static String removeSuffixIgnoreCase(CharSequence str, CharSequence suffix);\npublic static String cleanBlank(CharSequence str);\npublic static String strip(CharSequence str, CharSequence prefixOrSuffix);\npublic static String strip(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String stripIgnoreCase(CharSequence str, CharSequence prefixOrSuffix);\npublic static String stripIgnoreCase(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String addPrefixIfNot(CharSequence str, CharSequence prefix);\npublic static String addSuffixIfNot(CharSequence str, CharSequence suffix);\npublic static long[] splitToLong(CharSequence str, char separator);\npublic static long[] splitToLong(CharSequence str, CharSequence separator);\npublic static int[] splitToInt(CharSequence str, char separator);\npublic static int[] splitToInt(CharSequence str, CharSequence separator);\npublic static List<String> split(CharSequence str, char separator);\npublic static String[] splitToArray(CharSequence str, CharSequence separator);\npublic static String[] splitToArray(CharSequence str, char separator);\npublic static String[] splitToArray(CharSequence text, char separator, int limit);\npublic static List<String> split(CharSequence str, char separator, int limit);\npublic static List<String> splitTrim(CharSequence str, char separator);\npublic static List<String> splitTrim(CharSequence str, CharSequence separator);\npublic static List<String> splitTrim(CharSequence str, char separator, int limit);\npublic static List<String> splitTrim(CharSequence str, CharSequence separator, int limit);\npublic static List<String> split(CharSequence str, char separator, boolean isTrim, boolean ignoreEmpty);\npublic static List<String> split(CharSequence str, char separator, int limit, boolean isTrim, boolean ignoreEmpty);\npublic static List<R> split(CharSequence str, char separator, int limit, boolean ignoreEmpty, Function<String, R> mapping);\npublic static List<String> split(CharSequence str, CharSequence separator);\npublic static List<String> split(CharSequence str, CharSequence separator, boolean isTrim, boolean ignoreEmpty);\npublic static List<String> split(CharSequence str, CharSequence separator, int limit, boolean isTrim, boolean ignoreEmpty);\npublic static String[] split(CharSequence str, int len);\npublic static String[] cut(CharSequence str, int partLength);\npublic static String sub(CharSequence str, int fromIndexInclude, int toIndexExclude);\npublic static String subByCodePoint(CharSequence str, int fromIndex, int toIndex);\npublic static String subPreGbk(CharSequence str, int len, CharSequence suffix);\npublic static String subPreGbk(CharSequence str, int len, boolean halfUp);\npublic static String subPre(CharSequence string, int toIndexExclude);\npublic static String subSuf(CharSequence string, int fromIndex);\npublic static String subSufByLength(CharSequence string, int length);\npublic static String subWithLength(String input, int fromIndex, int length);\npublic static String subBefore(CharSequence string, CharSequence separator, boolean isLastSeparator);\npublic static String subBefore(CharSequence string, char separator, boolean isLastSeparator);\npublic static String subAfter(CharSequence string, CharSequence separator, boolean isLastSeparator);\npublic static String subAfter(CharSequence string, char separator, boolean isLastSeparator);\npublic static String subBetween(CharSequence str, CharSequence before, CharSequence after);\npublic static String subBetween(CharSequence str, CharSequence beforeAndAfter);\npublic static String[] subBetweenAll(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String[] subBetweenAll(CharSequence str, CharSequence prefixAndSuffix);\npublic static String repeat(char c, int count);\npublic static String repeat(CharSequence str, int count);\npublic static String repeatByLength(CharSequence str, int padLen);\npublic static String repeatAndJoin(CharSequence str, int count, CharSequence delimiter);\npublic static boolean equals(CharSequence str1, CharSequence str2);\npublic static boolean equalsIgnoreCase(CharSequence str1, CharSequence str2);\npublic static boolean equals(CharSequence str1, CharSequence str2, boolean ignoreCase);\npublic static boolean equalsAnyIgnoreCase(CharSequence str1, CharSequence... strs);\npublic static boolean equalsAny(CharSequence str1, CharSequence... strs);\npublic static boolean equalsAny(CharSequence str1, boolean ignoreCase, CharSequence... strs);\npublic static boolean equalsCharAt(CharSequence str, int position, char c);\npublic static boolean isSubEquals(CharSequence str1, int start1, CharSequence str2, boolean ignoreCase);\npublic static boolean isSubEquals(CharSequence str1, int start1, CharSequence str2, int start2, int length, boolean ignoreCase);\npublic static String format(CharSequence template, Object... params);\npublic static String indexedFormat(CharSequence pattern, Object... arguments);\npublic static byte[] utf8Bytes(CharSequence str);\npublic static byte[] bytes(CharSequence str);\npublic static byte[] bytes(CharSequence str, String charset);\npublic static byte[] bytes(CharSequence str, Charset charset);\npublic static ByteBuffer byteBuffer(CharSequence str, String charset);\npublic static String wrap(CharSequence str, CharSequence prefixAndSuffix);\npublic static String wrap(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String[] wrapAllWithPair(CharSequence prefixAndSuffix, CharSequence... strs);\npublic static String[] wrapAll(CharSequence prefix, CharSequence suffix, CharSequence... strs);\npublic static String wrapIfMissing(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String[] wrapAllWithPairIfMissing(CharSequence prefixAndSuffix, CharSequence... strs);\npublic static String[] wrapAllIfMissing(CharSequence prefix, CharSequence suffix, CharSequence... strs);\npublic static String unWrap(CharSequence str, String prefix, String suffix);\npublic static String unWrap(CharSequence str, char prefix, char suffix);\npublic static String unWrap(CharSequence str, char prefixAndSuffix);\npublic static boolean isWrap(CharSequence str, String prefix, String suffix);\npublic static boolean isWrap(CharSequence str, String wrapper);\npublic static boolean isWrap(CharSequence str, char wrapper);\npublic static boolean isWrap(CharSequence str, char prefixChar, char suffixChar);\npublic static String padPre(CharSequence str, int length, CharSequence padStr);\npublic static String padPre(CharSequence str, int length, char padChar);\npublic static String padAfter(CharSequence str, int length, char padChar);\npublic static String padAfter(CharSequence str, int length, CharSequence padStr);\npublic static String center(CharSequence str, final int size);\npublic static String center(CharSequence str, final int size, char padChar);\npublic static String center(CharSequence str, final int size, CharSequence padStr);\npublic static String str(CharSequence cs);\npublic static int count(CharSequence content, CharSequence strForSearch);\npublic static int count(CharSequence content, char charForSearch);\npublic static int compare(final CharSequence str1, final CharSequence str2, final boolean nullIsLess);\npublic static int compareIgnoreCase(CharSequence str1, CharSequence str2, boolean nullIsLess);\npublic static int compareVersion(CharSequence version1, CharSequence version2);\npublic static String appendIfMissing(CharSequence str, CharSequence suffix, CharSequence... suffixes);\npublic static String appendIfMissingIgnoreCase(CharSequence str, CharSequence suffix, CharSequence... suffixes);\npublic static String appendIfMissing(CharSequence str, CharSequence suffix, boolean ignoreCase, CharSequence... testSuffixes);\npublic static String prependIfMissing(CharSequence str, CharSequence prefix, CharSequence... prefixes);\npublic static String prependIfMissingIgnoreCase(CharSequence str, CharSequence prefix, CharSequence... prefixes);\npublic static String prependIfMissing(CharSequence str, CharSequence prefix, boolean ignoreCase, CharSequence... prefixes);\npublic static String replaceIgnoreCase(CharSequence str, CharSequence searchStr, CharSequence replacement);\npublic static String replace(CharSequence str, CharSequence searchStr, CharSequence replacement);\npublic static String replace(CharSequence str, CharSequence searchStr, CharSequence replacement, boolean ignoreCase);\npublic static String replace(CharSequence str, int fromIndex, CharSequence searchStr, CharSequence replacement, boolean ignoreCase);\npublic static String replace(CharSequence str, int startInclude, int endExclude, char replacedChar);\npublic static String replace(CharSequence str, int startInclude, int endExclude, CharSequence replacedStr);\npublic static String replace(CharSequence str, java.util.regex.Pattern pattern, Func1<java.util.regex.Matcher, String> replaceFun);\npublic static String replace(CharSequence str, String regex, Func1<java.util.regex.Matcher, String> replaceFun);\npublic static String replaceLast(CharSequence str, CharSequence searchStr, CharSequence replacedStr);\npublic static String replaceLast(CharSequence str, CharSequence searchStr, CharSequence replacedStr, boolean ignoreCase);\npublic static String replaceFirst(CharSequence str, CharSequence searchStr, CharSequence replacedStr);\npublic static String replaceFirst(CharSequence str, CharSequence searchStr, CharSequence replacedStr, boolean ignoreCase);\npublic static String hide(CharSequence str, int startInclude, int endExclude);\npublic static String desensitized(CharSequence str, DesensitizedUtil.DesensitizedType desensitizedType);\npublic static String replaceChars(CharSequence str, String chars, CharSequence replacedStr);\npublic static String replaceChars(CharSequence str, char[] chars, CharSequence replacedStr);\npublic static int length(CharSequence cs);\npublic static int byteLength(CharSequence cs, Charset charset);\npublic static int totalLength(CharSequence... strs);\npublic static String maxLength(CharSequence string, int length);\npublic static T firstNonNull(T... strs);\npublic static T firstNonEmpty(T... strs);\npublic static T firstNonBlank(T... strs);\npublic static String upperFirstAndAddPre(CharSequence str, String preString);\npublic static String upperFirst(CharSequence str);\npublic static String lowerFirst(CharSequence str);\npublic static String filter(CharSequence str, final Filter<Character> filter);\npublic static boolean isUpperCase(CharSequence str);\npublic static boolean isLowerCase(CharSequence str);\npublic static String swapCase(final String str);\npublic static String toUnderlineCase(CharSequence str);\npublic static String toSymbolCase(CharSequence str, char symbol);\npublic static String toCamelCase(CharSequence name);\npublic static String toCamelCase(CharSequence name, char symbol);\npublic static boolean isSurround(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static boolean isSurround(CharSequence str, char prefix, char suffix);\npublic static StringBuilder builder(CharSequence... strs);\npublic static StrBuilder strBuilder(CharSequence... strs);\npublic static String getGeneralField(CharSequence getOrSetMethodName);\npublic static String genSetter(CharSequence fieldName);\npublic static String genGetter(CharSequence fieldName);\npublic static String concat(boolean isNullToEmpty, CharSequence... strs);\npublic static String brief(CharSequence str, int maxLength);\npublic static String join(CharSequence conjunction, Object... objs);\npublic static String join(CharSequence conjunction, Iterable<T> iterable);\npublic static boolean isAllCharMatch(CharSequence value, Matcher<Character> matcher);\npublic static boolean isNumeric(CharSequence str);\npublic static String move(CharSequence str, int startInclude, int endExclude, int moveLength);\npublic static boolean isCharEquals(CharSequence str);\npublic static String normalize(CharSequence str);\npublic static String fixLength(CharSequence str, char fixedChar, int length);\npublic static boolean hasLetter(CharSequence str);\npublic static CharSequence commonPrefix(CharSequence str1, CharSequence str2);\npublic static CharSequence commonSuffix(CharSequence str1, CharSequence str2);",
        "Class_name": "CharSequenceUtil",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/text/CharSequenceUtil###removePrefixIgnoreCase",
        "Parameter_num": "2",
        "all_Import_statements": "import cn.hutool.core.collection.CollUtil;\n\nimport cn.hutool.core.comparator.VersionComparator;\n\nimport cn.hutool.core.convert.Convert;\n\nimport cn.hutool.core.lang.Assert;\n\nimport cn.hutool.core.lang.Filter;\n\nimport cn.hutool.core.lang.Matcher;\n\nimport cn.hutool.core.lang.func.Func1;\n\nimport cn.hutool.core.text.finder.CharFinder;\n\nimport cn.hutool.core.text.finder.Finder;\n\nimport cn.hutool.core.text.finder.StrFinder;\n\nimport cn.hutool.core.util.ArrayUtil;\n\nimport cn.hutool.core.util.CharUtil;\n\nimport cn.hutool.core.util.CharsetUtil;\n\nimport cn.hutool.core.util.DesensitizedUtil;\n\nimport cn.hutool.core.util.NumberUtil;\n\nimport cn.hutool.core.util.ReUtil;\n\nimport cn.hutool.core.util.StrUtil;\n\nimport java.nio.ByteBuffer;\n\nimport java.nio.charset.Charset;\n\nimport java.text.MessageFormat;\n\nimport java.text.Normalizer;\n\nimport java.util.HashSet;\n\nimport java.util.LinkedList;\n\nimport java.util.List;\n\nimport java.util.Set;\n\nimport java.util.function.Function;\n\nimport java.util.function.Predicate;\n",
        "comment": "\n\t * 忽略大小写去掉指定前缀\n\t *\n\t * @param str    字符串\n\t * @param prefix 前缀\n\t * @return 切掉后的字符串，若前缀不是 prefix， 返回原字符串\n\t ",
        "packageName": "cn.hutool.core.text",
        "method_signature": "public static String removePrefixIgnoreCase(CharSequence str, CharSequence prefix);",
        "Junit_version": "5",
        "returnType": "String"
    },
    {
        "Method_body": "public static Object[] cast(Class<?> type, Object arrayObj) throws NullPointerException, IllegalArgumentException {\n    if (null == arrayObj) {\n        throw new NullPointerException(\"Argument [arrayObj] is null !\");\n    }\n    if (false == arrayObj.getClass().isArray()) {\n        throw new IllegalArgumentException(\"Argument [arrayObj] is not array !\");\n    }\n    if (null == type) {\n        return (Object[]) arrayObj;\n    }\n    final Class<?> componentType = type.isArray() ? type.getComponentType() : type;\n    final Object[] array = (Object[]) arrayObj;\n    final Object[] result = ArrayUtil.newArray(componentType, array.length);\n    System.arraycopy(array, 0, result, 0, array.length);\n    return result;\n}",
        "all_field_declaration": "",
        "sub_project_name": "hutool-core",
        "lineNumbers": "8",
        "Filed": "",
        "Parameter_type": "Class<?>,Object",
        "Import_statements": "import java.lang.reflect.Array;\n",
        "public_method_signature": "public static boolean isEmpty(T[] array);\npublic static T[] defaultIfEmpty(T[] array, T[] defaultArray);\npublic static boolean isEmpty(Object array);\npublic static boolean isNotEmpty(T[] array);\npublic static boolean isNotEmpty(Object array);\npublic static boolean hasNull(T... array);\npublic static boolean isAllNull(T... array);\npublic static T firstNonNull(T... array);\npublic static T firstMatch(Matcher<T> matcher, T... array);\npublic static int matchIndex(Matcher<T> matcher, T... array);\npublic static int matchIndex(Matcher<T> matcher, int beginIndexInclude, T... array);\npublic static T[] newArray(Class<?> componentType, int newSize);\npublic static Object[] newArray(int newSize);\npublic static Class<?> getComponentType(Object array);\npublic static Class<?> getComponentType(Class<?> arrayClass);\npublic static Class<?> getArrayType(Class<?> componentType);\npublic static Object[] cast(Class<?> type, Object arrayObj) throws NullPointerException, IllegalArgumentException;\npublic static T[] append(T[] buffer, T... newElements);\npublic static Object append(Object array, T... newElements);\npublic static T[] setOrAppend(T[] buffer, int index, T value);\npublic static Object setOrAppend(Object array, int index, Object value);\npublic static T[] replace(T[] buffer, int index, T... values);\npublic static T[] insert(T[] buffer, int index, T... newElements);\npublic static Object insert(Object array, int index, T... newElements);\npublic static T[] resize(T[] data, int newSize, Class<?> componentType);\npublic static Object resize(Object array, int newSize);\npublic static T[] resize(T[] buffer, int newSize);\npublic static T[] addAll(T[]... arrays);\npublic static Object copy(Object src, int srcPos, Object dest, int destPos, int length);\npublic static Object copy(Object src, Object dest, int length);\npublic static T[] clone(T[] array);\npublic static T clone(final T obj);\npublic static T[] edit(T[] array, Editor<T> editor);\npublic static T[] filter(T[] array, Filter<T> filter);\npublic static T[] removeNull(T[] array);\npublic static T[] removeEmpty(T[] array);\npublic static T[] removeBlank(T[] array);\npublic static String[] nullToEmpty(String[] array);\npublic static Map<K, V> zip(K[] keys, V[] values, boolean isOrder);\npublic static Map<K, V> zip(K[] keys, V[] values);\npublic static int indexOf(T[] array, Object value, int beginIndexInclude);\npublic static int indexOf(T[] array, Object value);\npublic static int indexOfIgnoreCase(CharSequence[] array, CharSequence value);\npublic static int lastIndexOf(T[] array, Object value);\npublic static int lastIndexOf(T[] array, Object value, int endInclude);\npublic static boolean contains(T[] array, T value);\npublic static boolean containsAny(T[] array, T... values);\npublic static boolean containsAll(T[] array, T... values);\npublic static boolean containsIgnoreCase(CharSequence[] array, CharSequence value);\npublic static Object[] wrap(Object obj);\npublic static boolean isArray(Object obj);\npublic static T get(Object array, int index);\npublic static T[] getAny(Object array, int... indexes);\npublic static T[] sub(T[] array, int start, int end);\npublic static Object[] sub(Object array, int start, int end);\npublic static Object[] sub(Object array, int start, int end, int step);\npublic static String toString(Object obj);\npublic static int length(Object array) throws IllegalArgumentException;\npublic static String join(T[] array, CharSequence conjunction);\npublic static String join(T[] array, CharSequence delimiter, String prefix, String suffix);\npublic static String join(T[] array, CharSequence conjunction, Editor<T> editor);\npublic static String join(Object array, CharSequence conjunction);\npublic static byte[] toArray(ByteBuffer bytebuffer);\npublic static T[] toArray(Iterator<T> iterator, Class<T> componentType);\npublic static T[] toArray(Iterable<T> iterable, Class<T> componentType);\npublic static T[] toArray(Collection<T> collection, Class<T> componentType);\npublic static T[] remove(T[] array, int index) throws IllegalArgumentException;\npublic static T[] removeEle(T[] array, T element) throws IllegalArgumentException;\npublic static T[] reverse(T[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static T[] reverse(T[] array);\npublic static T min(T[] numberArray);\npublic static T min(T[] numberArray, Comparator<T> comparator);\npublic static T max(T[] numberArray);\npublic static T max(T[] numberArray, Comparator<T> comparator);\npublic static T[] shuffle(T[] array);\npublic static T[] shuffle(T[] array, Random random);\npublic static T[] swap(T[] array, int index1, int index2);\npublic static Object swap(Object array, int index1, int index2);\npublic static int emptyCount(Object... args);\npublic static boolean hasEmpty(Object... args);\npublic static boolean isAllEmpty(Object... args);\npublic static boolean isAllNotEmpty(Object... args);\npublic static boolean isAllNotNull(T... array);\npublic static T[] distinct(T[] array);\npublic static T[] distinct(T[] array, Function<T, K> uniqueGenerator, boolean override);\npublic static R[] map(T[] array, Class<R> targetComponentType, Function<? super T, ? extends R> func);\npublic static R[] map(Object array, Class<R> targetComponentType, Function<? super T, ? extends R> func);\npublic static List<R> map(T[] array, Function<? super T, ? extends R> func);\npublic static Set<R> mapToSet(T[] array, Function<? super T, ? extends R> func);\npublic static boolean equals(Object array1, Object array2);\npublic static boolean isSub(T[] array, T[] subArray);\npublic static int indexOfSub(T[] array, T[] subArray);\npublic static int indexOfSub(T[] array, int beginInclude, T[] subArray);\npublic static int lastIndexOfSub(T[] array, T[] subArray);\npublic static int lastIndexOfSub(T[] array, int endInclude, T[] subArray);\npublic static boolean isSorted(T[] array, Comparator<? super T> comparator);\npublic static boolean isSorted(T[] array);\npublic static boolean isSortedASC(T[] array);\npublic static boolean isSortedDESC(T[] array);",
        "public_field": "",
        "Method_statement": "cast(Class<?> type, Object arrayObj)",
        "Method_name": "cast",
        "Class_declaration": "public class ArrayUtil {\n",
        "constructors": "",
        "all_method_signature": "public static boolean isEmpty(T[] array);\npublic static T[] defaultIfEmpty(T[] array, T[] defaultArray);\npublic static boolean isEmpty(Object array);\npublic static boolean isNotEmpty(T[] array);\npublic static boolean isNotEmpty(Object array);\npublic static boolean hasNull(T... array);\npublic static boolean isAllNull(T... array);\npublic static T firstNonNull(T... array);\npublic static T firstMatch(Matcher<T> matcher, T... array);\npublic static int matchIndex(Matcher<T> matcher, T... array);\npublic static int matchIndex(Matcher<T> matcher, int beginIndexInclude, T... array);\npublic static T[] newArray(Class<?> componentType, int newSize);\npublic static Object[] newArray(int newSize);\npublic static Class<?> getComponentType(Object array);\npublic static Class<?> getComponentType(Class<?> arrayClass);\npublic static Class<?> getArrayType(Class<?> componentType);\npublic static Object[] cast(Class<?> type, Object arrayObj) throws NullPointerException, IllegalArgumentException;\npublic static T[] append(T[] buffer, T... newElements);\npublic static Object append(Object array, T... newElements);\npublic static T[] setOrAppend(T[] buffer, int index, T value);\npublic static Object setOrAppend(Object array, int index, Object value);\npublic static T[] replace(T[] buffer, int index, T... values);\npublic static T[] insert(T[] buffer, int index, T... newElements);\npublic static Object insert(Object array, int index, T... newElements);\npublic static T[] resize(T[] data, int newSize, Class<?> componentType);\npublic static Object resize(Object array, int newSize);\npublic static T[] resize(T[] buffer, int newSize);\npublic static T[] addAll(T[]... arrays);\npublic static Object copy(Object src, int srcPos, Object dest, int destPos, int length);\npublic static Object copy(Object src, Object dest, int length);\npublic static T[] clone(T[] array);\npublic static T clone(final T obj);\npublic static T[] edit(T[] array, Editor<T> editor);\npublic static T[] filter(T[] array, Filter<T> filter);\npublic static T[] removeNull(T[] array);\npublic static T[] removeEmpty(T[] array);\npublic static T[] removeBlank(T[] array);\npublic static String[] nullToEmpty(String[] array);\npublic static Map<K, V> zip(K[] keys, V[] values, boolean isOrder);\npublic static Map<K, V> zip(K[] keys, V[] values);\npublic static int indexOf(T[] array, Object value, int beginIndexInclude);\npublic static int indexOf(T[] array, Object value);\npublic static int indexOfIgnoreCase(CharSequence[] array, CharSequence value);\npublic static int lastIndexOf(T[] array, Object value);\npublic static int lastIndexOf(T[] array, Object value, int endInclude);\npublic static boolean contains(T[] array, T value);\npublic static boolean containsAny(T[] array, T... values);\npublic static boolean containsAll(T[] array, T... values);\npublic static boolean containsIgnoreCase(CharSequence[] array, CharSequence value);\npublic static Object[] wrap(Object obj);\npublic static boolean isArray(Object obj);\npublic static T get(Object array, int index);\npublic static T[] getAny(Object array, int... indexes);\npublic static T[] sub(T[] array, int start, int end);\npublic static Object[] sub(Object array, int start, int end);\npublic static Object[] sub(Object array, int start, int end, int step);\npublic static String toString(Object obj);\npublic static int length(Object array) throws IllegalArgumentException;\npublic static String join(T[] array, CharSequence conjunction);\npublic static String join(T[] array, CharSequence delimiter, String prefix, String suffix);\npublic static String join(T[] array, CharSequence conjunction, Editor<T> editor);\npublic static String join(Object array, CharSequence conjunction);\npublic static byte[] toArray(ByteBuffer bytebuffer);\npublic static T[] toArray(Iterator<T> iterator, Class<T> componentType);\npublic static T[] toArray(Iterable<T> iterable, Class<T> componentType);\npublic static T[] toArray(Collection<T> collection, Class<T> componentType);\npublic static T[] remove(T[] array, int index) throws IllegalArgumentException;\npublic static T[] removeEle(T[] array, T element) throws IllegalArgumentException;\npublic static T[] reverse(T[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static T[] reverse(T[] array);\npublic static T min(T[] numberArray);\npublic static T min(T[] numberArray, Comparator<T> comparator);\npublic static T max(T[] numberArray);\npublic static T max(T[] numberArray, Comparator<T> comparator);\npublic static T[] shuffle(T[] array);\npublic static T[] shuffle(T[] array, Random random);\npublic static T[] swap(T[] array, int index1, int index2);\npublic static Object swap(Object array, int index1, int index2);\npublic static int emptyCount(Object... args);\npublic static boolean hasEmpty(Object... args);\npublic static boolean isAllEmpty(Object... args);\npublic static boolean isAllNotEmpty(Object... args);\npublic static boolean isAllNotNull(T... array);\npublic static T[] distinct(T[] array);\npublic static T[] distinct(T[] array, Function<T, K> uniqueGenerator, boolean override);\npublic static R[] map(T[] array, Class<R> targetComponentType, Function<? super T, ? extends R> func);\npublic static R[] map(Object array, Class<R> targetComponentType, Function<? super T, ? extends R> func);\npublic static List<R> map(T[] array, Function<? super T, ? extends R> func);\npublic static Set<R> mapToSet(T[] array, Function<? super T, ? extends R> func);\npublic static boolean equals(Object array1, Object array2);\npublic static boolean isSub(T[] array, T[] subArray);\npublic static int indexOfSub(T[] array, T[] subArray);\npublic static int indexOfSub(T[] array, int beginInclude, T[] subArray);\npublic static int lastIndexOfSub(T[] array, T[] subArray);\npublic static int lastIndexOfSub(T[] array, int endInclude, T[] subArray);\npublic static boolean isSorted(T[] array, Comparator<? super T> comparator);\npublic static boolean isSorted(T[] array);\npublic static boolean isSortedASC(T[] array);\npublic static boolean isSortedDESC(T[] array);",
        "Class_name": "ArrayUtil",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/util/ArrayUtil###cast",
        "Parameter_num": "2",
        "all_Import_statements": "import cn.hutool.core.collection.CollUtil;\n\nimport cn.hutool.core.collection.CollectionUtil;\n\nimport cn.hutool.core.collection.UniqueKeySet;\n\nimport cn.hutool.core.comparator.CompareUtil;\n\nimport cn.hutool.core.convert.Convert;\n\nimport cn.hutool.core.exceptions.UtilException;\n\nimport cn.hutool.core.lang.Assert;\n\nimport cn.hutool.core.lang.Editor;\n\nimport cn.hutool.core.lang.Filter;\n\nimport cn.hutool.core.lang.Matcher;\n\nimport cn.hutool.core.map.MapUtil;\n\nimport cn.hutool.core.text.StrJoiner;\n\nimport java.lang.reflect.Array;\n\nimport java.nio.ByteBuffer;\n\nimport java.util.ArrayList;\n\nimport java.util.Arrays;\n\nimport java.util.Collection;\n\nimport java.util.Collections;\n\nimport java.util.Comparator;\n\nimport java.util.Iterator;\n\nimport java.util.LinkedHashSet;\n\nimport java.util.List;\n\nimport java.util.Map;\n\nimport java.util.Random;\n\nimport java.util.Set;\n\nimport java.util.function.Function;\n\nimport java.util.stream.Collectors;\n",
        "comment": "\n\t * 强转数组类型<br>\n\t * 强制转换的前提是数组元素类型可被强制转换<br>\n\t * 强制转换后会生成一个新数组\n\t *\n\t * @param type     数组类型或数组元素类型\n\t * @param arrayObj 原数组\n\t * @return 转换后的数组类型\n\t * @throws NullPointerException     提供参数为空\n\t * @throws IllegalArgumentException 参数arrayObj不是数组\n\t * @since 3.0.6\n\t ",
        "packageName": "cn.hutool.core.util",
        "method_signature": "public static Object[] cast(Class<?> type, Object arrayObj) throws NullPointerException, IllegalArgumentException;",
        "Junit_version": "5",
        "returnType": "Object[]"
    },
    {
        "Method_body": "public List<String[]> select(int m) {\n    final List<String[]> result = new ArrayList<>((int) count(this.datas.length, m));\n    select(0, new String[m], 0, result);\n    return result;\n}",
        "all_field_declaration": "private static final long serialVersionUID = 1L;\nprivate final String[] datas;",
        "sub_project_name": "hutool-core",
        "lineNumbers": "3",
        "Filed": "private final String[] datas;",
        "Parameter_type": "int",
        "Import_statements": "import java.util.ArrayList;\nimport java.util.List;\n",
        "public_method_signature": "public Combination(String[] datas);\npublic static long count(int n, int m);\npublic static long countAll(int n);\npublic List<String[]> select(int m);\npublic List<String[]> selectAll();",
        "public_field": "",
        "Method_statement": "select(int m)",
        "Method_name": "select",
        "Class_declaration": "public class Combination {\n",
        "constructors": "public Combination(String[] datas) {\n    this.datas = datas;\n}",
        "all_method_signature": "public Combination(String[] datas);\npublic static long count(int n, int m);\npublic static long countAll(int n);\npublic List<String[]> select(int m);\npublic List<String[]> selectAll();\nprivate void select(int dataIndex, String[] resultList, int resultIndex, List<String[]> result);",
        "Class_name": "Combination",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/math/Combination###select",
        "Parameter_num": "1",
        "all_Import_statements": "import java.io.Serializable;\n\nimport java.util.ArrayList;\n\nimport java.util.Arrays;\n\nimport java.util.List;\n\nimport cn.hutool.core.util.NumberUtil;\n\nimport cn.hutool.core.util.StrUtil;\n",
        "comment": "\n\t * 组合选择（从列表中选择m个组合）\n\t *\n\t * @param m 选择个数\n\t * @return 组合结果\n\t ",
        "packageName": "cn.hutool.core.math",
        "method_signature": "public List<String[]> select(int m);",
        "Junit_version": "5",
        "returnType": "List<String[]>"
    },
    {
        "Method_body": "public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeanException {\n    BeanInfo beanInfo;\n    try {\n        beanInfo = Introspector.getBeanInfo(clazz);\n    } catch (IntrospectionException e) {\n        throw new BeanException(e);\n    }\n    return ArrayUtil.filter(beanInfo.getPropertyDescriptors(), t -> {\n        return false == \"class\".equals(t.getName());\n    });\n}",
        "all_field_declaration": "",
        "sub_project_name": "hutool-core",
        "lineNumbers": "3",
        "Filed": "",
        "Parameter_type": "Class<?>",
        "Import_statements": "",
        "public_method_signature": "public static boolean isReadableBean(Class<?> clazz);\npublic static boolean isBean(Class<?> clazz);\npublic static boolean hasSetter(Class<?> clazz);\npublic static boolean hasGetter(Class<?> clazz);\npublic static boolean hasPublicField(Class<?> clazz);\npublic static DynaBean createDynaBean(Object bean);\npublic static PropertyEditor findEditor(Class<?> type);\npublic static BeanDesc getBeanDesc(Class<?> clazz);\npublic static void descForEach(Class<?> clazz, Consumer<? super PropDesc> action);\npublic static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeanException;\npublic static Map<String, PropertyDescriptor> getPropertyDescriptorMap(Class<?> clazz, boolean ignoreCase) throws BeanException;\npublic static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, final String fieldName) throws BeanException;\npublic static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, final String fieldName, boolean ignoreCase) throws BeanException;\npublic static Object getFieldValue(Object bean, String fieldNameOrIndex);\npublic static Object setFieldValue(Object bean, String fieldNameOrIndex, Object value);\npublic static T getProperty(Object bean, String expression);\npublic static void setProperty(Object bean, String expression, Object value);\npublic static T mapToBean(Map<?, ?> map, Class<T> beanClass, boolean isIgnoreError);\npublic static T mapToBeanIgnoreCase(Map<?, ?> map, Class<T> beanClass, boolean isIgnoreError);\npublic static T mapToBean(Map<?, ?> map, Class<T> beanClass, CopyOptions copyOptions);\npublic static T mapToBean(Map<?, ?> map, Class<T> beanClass, boolean isToCamelCase, CopyOptions copyOptions);\npublic static T fillBeanWithMap(Map<?, ?> map, T bean, boolean isIgnoreError);\npublic static T fillBeanWithMap(Map<?, ?> map, T bean, boolean isToCamelCase, boolean isIgnoreError);\npublic static T fillBeanWithMapIgnoreCase(Map<?, ?> map, T bean, boolean isIgnoreError);\npublic static T fillBeanWithMap(Map<?, ?> map, T bean, CopyOptions copyOptions);\npublic static T fillBeanWithMap(Map<?, ?> map, T bean, boolean isToCamelCase, CopyOptions copyOptions);\npublic static T toBean(Object source, Class<T> clazz);\npublic static T toBeanIgnoreError(Object source, Class<T> clazz);\npublic static T toBeanIgnoreCase(Object source, Class<T> clazz, boolean ignoreError);\npublic static T toBean(Object source, Class<T> clazz, CopyOptions options);\npublic static T toBean(Object source, Supplier<T> targetSupplier, CopyOptions options);\npublic static T toBean(Class<T> beanClass, ValueProvider<String> valueProvider, CopyOptions copyOptions);\npublic static T fillBean(T bean, ValueProvider<String> valueProvider, CopyOptions copyOptions);\npublic static Map<String, Object> beanToMap(Object bean, String... properties);\npublic static Map<String, Object> beanToMap(Object bean, boolean isToUnderlineCase, boolean ignoreNullValue);\npublic static Map<String, Object> beanToMap(Object bean, Map<String, Object> targetMap, final boolean isToUnderlineCase, boolean ignoreNullValue);\npublic static Map<String, Object> beanToMap(Object bean, Map<String, Object> targetMap, boolean ignoreNullValue, Editor<String> keyEditor);\npublic static Map<String, Object> beanToMap(Object bean, Map<String, Object> targetMap, CopyOptions copyOptions);\npublic static T copyProperties(Object source, Class<T> tClass, String... ignoreProperties);\npublic static void copyProperties(Object source, Object target, String... ignoreProperties);\npublic static void copyProperties(Object source, Object target, boolean ignoreCase);\npublic static void copyProperties(Object source, Object target, CopyOptions copyOptions);\npublic static List<T> copyToList(Collection<?> collection, Class<T> targetType, CopyOptions copyOptions);\npublic static List<T> copyToList(Collection<?> collection, Class<T> targetType);\npublic static boolean isMatchName(Object bean, String beanClassName, boolean isSimple);\npublic static T edit(T bean, Editor<Field> editor);\npublic static T trimStrFields(T bean, String... ignoreFields);\npublic static boolean isNotEmpty(Object bean, String... ignoreFieldNames);\npublic static boolean isEmpty(Object bean, String... ignoreFieldNames);\npublic static boolean hasNullField(Object bean, String... ignoreFieldNames);\npublic static String getFieldName(String getterOrSetterName);\npublic static boolean isCommonFieldsEqual(Object source, Object target, String... ignoreProperties);",
        "public_field": "",
        "Method_statement": "getPropertyDescriptors(Class<?> clazz)",
        "Method_name": "getPropertyDescriptors",
        "Class_declaration": "public class BeanUtil {\n",
        "constructors": "",
        "all_method_signature": "public static boolean isReadableBean(Class<?> clazz);\npublic static boolean isBean(Class<?> clazz);\npublic static boolean hasSetter(Class<?> clazz);\npublic static boolean hasGetter(Class<?> clazz);\npublic static boolean hasPublicField(Class<?> clazz);\npublic static DynaBean createDynaBean(Object bean);\npublic static PropertyEditor findEditor(Class<?> type);\npublic static BeanDesc getBeanDesc(Class<?> clazz);\npublic static void descForEach(Class<?> clazz, Consumer<? super PropDesc> action);\npublic static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeanException;\npublic static Map<String, PropertyDescriptor> getPropertyDescriptorMap(Class<?> clazz, boolean ignoreCase) throws BeanException;\nprivate static Map<String, PropertyDescriptor> internalGetPropertyDescriptorMap(Class<?> clazz, boolean ignoreCase) throws BeanException;\npublic static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, final String fieldName) throws BeanException;\npublic static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, final String fieldName, boolean ignoreCase) throws BeanException;\npublic static Object getFieldValue(Object bean, String fieldNameOrIndex);\npublic static Object setFieldValue(Object bean, String fieldNameOrIndex, Object value);\npublic static T getProperty(Object bean, String expression);\npublic static void setProperty(Object bean, String expression, Object value);\npublic static T mapToBean(Map<?, ?> map, Class<T> beanClass, boolean isIgnoreError);\npublic static T mapToBeanIgnoreCase(Map<?, ?> map, Class<T> beanClass, boolean isIgnoreError);\npublic static T mapToBean(Map<?, ?> map, Class<T> beanClass, CopyOptions copyOptions);\npublic static T mapToBean(Map<?, ?> map, Class<T> beanClass, boolean isToCamelCase, CopyOptions copyOptions);\npublic static T fillBeanWithMap(Map<?, ?> map, T bean, boolean isIgnoreError);\npublic static T fillBeanWithMap(Map<?, ?> map, T bean, boolean isToCamelCase, boolean isIgnoreError);\npublic static T fillBeanWithMapIgnoreCase(Map<?, ?> map, T bean, boolean isIgnoreError);\npublic static T fillBeanWithMap(Map<?, ?> map, T bean, CopyOptions copyOptions);\npublic static T fillBeanWithMap(Map<?, ?> map, T bean, boolean isToCamelCase, CopyOptions copyOptions);\npublic static T toBean(Object source, Class<T> clazz);\npublic static T toBeanIgnoreError(Object source, Class<T> clazz);\npublic static T toBeanIgnoreCase(Object source, Class<T> clazz, boolean ignoreError);\npublic static T toBean(Object source, Class<T> clazz, CopyOptions options);\npublic static T toBean(Object source, Supplier<T> targetSupplier, CopyOptions options);\npublic static T toBean(Class<T> beanClass, ValueProvider<String> valueProvider, CopyOptions copyOptions);\npublic static T fillBean(T bean, ValueProvider<String> valueProvider, CopyOptions copyOptions);\npublic static Map<String, Object> beanToMap(Object bean, String... properties);\npublic static Map<String, Object> beanToMap(Object bean, boolean isToUnderlineCase, boolean ignoreNullValue);\npublic static Map<String, Object> beanToMap(Object bean, Map<String, Object> targetMap, final boolean isToUnderlineCase, boolean ignoreNullValue);\npublic static Map<String, Object> beanToMap(Object bean, Map<String, Object> targetMap, boolean ignoreNullValue, Editor<String> keyEditor);\npublic static Map<String, Object> beanToMap(Object bean, Map<String, Object> targetMap, CopyOptions copyOptions);\npublic static T copyProperties(Object source, Class<T> tClass, String... ignoreProperties);\npublic static void copyProperties(Object source, Object target, String... ignoreProperties);\npublic static void copyProperties(Object source, Object target, boolean ignoreCase);\npublic static void copyProperties(Object source, Object target, CopyOptions copyOptions);\npublic static List<T> copyToList(Collection<?> collection, Class<T> targetType, CopyOptions copyOptions);\npublic static List<T> copyToList(Collection<?> collection, Class<T> targetType);\npublic static boolean isMatchName(Object bean, String beanClassName, boolean isSimple);\npublic static T edit(T bean, Editor<Field> editor);\npublic static T trimStrFields(T bean, String... ignoreFields);\npublic static boolean isNotEmpty(Object bean, String... ignoreFieldNames);\npublic static boolean isEmpty(Object bean, String... ignoreFieldNames);\npublic static boolean hasNullField(Object bean, String... ignoreFieldNames);\npublic static String getFieldName(String getterOrSetterName);\npublic static boolean isCommonFieldsEqual(Object source, Object target, String... ignoreProperties);",
        "Class_name": "BeanUtil",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/bean/BeanUtil###getPropertyDescriptors",
        "Parameter_num": "1",
        "all_Import_statements": "import cn.hutool.core.bean.copier.BeanCopier;\n\nimport cn.hutool.core.bean.copier.CopyOptions;\n\nimport cn.hutool.core.bean.copier.ValueProvider;\n\nimport cn.hutool.core.collection.CollUtil;\n\nimport cn.hutool.core.collection.ListUtil;\n\nimport cn.hutool.core.convert.Convert;\n\nimport cn.hutool.core.lang.Editor;\n\nimport cn.hutool.core.map.CaseInsensitiveMap;\n\nimport cn.hutool.core.map.MapUtil;\n\nimport cn.hutool.core.util.*;\n\nimport java.beans.*;\n\nimport java.lang.reflect.Field;\n\nimport java.lang.reflect.Method;\n\nimport java.util.*;\n\nimport java.util.function.Consumer;\n\nimport java.util.function.Supplier;\n\nimport java.util.stream.Collectors;\n",
        "comment": "\n\t * 获得Bean字段描述数组\n\t *\n\t * @param clazz Bean类\n\t * @return 字段描述数组\n\t * @throws BeanException 获取属性异常\n\t ",
        "packageName": "cn.hutool.core.bean",
        "method_signature": "public static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeanException;",
        "Junit_version": "5",
        "returnType": "PropertyDescriptor[]"
    },
    {
        "Method_body": "public static String formatChineseDate(Date date, boolean isUppercase, boolean withTime) {\n    if (null == date) {\n        return null;\n    }\n    if (false == isUppercase) {\n        return (withTime ? DatePattern.CHINESE_DATE_TIME_FORMAT : DatePattern.CHINESE_DATE_FORMAT).format(date);\n    }\n    return CalendarUtil.formatChineseDate(CalendarUtil.calendar(date), withTime);\n}",
        "all_field_declaration": "/**\n * java.util.Date EEE MMM zzz 缩写数组\n */\nprivate final static String[] wtb = { // \n// 星期\n\"sun\", // 星期\n\"mon\", // 星期\n\"tue\", // 星期\n\"wed\", // 星期\n\"thu\", // 星期\n\"fri\", // 星期\n\"sat\", // 月份\n\"jan\", // 月份\n\"feb\", // 月份\n\"mar\", // 月份\n\"apr\", // 月份\n\"may\", // 月份\n\"jun\", // 月份\n\"jul\", // 月份\n\"aug\", // 月份\n\"sep\", // 月份\n\"oct\", // 月份\n\"nov\", // 月份\n\"dec\", // 时间标准\n\"gmt\", // 时间标准\n\"ut\", // 时间标准\n\"utc\", // 时间标准\n\"est\", // 时间标准\n\"edt\", // 时间标准\n\"cst\", // 时间标准\n\"cdt\", // 时间标准\n\"mst\", // 时间标准\n\"mdt\", // 时间标准\n\"pst\", // 时间标准\n\"pdt\" };",
        "sub_project_name": "hutool-core",
        "lineNumbers": "3",
        "Filed": "",
        "Parameter_type": "Date,boolean,boolean",
        "Import_statements": "",
        "public_method_signature": "public static DateTime date();\npublic static DateTime dateSecond();\npublic static DateTime date(Date date);\npublic static DateTime dateNew(Date date);\npublic static DateTime date(long date);\npublic static DateTime date(Calendar calendar);\npublic static DateTime date(TemporalAccessor temporalAccessor);\npublic static long current();\npublic static long currentSeconds();\npublic static String now();\npublic static String today();\npublic static int year(Date date);\npublic static int quarter(Date date);\npublic static Quarter quarterEnum(Date date);\npublic static int month(Date date);\npublic static Month monthEnum(Date date);\npublic static int weekOfYear(Date date);\npublic static int weekOfMonth(Date date);\npublic static int dayOfMonth(Date date);\npublic static int dayOfYear(Date date);\npublic static int dayOfWeek(Date date);\npublic static Week dayOfWeekEnum(Date date);\npublic static boolean isWeekend(Date date);\npublic static int hour(Date date, boolean is24HourClock);\npublic static int minute(Date date);\npublic static int second(Date date);\npublic static int millisecond(Date date);\npublic static boolean isAM(Date date);\npublic static boolean isPM(Date date);\npublic static int thisYear();\npublic static int thisMonth();\npublic static Month thisMonthEnum();\npublic static int thisWeekOfYear();\npublic static int thisWeekOfMonth();\npublic static int thisDayOfMonth();\npublic static int thisDayOfWeek();\npublic static Week thisDayOfWeekEnum();\npublic static int thisHour(boolean is24HourClock);\npublic static int thisMinute();\npublic static int thisSecond();\npublic static int thisMillisecond();\npublic static String yearAndQuarter(Date date);\npublic static LinkedHashSet<String> yearAndQuarter(Date startDate, Date endDate);\npublic static String formatLocalDateTime(LocalDateTime localDateTime);\npublic static String format(LocalDateTime localDateTime, String format);\npublic static String format(Date date, String format);\npublic static String format(Date date, DatePrinter format);\npublic static String format(Date date, DateFormat format);\npublic static String format(Date date, DateTimeFormatter format);\npublic static String formatDateTime(Date date);\npublic static String formatDate(Date date);\npublic static String formatTime(Date date);\npublic static String formatHttpDate(Date date);\npublic static String formatChineseDate(Date date, boolean isUppercase, boolean withTime);\npublic static LocalDateTime parseLocalDateTime(CharSequence dateStr);\npublic static LocalDateTime parseLocalDateTime(CharSequence dateStr, String format);\npublic static DateTime parse(CharSequence dateStr, DateFormat dateFormat);\npublic static DateTime parse(CharSequence dateStr, DateParser parser);\npublic static DateTime parse(CharSequence dateStr, DateParser parser, boolean lenient);\npublic static DateTime parse(CharSequence dateStr, DateTimeFormatter formatter);\npublic static DateTime parse(CharSequence dateStr, String format);\npublic static DateTime parse(CharSequence dateStr, String format, Locale locale);\npublic static DateTime parse(String str, String... parsePatterns) throws DateException;\npublic static DateTime parseDateTime(CharSequence dateString);\npublic static DateTime parseDate(CharSequence dateString);\npublic static DateTime parseTime(CharSequence timeString);\npublic static DateTime parseTimeToday(CharSequence timeString);\npublic static DateTime parseUTC(String utcString);\npublic static DateTime parseCST(CharSequence cstString);\npublic static DateTime parse(CharSequence dateCharSequence);\npublic static DateTime truncate(Date date, DateField dateField);\npublic static DateTime round(Date date, DateField dateField);\npublic static DateTime ceiling(Date date, DateField dateField);\npublic static DateTime ceiling(Date date, DateField dateField, boolean truncateMillisecond);\npublic static DateTime beginOfSecond(Date date);\npublic static DateTime endOfSecond(Date date);\npublic static DateTime beginOfHour(Date date);\npublic static DateTime endOfHour(Date date);\npublic static DateTime beginOfMinute(Date date);\npublic static DateTime endOfMinute(Date date);\npublic static DateTime beginOfDay(Date date);\npublic static DateTime endOfDay(Date date);\npublic static DateTime beginOfWeek(Date date);\npublic static DateTime beginOfWeek(Date date, boolean isMondayAsFirstDay);\npublic static DateTime endOfWeek(Date date);\npublic static DateTime endOfWeek(Date date, boolean isSundayAsLastDay);\npublic static DateTime beginOfMonth(Date date);\npublic static DateTime endOfMonth(Date date);\npublic static DateTime beginOfQuarter(Date date);\npublic static DateTime endOfQuarter(Date date);\npublic static DateTime beginOfYear(Date date);\npublic static DateTime endOfYear(Date date);\npublic static DateTime yesterday();\npublic static DateTime tomorrow();\npublic static DateTime lastWeek();\npublic static DateTime nextWeek();\npublic static DateTime lastMonth();\npublic static DateTime nextMonth();\npublic static DateTime offsetMillisecond(Date date, int offset);\npublic static DateTime offsetSecond(Date date, int offset);\npublic static DateTime offsetMinute(Date date, int offset);\npublic static DateTime offsetHour(Date date, int offset);\npublic static DateTime offsetDay(Date date, int offset);\npublic static DateTime offsetWeek(Date date, int offset);\npublic static DateTime offsetMonth(Date date, int offset);\npublic static DateTime offset(Date date, DateField dateField, int offset);\npublic static long between(Date beginDate, Date endDate, DateUnit unit);\npublic static long between(Date beginDate, Date endDate, DateUnit unit, boolean isAbs);\npublic static long betweenMs(Date beginDate, Date endDate);\npublic static long betweenDay(Date beginDate, Date endDate, boolean isReset);\npublic static long betweenWeek(Date beginDate, Date endDate, boolean isReset);\npublic static long betweenMonth(Date beginDate, Date endDate, boolean isReset);\npublic static long betweenYear(Date beginDate, Date endDate, boolean isReset);\npublic static String formatBetween(Date beginDate, Date endDate, BetweenFormatter.Level level);\npublic static String formatBetween(Date beginDate, Date endDate);\npublic static String formatBetween(long betweenMs, BetweenFormatter.Level level);\npublic static String formatBetween(long betweenMs);\npublic static boolean isIn(Date date, Date beginDate, Date endDate);\npublic static boolean isSameTime(Date date1, Date date2);\npublic static boolean isSameDay(final Date date1, final Date date2);\npublic static boolean isSameWeek(final Date date1, final Date date2, boolean isMon);\npublic static boolean isSameMonth(final Date date1, final Date date2);\npublic static long spendNt(long preTime);\npublic static long spendMs(long preTime);\npublic static int toIntSecond(Date date);\npublic static TimeInterval timer();\npublic static TimeInterval timer(boolean isNano);\npublic static StopWatch createStopWatch();\npublic static StopWatch createStopWatch(String id);\npublic static int ageOfNow(String birthDay);\npublic static int ageOfNow(Date birthDay);\npublic static boolean isLeapYear(int year);\npublic static int age(Date birthday, Date dateToCompare);\npublic static boolean isExpired(Date startDate, DateField dateField, int timeLength, Date endDate);\npublic static boolean isExpired(Date startDate, Date endDate, Date checkDate);\npublic static int timeToSecond(String timeStr);\npublic static String secondToTime(int seconds);\npublic static DateRange range(Date start, Date end, final DateField unit);\npublic static List<DateTime> rangeContains(DateRange start, DateRange end);\npublic static List<DateTime> rangeNotContains(DateRange start, DateRange end);\npublic static List<T> rangeFunc(Date start, Date end, final DateField unit, Function<Date, T> func);\npublic static void rangeConsume(Date start, Date end, final DateField unit, Consumer<Date> consumer);\npublic static List<DateTime> rangeToList(Date start, Date end, DateField unit);\npublic static List<DateTime> rangeToList(Date start, Date end, final DateField unit, int step);\npublic static String getZodiac(int month, int day);\npublic static String getChineseZodiac(int year);\npublic static int compare(Date date1, Date date2);\npublic static int compare(Date date1, Date date2, String format);\npublic static long nanosToMillis(long duration);\npublic static double nanosToSeconds(long duration);\npublic static Instant toInstant(Date date);\npublic static Instant toInstant(TemporalAccessor temporalAccessor);\npublic static LocalDateTime toLocalDateTime(Instant instant);\npublic static LocalDateTime toLocalDateTime(Date date);\npublic static DateTime convertTimeZone(Date date, ZoneId zoneId);\npublic static DateTime convertTimeZone(Date date, TimeZone timeZone);\npublic static int lengthOfYear(int year);\npublic static int lengthOfMonth(int month, boolean isLeapYear);\npublic static SimpleDateFormat newSimpleFormat(String pattern);\npublic static SimpleDateFormat newSimpleFormat(String pattern, Locale locale, TimeZone timeZone);\npublic static String getShotName(TimeUnit unit);\npublic static boolean isOverlap(Date realStartTime, Date realEndTime, Date startTime, Date endTime);\npublic static boolean isLastDayOfMonth(Date date);\npublic static int getLastDayOfMonth(Date date);",
        "public_field": "",
        "Method_statement": "formatChineseDate(Date date, boolean isUppercase, boolean withTime)",
        "Method_name": "formatChineseDate",
        "Class_declaration": "public class DateUtil {\n",
        "constructors": "",
        "all_method_signature": "public static DateTime date();\npublic static DateTime dateSecond();\npublic static DateTime date(Date date);\npublic static DateTime dateNew(Date date);\npublic static DateTime date(long date);\npublic static DateTime date(Calendar calendar);\npublic static DateTime date(TemporalAccessor temporalAccessor);\npublic static long current();\npublic static long currentSeconds();\npublic static String now();\npublic static String today();\npublic static int year(Date date);\npublic static int quarter(Date date);\npublic static Quarter quarterEnum(Date date);\npublic static int month(Date date);\npublic static Month monthEnum(Date date);\npublic static int weekOfYear(Date date);\npublic static int weekOfMonth(Date date);\npublic static int dayOfMonth(Date date);\npublic static int dayOfYear(Date date);\npublic static int dayOfWeek(Date date);\npublic static Week dayOfWeekEnum(Date date);\npublic static boolean isWeekend(Date date);\npublic static int hour(Date date, boolean is24HourClock);\npublic static int minute(Date date);\npublic static int second(Date date);\npublic static int millisecond(Date date);\npublic static boolean isAM(Date date);\npublic static boolean isPM(Date date);\npublic static int thisYear();\npublic static int thisMonth();\npublic static Month thisMonthEnum();\npublic static int thisWeekOfYear();\npublic static int thisWeekOfMonth();\npublic static int thisDayOfMonth();\npublic static int thisDayOfWeek();\npublic static Week thisDayOfWeekEnum();\npublic static int thisHour(boolean is24HourClock);\npublic static int thisMinute();\npublic static int thisSecond();\npublic static int thisMillisecond();\npublic static String yearAndQuarter(Date date);\npublic static LinkedHashSet<String> yearAndQuarter(Date startDate, Date endDate);\npublic static String formatLocalDateTime(LocalDateTime localDateTime);\npublic static String format(LocalDateTime localDateTime, String format);\npublic static String format(Date date, String format);\npublic static String format(Date date, DatePrinter format);\npublic static String format(Date date, DateFormat format);\npublic static String format(Date date, DateTimeFormatter format);\npublic static String formatDateTime(Date date);\npublic static String formatDate(Date date);\npublic static String formatTime(Date date);\npublic static String formatHttpDate(Date date);\npublic static String formatChineseDate(Date date, boolean isUppercase, boolean withTime);\npublic static LocalDateTime parseLocalDateTime(CharSequence dateStr);\npublic static LocalDateTime parseLocalDateTime(CharSequence dateStr, String format);\npublic static DateTime parse(CharSequence dateStr, DateFormat dateFormat);\npublic static DateTime parse(CharSequence dateStr, DateParser parser);\npublic static DateTime parse(CharSequence dateStr, DateParser parser, boolean lenient);\npublic static DateTime parse(CharSequence dateStr, DateTimeFormatter formatter);\npublic static DateTime parse(CharSequence dateStr, String format);\npublic static DateTime parse(CharSequence dateStr, String format, Locale locale);\npublic static DateTime parse(String str, String... parsePatterns) throws DateException;\npublic static DateTime parseDateTime(CharSequence dateString);\npublic static DateTime parseDate(CharSequence dateString);\npublic static DateTime parseTime(CharSequence timeString);\npublic static DateTime parseTimeToday(CharSequence timeString);\npublic static DateTime parseUTC(String utcString);\npublic static DateTime parseCST(CharSequence cstString);\npublic static DateTime parse(CharSequence dateCharSequence);\npublic static DateTime truncate(Date date, DateField dateField);\npublic static DateTime round(Date date, DateField dateField);\npublic static DateTime ceiling(Date date, DateField dateField);\npublic static DateTime ceiling(Date date, DateField dateField, boolean truncateMillisecond);\npublic static DateTime beginOfSecond(Date date);\npublic static DateTime endOfSecond(Date date);\npublic static DateTime beginOfHour(Date date);\npublic static DateTime endOfHour(Date date);\npublic static DateTime beginOfMinute(Date date);\npublic static DateTime endOfMinute(Date date);\npublic static DateTime beginOfDay(Date date);\npublic static DateTime endOfDay(Date date);\npublic static DateTime beginOfWeek(Date date);\npublic static DateTime beginOfWeek(Date date, boolean isMondayAsFirstDay);\npublic static DateTime endOfWeek(Date date);\npublic static DateTime endOfWeek(Date date, boolean isSundayAsLastDay);\npublic static DateTime beginOfMonth(Date date);\npublic static DateTime endOfMonth(Date date);\npublic static DateTime beginOfQuarter(Date date);\npublic static DateTime endOfQuarter(Date date);\npublic static DateTime beginOfYear(Date date);\npublic static DateTime endOfYear(Date date);\npublic static DateTime yesterday();\npublic static DateTime tomorrow();\npublic static DateTime lastWeek();\npublic static DateTime nextWeek();\npublic static DateTime lastMonth();\npublic static DateTime nextMonth();\npublic static DateTime offsetMillisecond(Date date, int offset);\npublic static DateTime offsetSecond(Date date, int offset);\npublic static DateTime offsetMinute(Date date, int offset);\npublic static DateTime offsetHour(Date date, int offset);\npublic static DateTime offsetDay(Date date, int offset);\npublic static DateTime offsetWeek(Date date, int offset);\npublic static DateTime offsetMonth(Date date, int offset);\npublic static DateTime offset(Date date, DateField dateField, int offset);\npublic static long between(Date beginDate, Date endDate, DateUnit unit);\npublic static long between(Date beginDate, Date endDate, DateUnit unit, boolean isAbs);\npublic static long betweenMs(Date beginDate, Date endDate);\npublic static long betweenDay(Date beginDate, Date endDate, boolean isReset);\npublic static long betweenWeek(Date beginDate, Date endDate, boolean isReset);\npublic static long betweenMonth(Date beginDate, Date endDate, boolean isReset);\npublic static long betweenYear(Date beginDate, Date endDate, boolean isReset);\npublic static String formatBetween(Date beginDate, Date endDate, BetweenFormatter.Level level);\npublic static String formatBetween(Date beginDate, Date endDate);\npublic static String formatBetween(long betweenMs, BetweenFormatter.Level level);\npublic static String formatBetween(long betweenMs);\npublic static boolean isIn(Date date, Date beginDate, Date endDate);\npublic static boolean isSameTime(Date date1, Date date2);\npublic static boolean isSameDay(final Date date1, final Date date2);\npublic static boolean isSameWeek(final Date date1, final Date date2, boolean isMon);\npublic static boolean isSameMonth(final Date date1, final Date date2);\npublic static long spendNt(long preTime);\npublic static long spendMs(long preTime);\npublic static int toIntSecond(Date date);\npublic static TimeInterval timer();\npublic static TimeInterval timer(boolean isNano);\npublic static StopWatch createStopWatch();\npublic static StopWatch createStopWatch(String id);\npublic static int ageOfNow(String birthDay);\npublic static int ageOfNow(Date birthDay);\npublic static boolean isLeapYear(int year);\npublic static int age(Date birthday, Date dateToCompare);\npublic static boolean isExpired(Date startDate, DateField dateField, int timeLength, Date endDate);\npublic static boolean isExpired(Date startDate, Date endDate, Date checkDate);\npublic static int timeToSecond(String timeStr);\npublic static String secondToTime(int seconds);\npublic static DateRange range(Date start, Date end, final DateField unit);\npublic static List<DateTime> rangeContains(DateRange start, DateRange end);\npublic static List<DateTime> rangeNotContains(DateRange start, DateRange end);\npublic static List<T> rangeFunc(Date start, Date end, final DateField unit, Function<Date, T> func);\npublic static void rangeConsume(Date start, Date end, final DateField unit, Consumer<Date> consumer);\npublic static List<DateTime> rangeToList(Date start, Date end, DateField unit);\npublic static List<DateTime> rangeToList(Date start, Date end, final DateField unit, int step);\npublic static String getZodiac(int month, int day);\npublic static String getChineseZodiac(int year);\npublic static int compare(Date date1, Date date2);\npublic static int compare(Date date1, Date date2, String format);\npublic static long nanosToMillis(long duration);\npublic static double nanosToSeconds(long duration);\npublic static Instant toInstant(Date date);\npublic static Instant toInstant(TemporalAccessor temporalAccessor);\npublic static LocalDateTime toLocalDateTime(Instant instant);\npublic static LocalDateTime toLocalDateTime(Date date);\npublic static DateTime convertTimeZone(Date date, ZoneId zoneId);\npublic static DateTime convertTimeZone(Date date, TimeZone timeZone);\npublic static int lengthOfYear(int year);\npublic static int lengthOfMonth(int month, boolean isLeapYear);\npublic static SimpleDateFormat newSimpleFormat(String pattern);\npublic static SimpleDateFormat newSimpleFormat(String pattern, Locale locale, TimeZone timeZone);\npublic static String getShotName(TimeUnit unit);\npublic static boolean isOverlap(Date realStartTime, Date realEndTime, Date startTime, Date endTime);\npublic static boolean isLastDayOfMonth(Date date);\npublic static int getLastDayOfMonth(Date date);\nprivate static String normalize(CharSequence dateStr);\nprivate static String normalizeMillSeconds(String dateStr, CharSequence before, CharSequence after);",
        "Class_name": "DateUtil",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/date/DateUtil###formatChineseDate",
        "Parameter_num": "3",
        "all_Import_statements": "import cn.hutool.core.collection.CollUtil;\n\nimport cn.hutool.core.comparator.CompareUtil;\n\nimport cn.hutool.core.date.format.DateParser;\n\nimport cn.hutool.core.date.format.DatePrinter;\n\nimport cn.hutool.core.date.format.FastDateFormat;\n\nimport cn.hutool.core.date.format.GlobalCustomFormat;\n\nimport cn.hutool.core.lang.Assert;\n\nimport cn.hutool.core.lang.PatternPool;\n\nimport cn.hutool.core.util.CharUtil;\n\nimport cn.hutool.core.util.NumberUtil;\n\nimport cn.hutool.core.util.ReUtil;\n\nimport cn.hutool.core.util.StrUtil;\n\nimport java.text.DateFormat;\n\nimport java.text.SimpleDateFormat;\n\nimport java.time.Instant;\n\nimport java.time.LocalDateTime;\n\nimport java.time.Year;\n\nimport java.time.ZoneId;\n\nimport java.time.format.DateTimeFormatter;\n\nimport java.time.temporal.TemporalAccessor;\n\nimport java.util.*;\n\nimport java.util.concurrent.TimeUnit;\n\nimport java.util.function.Consumer;\n\nimport java.util.function.Function;\n\nimport java.util.stream.Collectors;\n",
        "comment": "\n\t * 格式化为中文日期格式，如果isUppercase为false，则返回类似：2018年10月24日，否则返回二〇一八年十月二十四日\n\t *\n\t * @param date        被格式化的日期\n\t * @param isUppercase 是否采用大写形式\n\t * @param withTime    是否包含时间部分\n\t * @return 中文日期字符串\n\t * @since 5.3.9\n\t ",
        "packageName": "cn.hutool.core.date",
        "method_signature": "public static String formatChineseDate(Date date, boolean isUppercase, boolean withTime);",
        "Junit_version": "5",
        "returnType": "String"
    },
    {
        "Method_body": "@SuppressWarnings(\"unchecked\")\npublic static <T> T[] distinct(T[] array) {\n    if (isEmpty(array)) {\n        return array;\n    }\n    final Set<T> set = new LinkedHashSet<>(array.length, 1);\n    Collections.addAll(set, array);\n    return toArray(set, (Class<T>) getComponentType(array));\n}",
        "all_field_declaration": "",
        "sub_project_name": "hutool-core",
        "lineNumbers": "4",
        "Filed": "",
        "Parameter_type": "T[]",
        "Import_statements": "import java.lang.reflect.Array;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\n",
        "public_method_signature": "public static boolean isEmpty(T[] array);\npublic static T[] defaultIfEmpty(T[] array, T[] defaultArray);\npublic static boolean isEmpty(Object array);\npublic static boolean isNotEmpty(T[] array);\npublic static boolean isNotEmpty(Object array);\npublic static boolean hasNull(T... array);\npublic static boolean isAllNull(T... array);\npublic static T firstNonNull(T... array);\npublic static T firstMatch(Matcher<T> matcher, T... array);\npublic static int matchIndex(Matcher<T> matcher, T... array);\npublic static int matchIndex(Matcher<T> matcher, int beginIndexInclude, T... array);\npublic static T[] newArray(Class<?> componentType, int newSize);\npublic static Object[] newArray(int newSize);\npublic static Class<?> getComponentType(Object array);\npublic static Class<?> getComponentType(Class<?> arrayClass);\npublic static Class<?> getArrayType(Class<?> componentType);\npublic static Object[] cast(Class<?> type, Object arrayObj) throws NullPointerException, IllegalArgumentException;\npublic static T[] append(T[] buffer, T... newElements);\npublic static Object append(Object array, T... newElements);\npublic static T[] setOrAppend(T[] buffer, int index, T value);\npublic static Object setOrAppend(Object array, int index, Object value);\npublic static T[] replace(T[] buffer, int index, T... values);\npublic static T[] insert(T[] buffer, int index, T... newElements);\npublic static Object insert(Object array, int index, T... newElements);\npublic static T[] resize(T[] data, int newSize, Class<?> componentType);\npublic static Object resize(Object array, int newSize);\npublic static T[] resize(T[] buffer, int newSize);\npublic static T[] addAll(T[]... arrays);\npublic static Object copy(Object src, int srcPos, Object dest, int destPos, int length);\npublic static Object copy(Object src, Object dest, int length);\npublic static T[] clone(T[] array);\npublic static T clone(final T obj);\npublic static T[] edit(T[] array, Editor<T> editor);\npublic static T[] filter(T[] array, Filter<T> filter);\npublic static T[] removeNull(T[] array);\npublic static T[] removeEmpty(T[] array);\npublic static T[] removeBlank(T[] array);\npublic static String[] nullToEmpty(String[] array);\npublic static Map<K, V> zip(K[] keys, V[] values, boolean isOrder);\npublic static Map<K, V> zip(K[] keys, V[] values);\npublic static int indexOf(T[] array, Object value, int beginIndexInclude);\npublic static int indexOf(T[] array, Object value);\npublic static int indexOfIgnoreCase(CharSequence[] array, CharSequence value);\npublic static int lastIndexOf(T[] array, Object value);\npublic static int lastIndexOf(T[] array, Object value, int endInclude);\npublic static boolean contains(T[] array, T value);\npublic static boolean containsAny(T[] array, T... values);\npublic static boolean containsAll(T[] array, T... values);\npublic static boolean containsIgnoreCase(CharSequence[] array, CharSequence value);\npublic static Object[] wrap(Object obj);\npublic static boolean isArray(Object obj);\npublic static T get(Object array, int index);\npublic static T[] getAny(Object array, int... indexes);\npublic static T[] sub(T[] array, int start, int end);\npublic static Object[] sub(Object array, int start, int end);\npublic static Object[] sub(Object array, int start, int end, int step);\npublic static String toString(Object obj);\npublic static int length(Object array) throws IllegalArgumentException;\npublic static String join(T[] array, CharSequence conjunction);\npublic static String join(T[] array, CharSequence delimiter, String prefix, String suffix);\npublic static String join(T[] array, CharSequence conjunction, Editor<T> editor);\npublic static String join(Object array, CharSequence conjunction);\npublic static byte[] toArray(ByteBuffer bytebuffer);\npublic static T[] toArray(Iterator<T> iterator, Class<T> componentType);\npublic static T[] toArray(Iterable<T> iterable, Class<T> componentType);\npublic static T[] toArray(Collection<T> collection, Class<T> componentType);\npublic static T[] remove(T[] array, int index) throws IllegalArgumentException;\npublic static T[] removeEle(T[] array, T element) throws IllegalArgumentException;\npublic static T[] reverse(T[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static T[] reverse(T[] array);\npublic static T min(T[] numberArray);\npublic static T min(T[] numberArray, Comparator<T> comparator);\npublic static T max(T[] numberArray);\npublic static T max(T[] numberArray, Comparator<T> comparator);\npublic static T[] shuffle(T[] array);\npublic static T[] shuffle(T[] array, Random random);\npublic static T[] swap(T[] array, int index1, int index2);\npublic static Object swap(Object array, int index1, int index2);\npublic static int emptyCount(Object... args);\npublic static boolean hasEmpty(Object... args);\npublic static boolean isAllEmpty(Object... args);\npublic static boolean isAllNotEmpty(Object... args);\npublic static boolean isAllNotNull(T... array);\npublic static T[] distinct(T[] array);\npublic static T[] distinct(T[] array, Function<T, K> uniqueGenerator, boolean override);\npublic static R[] map(T[] array, Class<R> targetComponentType, Function<? super T, ? extends R> func);\npublic static R[] map(Object array, Class<R> targetComponentType, Function<? super T, ? extends R> func);\npublic static List<R> map(T[] array, Function<? super T, ? extends R> func);\npublic static Set<R> mapToSet(T[] array, Function<? super T, ? extends R> func);\npublic static boolean equals(Object array1, Object array2);\npublic static boolean isSub(T[] array, T[] subArray);\npublic static int indexOfSub(T[] array, T[] subArray);\npublic static int indexOfSub(T[] array, int beginInclude, T[] subArray);\npublic static int lastIndexOfSub(T[] array, T[] subArray);\npublic static int lastIndexOfSub(T[] array, int endInclude, T[] subArray);\npublic static boolean isSorted(T[] array, Comparator<? super T> comparator);\npublic static boolean isSorted(T[] array);\npublic static boolean isSortedASC(T[] array);\npublic static boolean isSortedDESC(T[] array);",
        "public_field": "",
        "Method_statement": "distinct(T() array)",
        "Method_name": "distinct",
        "Class_declaration": "public class ArrayUtil {\n",
        "constructors": "",
        "all_method_signature": "public static boolean isEmpty(T[] array);\npublic static T[] defaultIfEmpty(T[] array, T[] defaultArray);\npublic static boolean isEmpty(Object array);\npublic static boolean isNotEmpty(T[] array);\npublic static boolean isNotEmpty(Object array);\npublic static boolean hasNull(T... array);\npublic static boolean isAllNull(T... array);\npublic static T firstNonNull(T... array);\npublic static T firstMatch(Matcher<T> matcher, T... array);\npublic static int matchIndex(Matcher<T> matcher, T... array);\npublic static int matchIndex(Matcher<T> matcher, int beginIndexInclude, T... array);\npublic static T[] newArray(Class<?> componentType, int newSize);\npublic static Object[] newArray(int newSize);\npublic static Class<?> getComponentType(Object array);\npublic static Class<?> getComponentType(Class<?> arrayClass);\npublic static Class<?> getArrayType(Class<?> componentType);\npublic static Object[] cast(Class<?> type, Object arrayObj) throws NullPointerException, IllegalArgumentException;\npublic static T[] append(T[] buffer, T... newElements);\npublic static Object append(Object array, T... newElements);\npublic static T[] setOrAppend(T[] buffer, int index, T value);\npublic static Object setOrAppend(Object array, int index, Object value);\npublic static T[] replace(T[] buffer, int index, T... values);\npublic static T[] insert(T[] buffer, int index, T... newElements);\npublic static Object insert(Object array, int index, T... newElements);\npublic static T[] resize(T[] data, int newSize, Class<?> componentType);\npublic static Object resize(Object array, int newSize);\npublic static T[] resize(T[] buffer, int newSize);\npublic static T[] addAll(T[]... arrays);\npublic static Object copy(Object src, int srcPos, Object dest, int destPos, int length);\npublic static Object copy(Object src, Object dest, int length);\npublic static T[] clone(T[] array);\npublic static T clone(final T obj);\npublic static T[] edit(T[] array, Editor<T> editor);\npublic static T[] filter(T[] array, Filter<T> filter);\npublic static T[] removeNull(T[] array);\npublic static T[] removeEmpty(T[] array);\npublic static T[] removeBlank(T[] array);\npublic static String[] nullToEmpty(String[] array);\npublic static Map<K, V> zip(K[] keys, V[] values, boolean isOrder);\npublic static Map<K, V> zip(K[] keys, V[] values);\npublic static int indexOf(T[] array, Object value, int beginIndexInclude);\npublic static int indexOf(T[] array, Object value);\npublic static int indexOfIgnoreCase(CharSequence[] array, CharSequence value);\npublic static int lastIndexOf(T[] array, Object value);\npublic static int lastIndexOf(T[] array, Object value, int endInclude);\npublic static boolean contains(T[] array, T value);\npublic static boolean containsAny(T[] array, T... values);\npublic static boolean containsAll(T[] array, T... values);\npublic static boolean containsIgnoreCase(CharSequence[] array, CharSequence value);\npublic static Object[] wrap(Object obj);\npublic static boolean isArray(Object obj);\npublic static T get(Object array, int index);\npublic static T[] getAny(Object array, int... indexes);\npublic static T[] sub(T[] array, int start, int end);\npublic static Object[] sub(Object array, int start, int end);\npublic static Object[] sub(Object array, int start, int end, int step);\npublic static String toString(Object obj);\npublic static int length(Object array) throws IllegalArgumentException;\npublic static String join(T[] array, CharSequence conjunction);\npublic static String join(T[] array, CharSequence delimiter, String prefix, String suffix);\npublic static String join(T[] array, CharSequence conjunction, Editor<T> editor);\npublic static String join(Object array, CharSequence conjunction);\npublic static byte[] toArray(ByteBuffer bytebuffer);\npublic static T[] toArray(Iterator<T> iterator, Class<T> componentType);\npublic static T[] toArray(Iterable<T> iterable, Class<T> componentType);\npublic static T[] toArray(Collection<T> collection, Class<T> componentType);\npublic static T[] remove(T[] array, int index) throws IllegalArgumentException;\npublic static T[] removeEle(T[] array, T element) throws IllegalArgumentException;\npublic static T[] reverse(T[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static T[] reverse(T[] array);\npublic static T min(T[] numberArray);\npublic static T min(T[] numberArray, Comparator<T> comparator);\npublic static T max(T[] numberArray);\npublic static T max(T[] numberArray, Comparator<T> comparator);\npublic static T[] shuffle(T[] array);\npublic static T[] shuffle(T[] array, Random random);\npublic static T[] swap(T[] array, int index1, int index2);\npublic static Object swap(Object array, int index1, int index2);\npublic static int emptyCount(Object... args);\npublic static boolean hasEmpty(Object... args);\npublic static boolean isAllEmpty(Object... args);\npublic static boolean isAllNotEmpty(Object... args);\npublic static boolean isAllNotNull(T... array);\npublic static T[] distinct(T[] array);\npublic static T[] distinct(T[] array, Function<T, K> uniqueGenerator, boolean override);\npublic static R[] map(T[] array, Class<R> targetComponentType, Function<? super T, ? extends R> func);\npublic static R[] map(Object array, Class<R> targetComponentType, Function<? super T, ? extends R> func);\npublic static List<R> map(T[] array, Function<? super T, ? extends R> func);\npublic static Set<R> mapToSet(T[] array, Function<? super T, ? extends R> func);\npublic static boolean equals(Object array1, Object array2);\npublic static boolean isSub(T[] array, T[] subArray);\npublic static int indexOfSub(T[] array, T[] subArray);\npublic static int indexOfSub(T[] array, int beginInclude, T[] subArray);\npublic static int lastIndexOfSub(T[] array, T[] subArray);\npublic static int lastIndexOfSub(T[] array, int endInclude, T[] subArray);\npublic static boolean isSorted(T[] array, Comparator<? super T> comparator);\npublic static boolean isSorted(T[] array);\npublic static boolean isSortedASC(T[] array);\npublic static boolean isSortedDESC(T[] array);",
        "Class_name": "ArrayUtil",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/util/ArrayUtil###distinct",
        "Parameter_num": "1",
        "all_Import_statements": "import cn.hutool.core.collection.CollUtil;\n\nimport cn.hutool.core.collection.CollectionUtil;\n\nimport cn.hutool.core.collection.UniqueKeySet;\n\nimport cn.hutool.core.comparator.CompareUtil;\n\nimport cn.hutool.core.convert.Convert;\n\nimport cn.hutool.core.exceptions.UtilException;\n\nimport cn.hutool.core.lang.Assert;\n\nimport cn.hutool.core.lang.Editor;\n\nimport cn.hutool.core.lang.Filter;\n\nimport cn.hutool.core.lang.Matcher;\n\nimport cn.hutool.core.map.MapUtil;\n\nimport cn.hutool.core.text.StrJoiner;\n\nimport java.lang.reflect.Array;\n\nimport java.nio.ByteBuffer;\n\nimport java.util.ArrayList;\n\nimport java.util.Arrays;\n\nimport java.util.Collection;\n\nimport java.util.Collections;\n\nimport java.util.Comparator;\n\nimport java.util.Iterator;\n\nimport java.util.LinkedHashSet;\n\nimport java.util.List;\n\nimport java.util.Map;\n\nimport java.util.Random;\n\nimport java.util.Set;\n\nimport java.util.function.Function;\n\nimport java.util.stream.Collectors;\n",
        "comment": "\n\t * 去重数组中的元素，去重后生成新的数组，原数组不变<br>\n\t * 此方法通过{@link LinkedHashSet} 去重\n\t *\n\t * @param <T>   数组元素类型\n\t * @param array 数组\n\t * @return 去重后的数组\n\t ",
        "packageName": "cn.hutool.core.util",
        "method_signature": "public static T[] distinct(T[] array);",
        "Junit_version": "5",
        "returnType": "T[]"
    },
    {
        "Method_body": "public static String getCallerMethodName(boolean isFullName) {\n    final StackTraceElement stackTraceElement = Thread.currentThread().getStackTrace()[2];\n    final String methodName = stackTraceElement.getMethodName();\n    if (false == isFullName) {\n        return methodName;\n    }\n    return stackTraceElement.getClassName() + \".\" + methodName;\n}",
        "all_field_declaration": "private static final Caller INSTANCE;",
        "sub_project_name": "hutool-core",
        "lineNumbers": "4",
        "Filed": "",
        "Parameter_type": "boolean",
        "Import_statements": "",
        "public_method_signature": "public static Class<?> getCaller();\npublic static Class<?> getCallerCaller();\npublic static Class<?> getCaller(int depth);\npublic static boolean isCalledBy(Class<?> clazz);\npublic static String getCallerMethodName(boolean isFullName);",
        "public_field": "",
        "Method_statement": "getCallerMethodName(boolean isFullName)",
        "Method_name": "getCallerMethodName",
        "Class_declaration": "public class CallerUtil {\n",
        "constructors": "",
        "all_method_signature": "public static Class<?> getCaller();\npublic static Class<?> getCallerCaller();\npublic static Class<?> getCaller(int depth);\npublic static boolean isCalledBy(Class<?> clazz);\npublic static String getCallerMethodName(boolean isFullName);\nprivate static Caller tryCreateCaller();",
        "Class_name": "CallerUtil",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/lang/caller/CallerUtil###getCallerMethodName",
        "Parameter_num": "1",
        "all_Import_statements": "",
        "comment": "\n\t * 获取调用此方法的方法名\n\t *\n\t * @param isFullName 是否返回全名，全名包括方法所在类的全路径名\n\t * @return 调用此方法的方法名\n\t * @since 5.2.4\n\t ",
        "packageName": "cn.hutool.core.lang.caller",
        "method_signature": "public static String getCallerMethodName(boolean isFullName);",
        "Junit_version": "5",
        "returnType": "String"
    },
    {
        "Method_body": "@SuppressWarnings({ \"unchecked\" })\npublic static <T> T[] replace(T[] buffer, int index, T... values) {\n    if (isEmpty(values)) {\n        return buffer;\n    }\n    if (isEmpty(buffer)) {\n        return values;\n    }\n    if (index < 0) {\n        return insert(buffer, 0, values);\n    }\n    if (index >= buffer.length) {\n        return append(buffer, values);\n    }\n    if (buffer.length >= values.length + index) {\n        System.arraycopy(values, 0, buffer, index, values.length);\n        return buffer;\n    }\n    int newArrayLength = index + values.length;\n    final T[] result = newArray(buffer.getClass().getComponentType(), newArrayLength);\n    System.arraycopy(buffer, 0, result, 0, index);\n    System.arraycopy(values, 0, result, index, values.length);\n    return result;\n}",
        "all_field_declaration": "",
        "sub_project_name": "hutool-core",
        "lineNumbers": "10",
        "Filed": "",
        "Parameter_type": "T[],int,T",
        "Import_statements": "import java.lang.reflect.Array;\n",
        "public_method_signature": "public static boolean isEmpty(T[] array);\npublic static T[] defaultIfEmpty(T[] array, T[] defaultArray);\npublic static boolean isEmpty(Object array);\npublic static boolean isNotEmpty(T[] array);\npublic static boolean isNotEmpty(Object array);\npublic static boolean hasNull(T... array);\npublic static boolean isAllNull(T... array);\npublic static T firstNonNull(T... array);\npublic static T firstMatch(Matcher<T> matcher, T... array);\npublic static int matchIndex(Matcher<T> matcher, T... array);\npublic static int matchIndex(Matcher<T> matcher, int beginIndexInclude, T... array);\npublic static T[] newArray(Class<?> componentType, int newSize);\npublic static Object[] newArray(int newSize);\npublic static Class<?> getComponentType(Object array);\npublic static Class<?> getComponentType(Class<?> arrayClass);\npublic static Class<?> getArrayType(Class<?> componentType);\npublic static Object[] cast(Class<?> type, Object arrayObj) throws NullPointerException, IllegalArgumentException;\npublic static T[] append(T[] buffer, T... newElements);\npublic static Object append(Object array, T... newElements);\npublic static T[] setOrAppend(T[] buffer, int index, T value);\npublic static Object setOrAppend(Object array, int index, Object value);\npublic static T[] replace(T[] buffer, int index, T... values);\npublic static T[] insert(T[] buffer, int index, T... newElements);\npublic static Object insert(Object array, int index, T... newElements);\npublic static T[] resize(T[] data, int newSize, Class<?> componentType);\npublic static Object resize(Object array, int newSize);\npublic static T[] resize(T[] buffer, int newSize);\npublic static T[] addAll(T[]... arrays);\npublic static Object copy(Object src, int srcPos, Object dest, int destPos, int length);\npublic static Object copy(Object src, Object dest, int length);\npublic static T[] clone(T[] array);\npublic static T clone(final T obj);\npublic static T[] edit(T[] array, Editor<T> editor);\npublic static T[] filter(T[] array, Filter<T> filter);\npublic static T[] removeNull(T[] array);\npublic static T[] removeEmpty(T[] array);\npublic static T[] removeBlank(T[] array);\npublic static String[] nullToEmpty(String[] array);\npublic static Map<K, V> zip(K[] keys, V[] values, boolean isOrder);\npublic static Map<K, V> zip(K[] keys, V[] values);\npublic static int indexOf(T[] array, Object value, int beginIndexInclude);\npublic static int indexOf(T[] array, Object value);\npublic static int indexOfIgnoreCase(CharSequence[] array, CharSequence value);\npublic static int lastIndexOf(T[] array, Object value);\npublic static int lastIndexOf(T[] array, Object value, int endInclude);\npublic static boolean contains(T[] array, T value);\npublic static boolean containsAny(T[] array, T... values);\npublic static boolean containsAll(T[] array, T... values);\npublic static boolean containsIgnoreCase(CharSequence[] array, CharSequence value);\npublic static Object[] wrap(Object obj);\npublic static boolean isArray(Object obj);\npublic static T get(Object array, int index);\npublic static T[] getAny(Object array, int... indexes);\npublic static T[] sub(T[] array, int start, int end);\npublic static Object[] sub(Object array, int start, int end);\npublic static Object[] sub(Object array, int start, int end, int step);\npublic static String toString(Object obj);\npublic static int length(Object array) throws IllegalArgumentException;\npublic static String join(T[] array, CharSequence conjunction);\npublic static String join(T[] array, CharSequence delimiter, String prefix, String suffix);\npublic static String join(T[] array, CharSequence conjunction, Editor<T> editor);\npublic static String join(Object array, CharSequence conjunction);\npublic static byte[] toArray(ByteBuffer bytebuffer);\npublic static T[] toArray(Iterator<T> iterator, Class<T> componentType);\npublic static T[] toArray(Iterable<T> iterable, Class<T> componentType);\npublic static T[] toArray(Collection<T> collection, Class<T> componentType);\npublic static T[] remove(T[] array, int index) throws IllegalArgumentException;\npublic static T[] removeEle(T[] array, T element) throws IllegalArgumentException;\npublic static T[] reverse(T[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static T[] reverse(T[] array);\npublic static T min(T[] numberArray);\npublic static T min(T[] numberArray, Comparator<T> comparator);\npublic static T max(T[] numberArray);\npublic static T max(T[] numberArray, Comparator<T> comparator);\npublic static T[] shuffle(T[] array);\npublic static T[] shuffle(T[] array, Random random);\npublic static T[] swap(T[] array, int index1, int index2);\npublic static Object swap(Object array, int index1, int index2);\npublic static int emptyCount(Object... args);\npublic static boolean hasEmpty(Object... args);\npublic static boolean isAllEmpty(Object... args);\npublic static boolean isAllNotEmpty(Object... args);\npublic static boolean isAllNotNull(T... array);\npublic static T[] distinct(T[] array);\npublic static T[] distinct(T[] array, Function<T, K> uniqueGenerator, boolean override);\npublic static R[] map(T[] array, Class<R> targetComponentType, Function<? super T, ? extends R> func);\npublic static R[] map(Object array, Class<R> targetComponentType, Function<? super T, ? extends R> func);\npublic static List<R> map(T[] array, Function<? super T, ? extends R> func);\npublic static Set<R> mapToSet(T[] array, Function<? super T, ? extends R> func);\npublic static boolean equals(Object array1, Object array2);\npublic static boolean isSub(T[] array, T[] subArray);\npublic static int indexOfSub(T[] array, T[] subArray);\npublic static int indexOfSub(T[] array, int beginInclude, T[] subArray);\npublic static int lastIndexOfSub(T[] array, T[] subArray);\npublic static int lastIndexOfSub(T[] array, int endInclude, T[] subArray);\npublic static boolean isSorted(T[] array, Comparator<? super T> comparator);\npublic static boolean isSorted(T[] array);\npublic static boolean isSortedASC(T[] array);\npublic static boolean isSortedDESC(T[] array);",
        "public_field": "",
        "Method_statement": "replace(T() buffer, int index, T... values)",
        "Method_name": "replace",
        "Class_declaration": "public class ArrayUtil {\n",
        "constructors": "",
        "all_method_signature": "public static boolean isEmpty(T[] array);\npublic static T[] defaultIfEmpty(T[] array, T[] defaultArray);\npublic static boolean isEmpty(Object array);\npublic static boolean isNotEmpty(T[] array);\npublic static boolean isNotEmpty(Object array);\npublic static boolean hasNull(T... array);\npublic static boolean isAllNull(T... array);\npublic static T firstNonNull(T... array);\npublic static T firstMatch(Matcher<T> matcher, T... array);\npublic static int matchIndex(Matcher<T> matcher, T... array);\npublic static int matchIndex(Matcher<T> matcher, int beginIndexInclude, T... array);\npublic static T[] newArray(Class<?> componentType, int newSize);\npublic static Object[] newArray(int newSize);\npublic static Class<?> getComponentType(Object array);\npublic static Class<?> getComponentType(Class<?> arrayClass);\npublic static Class<?> getArrayType(Class<?> componentType);\npublic static Object[] cast(Class<?> type, Object arrayObj) throws NullPointerException, IllegalArgumentException;\npublic static T[] append(T[] buffer, T... newElements);\npublic static Object append(Object array, T... newElements);\npublic static T[] setOrAppend(T[] buffer, int index, T value);\npublic static Object setOrAppend(Object array, int index, Object value);\npublic static T[] replace(T[] buffer, int index, T... values);\npublic static T[] insert(T[] buffer, int index, T... newElements);\npublic static Object insert(Object array, int index, T... newElements);\npublic static T[] resize(T[] data, int newSize, Class<?> componentType);\npublic static Object resize(Object array, int newSize);\npublic static T[] resize(T[] buffer, int newSize);\npublic static T[] addAll(T[]... arrays);\npublic static Object copy(Object src, int srcPos, Object dest, int destPos, int length);\npublic static Object copy(Object src, Object dest, int length);\npublic static T[] clone(T[] array);\npublic static T clone(final T obj);\npublic static T[] edit(T[] array, Editor<T> editor);\npublic static T[] filter(T[] array, Filter<T> filter);\npublic static T[] removeNull(T[] array);\npublic static T[] removeEmpty(T[] array);\npublic static T[] removeBlank(T[] array);\npublic static String[] nullToEmpty(String[] array);\npublic static Map<K, V> zip(K[] keys, V[] values, boolean isOrder);\npublic static Map<K, V> zip(K[] keys, V[] values);\npublic static int indexOf(T[] array, Object value, int beginIndexInclude);\npublic static int indexOf(T[] array, Object value);\npublic static int indexOfIgnoreCase(CharSequence[] array, CharSequence value);\npublic static int lastIndexOf(T[] array, Object value);\npublic static int lastIndexOf(T[] array, Object value, int endInclude);\npublic static boolean contains(T[] array, T value);\npublic static boolean containsAny(T[] array, T... values);\npublic static boolean containsAll(T[] array, T... values);\npublic static boolean containsIgnoreCase(CharSequence[] array, CharSequence value);\npublic static Object[] wrap(Object obj);\npublic static boolean isArray(Object obj);\npublic static T get(Object array, int index);\npublic static T[] getAny(Object array, int... indexes);\npublic static T[] sub(T[] array, int start, int end);\npublic static Object[] sub(Object array, int start, int end);\npublic static Object[] sub(Object array, int start, int end, int step);\npublic static String toString(Object obj);\npublic static int length(Object array) throws IllegalArgumentException;\npublic static String join(T[] array, CharSequence conjunction);\npublic static String join(T[] array, CharSequence delimiter, String prefix, String suffix);\npublic static String join(T[] array, CharSequence conjunction, Editor<T> editor);\npublic static String join(Object array, CharSequence conjunction);\npublic static byte[] toArray(ByteBuffer bytebuffer);\npublic static T[] toArray(Iterator<T> iterator, Class<T> componentType);\npublic static T[] toArray(Iterable<T> iterable, Class<T> componentType);\npublic static T[] toArray(Collection<T> collection, Class<T> componentType);\npublic static T[] remove(T[] array, int index) throws IllegalArgumentException;\npublic static T[] removeEle(T[] array, T element) throws IllegalArgumentException;\npublic static T[] reverse(T[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static T[] reverse(T[] array);\npublic static T min(T[] numberArray);\npublic static T min(T[] numberArray, Comparator<T> comparator);\npublic static T max(T[] numberArray);\npublic static T max(T[] numberArray, Comparator<T> comparator);\npublic static T[] shuffle(T[] array);\npublic static T[] shuffle(T[] array, Random random);\npublic static T[] swap(T[] array, int index1, int index2);\npublic static Object swap(Object array, int index1, int index2);\npublic static int emptyCount(Object... args);\npublic static boolean hasEmpty(Object... args);\npublic static boolean isAllEmpty(Object... args);\npublic static boolean isAllNotEmpty(Object... args);\npublic static boolean isAllNotNull(T... array);\npublic static T[] distinct(T[] array);\npublic static T[] distinct(T[] array, Function<T, K> uniqueGenerator, boolean override);\npublic static R[] map(T[] array, Class<R> targetComponentType, Function<? super T, ? extends R> func);\npublic static R[] map(Object array, Class<R> targetComponentType, Function<? super T, ? extends R> func);\npublic static List<R> map(T[] array, Function<? super T, ? extends R> func);\npublic static Set<R> mapToSet(T[] array, Function<? super T, ? extends R> func);\npublic static boolean equals(Object array1, Object array2);\npublic static boolean isSub(T[] array, T[] subArray);\npublic static int indexOfSub(T[] array, T[] subArray);\npublic static int indexOfSub(T[] array, int beginInclude, T[] subArray);\npublic static int lastIndexOfSub(T[] array, T[] subArray);\npublic static int lastIndexOfSub(T[] array, int endInclude, T[] subArray);\npublic static boolean isSorted(T[] array, Comparator<? super T> comparator);\npublic static boolean isSorted(T[] array);\npublic static boolean isSortedASC(T[] array);\npublic static boolean isSortedDESC(T[] array);",
        "Class_name": "ArrayUtil",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/util/ArrayUtil###replace",
        "Parameter_num": "3",
        "all_Import_statements": "import cn.hutool.core.collection.CollUtil;\n\nimport cn.hutool.core.collection.CollectionUtil;\n\nimport cn.hutool.core.collection.UniqueKeySet;\n\nimport cn.hutool.core.comparator.CompareUtil;\n\nimport cn.hutool.core.convert.Convert;\n\nimport cn.hutool.core.exceptions.UtilException;\n\nimport cn.hutool.core.lang.Assert;\n\nimport cn.hutool.core.lang.Editor;\n\nimport cn.hutool.core.lang.Filter;\n\nimport cn.hutool.core.lang.Matcher;\n\nimport cn.hutool.core.map.MapUtil;\n\nimport cn.hutool.core.text.StrJoiner;\n\nimport java.lang.reflect.Array;\n\nimport java.nio.ByteBuffer;\n\nimport java.util.ArrayList;\n\nimport java.util.Arrays;\n\nimport java.util.Collection;\n\nimport java.util.Collections;\n\nimport java.util.Comparator;\n\nimport java.util.Iterator;\n\nimport java.util.LinkedHashSet;\n\nimport java.util.List;\n\nimport java.util.Map;\n\nimport java.util.Random;\n\nimport java.util.Set;\n\nimport java.util.function.Function;\n\nimport java.util.stream.Collectors;\n",
        "comment": "\n\t * 将新元素插入到到已有数组中的某个位置<br>\n\t * 添加新元素会生成一个新数组或原有数组<br>\n\t * 如果插入位置为为负数，那么生成一个由插入元素顺序加已有数组顺序的新数组\n\t *\n\t * @param <T>    数组元素类型\n\t * @param buffer 已有数组\n\t * @param index  位置，大于长度追加，否则替换，&lt;0表示从头部追加\n\t * @param values 新值\n\t * @return 新数组或原有数组\n\t * @since 5.7.23\n\t ",
        "packageName": "cn.hutool.core.util",
        "method_signature": "public static T[] replace(T[] buffer, int index, T... values);",
        "Junit_version": "5",
        "returnType": "T[]"
    },
    {
        "Method_body": "public static boolean containsAny(Collection<?> coll1, Collection<?> coll2) {\n    if (isEmpty(coll1) || isEmpty(coll2)) {\n        return false;\n    }\n    if (coll1.size() < coll2.size()) {\n        for (Object object : coll1) {\n            if (coll2.contains(object)) {\n                return true;\n            }\n        }\n    } else {\n        for (Object object : coll2) {\n            if (coll1.contains(object)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}",
        "all_field_declaration": "",
        "sub_project_name": "hutool-core",
        "lineNumbers": "3",
        "Filed": "",
        "Parameter_type": "Collection<?>,Collection<?>",
        "Import_statements": "",
        "public_method_signature": "public static Set<T> emptyIfNull(Set<T> set);\npublic static List<T> emptyIfNull(List<T> list);\npublic static Collection<T> union(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> union(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Set<T> unionDistinct(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static List<T> unionAll(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Collection<T> intersection(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> intersection(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Set<T> intersectionDistinct(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Collection<T> disjunction(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> subtract(Collection<T> coll1, Collection<T> coll2);\npublic static List<T> subtractToList(Collection<T> coll1, Collection<T> coll2);\npublic static boolean contains(Collection<?> collection, Object value);\npublic static boolean safeContains(Collection<?> collection, Object value);\npublic static boolean contains(Collection<T> collection, Predicate<? super T> containFunc);\npublic static boolean containsAny(Collection<?> coll1, Collection<?> coll2);\npublic static boolean containsAll(Collection<?> coll1, Collection<?> coll2);\npublic static Map<T, Integer> countMap(Iterable<T> collection);\npublic static String join(Iterable<T> iterable, CharSequence conjunction, Function<T, ? extends CharSequence> func);\npublic static String join(Iterable<T> iterable, CharSequence conjunction);\npublic static String join(Iterable<T> iterable, CharSequence conjunction, String prefix, String suffix);\npublic static String join(Iterator<T> iterator, CharSequence conjunction);\npublic static List<T> popPart(Stack<T> surplusAlaDatas, int partSize);\npublic static List<T> popPart(Deque<T> surplusAlaDatas, int partSize);\npublic static HashSet<T> newHashSet(T... ts);\npublic static LinkedHashSet<T> newLinkedHashSet(T... ts);\npublic static HashSet<T> set(boolean isSorted, T... ts);\npublic static HashSet<T> newHashSet(Collection<T> collection);\npublic static HashSet<T> newHashSet(boolean isSorted, Collection<T> collection);\npublic static HashSet<T> newHashSet(boolean isSorted, Iterator<T> iter);\npublic static HashSet<T> newHashSet(boolean isSorted, Enumeration<T> enumeration);\npublic static List<T> list(boolean isLinked);\npublic static List<T> list(boolean isLinked, T... values);\npublic static List<T> list(boolean isLinked, Collection<T> collection);\npublic static List<T> list(boolean isLinked, Iterable<T> iterable);\npublic static List<T> list(boolean isLinked, Iterator<T> iter);\npublic static List<T> list(boolean isLinked, Enumeration<T> enumeration);\npublic static ArrayList<T> newArrayList(T... values);\npublic static ArrayList<T> toList(T... values);\npublic static ArrayList<T> newArrayList(Collection<T> collection);\npublic static ArrayList<T> newArrayList(Iterable<T> iterable);\npublic static ArrayList<T> newArrayList(Iterator<T> iterator);\npublic static ArrayList<T> newArrayList(Enumeration<T> enumeration);\npublic static LinkedList<T> newLinkedList(T... values);\npublic static CopyOnWriteArrayList<T> newCopyOnWriteArrayList(Collection<T> collection);\npublic static BlockingQueue<T> newBlockingQueue(int capacity, boolean isLinked);\npublic static Collection<T> create(Class<?> collectionType);\npublic static Collection<T> create(Class<?> collectionType, Class<T> elementType);\npublic static ArrayList<T> distinct(Collection<T> collection);\npublic static List<T> distinct(Collection<T> collection, Function<T, K> uniqueGenerator, boolean override);\npublic static List<T> sub(List<T> list, int start, int end);\npublic static List<T> sub(List<T> list, int start, int end, int step);\npublic static List<T> sub(Collection<T> collection, int start, int end);\npublic static List<T> sub(Collection<T> collection, int start, int end, int step);\npublic static List<List<T>> splitList(List<T> list, int size);\npublic static List<List<T>> split(Collection<T> collection, int size);\npublic static Collection<T> edit(Collection<T> collection, Editor<T> editor);\npublic static Collection<T> filterNew(Collection<T> collection, Filter<T> filter);\npublic static T removeAny(T collection, E... elesRemoved);\npublic static T filter(T collection, final Filter<E> filter);\npublic static T removeNull(T collection);\npublic static T removeEmpty(T collection);\npublic static T removeBlank(T collection);\npublic static T removeWithAddIf(T targetCollection, T resultCollection, Predicate<? super E> predicate);\npublic static List<E> removeWithAddIf(T targetCollection, Predicate<? super E> predicate);\npublic static List<Object> extract(Iterable<?> collection, Editor<Object> editor);\npublic static List<Object> extract(Iterable<?> collection, Editor<Object> editor, boolean ignoreNull);\npublic static List<R> map(Iterable<T> collection, Function<? super T, ? extends R> func, boolean ignoreNull);\npublic static List<Object> getFieldValues(Iterable<?> collection, final String fieldName);\npublic static List<Object> getFieldValues(Iterable<?> collection, final String fieldName, boolean ignoreNull);\npublic static List<T> getFieldValues(Iterable<?> collection, final String fieldName, final Class<T> elementType);\npublic static Map<K, V> fieldValueMap(Iterable<V> iterable, String fieldName);\npublic static Map<K, V> fieldValueAsMap(Iterable<?> iterable, String fieldNameForKey, String fieldNameForValue);\npublic static T findOne(Iterable<T> collection, Filter<T> filter);\npublic static T findOneByField(Iterable<T> collection, final String fieldName, final Object fieldValue);\npublic static int count(Iterable<T> iterable, Matcher<T> matcher);\npublic static int indexOf(Collection<T> collection, Matcher<T> matcher);\npublic static int lastIndexOf(Collection<T> collection, Matcher<T> matcher);\npublic static int[] indexOfAll(Collection<T> collection, Matcher<T> matcher);\npublic static boolean isEmpty(Collection<?> collection);\npublic static T defaultIfEmpty(T collection, T defaultCollection);\npublic static T defaultIfEmpty(T collection, Supplier<? extends T> supplier);\npublic static boolean isEmpty(Iterable<?> iterable);\npublic static boolean isEmpty(Iterator<?> Iterator);\npublic static boolean isEmpty(Enumeration<?> enumeration);\npublic static boolean isEmpty(Map<?, ?> map);\npublic static boolean isNotEmpty(Collection<?> collection);\npublic static boolean isNotEmpty(Iterable<?> iterable);\npublic static boolean isNotEmpty(Iterator<?> Iterator);\npublic static boolean isNotEmpty(Enumeration<?> enumeration);\npublic static boolean hasNull(Iterable<?> iterable);\npublic static boolean isNotEmpty(Map<?, ?> map);\npublic static Map<String, String> zip(String keys, String values, String delimiter, boolean isOrder);\npublic static Map<String, String> zip(String keys, String values, String delimiter);\npublic static Map<K, V> zip(Collection<K> keys, Collection<V> values);\npublic static HashMap<K, V> toMap(Iterable<Entry<K, V>> entryIter);\npublic static HashMap<Object, Object> toMap(Object[] array);\npublic static TreeSet<T> toTreeSet(Collection<T> collection, Comparator<T> comparator);\npublic static Enumeration<E> asEnumeration(Iterator<E> iter);\npublic static Iterator<E> asIterator(Enumeration<E> e);\npublic static Iterable<E> asIterable(final Iterator<E> iter);\npublic static Collection<E> toCollection(Iterable<E> iterable);\npublic static Map<K, List<V>> toListMap(Iterable<? extends Map<K, V>> mapList);\npublic static List<Map<K, V>> toMapList(Map<K, ? extends Iterable<V>> listMap);\npublic static Map<K, V> toMap(Iterable<V> values, Map<K, V> map, Func1<V, K> keyFunc);\npublic static Map<K, V> toMap(Iterable<E> values, Map<K, V> map, Func1<E, K> keyFunc, Func1<E, V> valueFunc);\npublic static boolean addIfAbsent(Collection<T> collection, S object);\npublic static Collection<T> addAll(Collection<T> collection, Object value);\npublic static Collection<T> addAll(Collection<T> collection, Object value, Type elementType);\npublic static Collection<T> addAll(Collection<T> collection, Iterator<T> iterator);\npublic static Collection<T> addAll(Collection<T> collection, Iterable<T> iterable);\npublic static Collection<T> addAll(Collection<T> collection, Enumeration<T> enumeration);\npublic static Collection<T> addAll(Collection<T> collection, T[] values);\npublic static List<T> addAllIfNotContains(List<T> list, List<T> otherList);\npublic static T get(Collection<T> collection, int index);\npublic static List<T> getAny(Collection<T> collection, int... indexes);\npublic static T getFirst(Iterable<T> iterable);\npublic static T getFirst(Iterator<T> iterator);\npublic static T getLast(Collection<T> collection);\npublic static Class<?> getElementType(Iterable<?> iterable);\npublic static Class<?> getElementType(Iterator<?> iterator);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, K... keys);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, Iterable<K> keys);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, Iterator<K> keys);\npublic static List<T> sortPageAll(int pageNo, int pageSize, Comparator<T> comparator, Collection<T>... colls);\npublic static List<T> page(int pageNo, int pageSize, List<T> list);\npublic static List<T> sort(Collection<T> collection, Comparator<? super T> comparator);\npublic static List<T> sort(List<T> list, Comparator<? super T> c);\npublic static List<T> sortByProperty(Collection<T> collection, String property);\npublic static List<T> sortByProperty(List<T> list, String property);\npublic static List<String> sortByPinyin(Collection<String> collection);\npublic static List<String> sortByPinyin(List<String> list);\npublic static TreeMap<K, V> sort(Map<K, V> map, Comparator<? super K> comparator);\npublic static LinkedHashMap<K, V> sortToMap(Collection<Map.Entry<K, V>> entryCollection, Comparator<Map.Entry<K, V>> comparator);\npublic static LinkedHashMap<K, V> sortByEntry(Map<K, V> map, Comparator<Map.Entry<K, V>> comparator);\npublic static List<Entry<K, V>> sortEntryToList(Collection<Entry<K, V>> collection);\npublic static void forEach(Iterable<T> iterable, Consumer<T> consumer);\npublic static void forEach(Iterator<T> iterator, Consumer<T> consumer);\npublic static void forEach(Enumeration<T> enumeration, Consumer<T> consumer);\npublic static void forEach(Map<K, V> map, KVConsumer<K, V> kvConsumer);\npublic static List<List<T>> group(Collection<T> collection, Hash32<T> hash);\npublic static List<List<T>> groupByField(Collection<T> collection, final String fieldName);\npublic static List<T> reverse(List<T> list);\npublic static List<T> reverseNew(List<T> list);\npublic static List<T> setOrAppend(List<T> list, int index, T element);\npublic static Set<K> keySet(Collection<Map<K, ?>> mapCollection);\npublic static List<V> values(Collection<Map<?, V>> mapCollection);\npublic static T max(Collection<T> coll);\npublic static T min(Collection<T> coll);\npublic static Collection<T> unmodifiable(Collection<? extends T> c);\npublic static T empty(Class<?> collectionClass);\npublic static void clear(Collection<?>... collections);\npublic static void padLeft(List<T> list, int minLen, T padObj);\npublic static void padRight(Collection<T> list, int minLen, T padObj);\npublic static Collection<T> trans(Collection<F> collection, Function<? super F, ? extends T> function);\npublic static void setValueByMap(Iterable<E> iterable, Map<K, V> map, Function<E, K> keyGenerate, BiConsumer<E, V> biConsumer);\npublic static int size(final Object object);\npublic static boolean isEqualList(final Collection<?> list1, final Collection<?> list2);",
        "public_field": "",
        "Method_statement": "containsAny(Collection<?> coll1, Collection<?> coll2)",
        "Method_name": "containsAny",
        "Class_declaration": "public class CollUtil {\n",
        "constructors": "",
        "all_method_signature": "public static Set<T> emptyIfNull(Set<T> set);\npublic static List<T> emptyIfNull(List<T> list);\npublic static Collection<T> union(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> union(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Set<T> unionDistinct(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static List<T> unionAll(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Collection<T> intersection(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> intersection(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Set<T> intersectionDistinct(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Collection<T> disjunction(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> subtract(Collection<T> coll1, Collection<T> coll2);\npublic static List<T> subtractToList(Collection<T> coll1, Collection<T> coll2);\npublic static boolean contains(Collection<?> collection, Object value);\npublic static boolean safeContains(Collection<?> collection, Object value);\npublic static boolean contains(Collection<T> collection, Predicate<? super T> containFunc);\npublic static boolean containsAny(Collection<?> coll1, Collection<?> coll2);\npublic static boolean containsAll(Collection<?> coll1, Collection<?> coll2);\npublic static Map<T, Integer> countMap(Iterable<T> collection);\npublic static String join(Iterable<T> iterable, CharSequence conjunction, Function<T, ? extends CharSequence> func);\npublic static String join(Iterable<T> iterable, CharSequence conjunction);\npublic static String join(Iterable<T> iterable, CharSequence conjunction, String prefix, String suffix);\npublic static String join(Iterator<T> iterator, CharSequence conjunction);\npublic static List<T> popPart(Stack<T> surplusAlaDatas, int partSize);\npublic static List<T> popPart(Deque<T> surplusAlaDatas, int partSize);\npublic static HashSet<T> newHashSet(T... ts);\npublic static LinkedHashSet<T> newLinkedHashSet(T... ts);\npublic static HashSet<T> set(boolean isSorted, T... ts);\npublic static HashSet<T> newHashSet(Collection<T> collection);\npublic static HashSet<T> newHashSet(boolean isSorted, Collection<T> collection);\npublic static HashSet<T> newHashSet(boolean isSorted, Iterator<T> iter);\npublic static HashSet<T> newHashSet(boolean isSorted, Enumeration<T> enumeration);\npublic static List<T> list(boolean isLinked);\npublic static List<T> list(boolean isLinked, T... values);\npublic static List<T> list(boolean isLinked, Collection<T> collection);\npublic static List<T> list(boolean isLinked, Iterable<T> iterable);\npublic static List<T> list(boolean isLinked, Iterator<T> iter);\npublic static List<T> list(boolean isLinked, Enumeration<T> enumeration);\npublic static ArrayList<T> newArrayList(T... values);\npublic static ArrayList<T> toList(T... values);\npublic static ArrayList<T> newArrayList(Collection<T> collection);\npublic static ArrayList<T> newArrayList(Iterable<T> iterable);\npublic static ArrayList<T> newArrayList(Iterator<T> iterator);\npublic static ArrayList<T> newArrayList(Enumeration<T> enumeration);\npublic static LinkedList<T> newLinkedList(T... values);\npublic static CopyOnWriteArrayList<T> newCopyOnWriteArrayList(Collection<T> collection);\npublic static BlockingQueue<T> newBlockingQueue(int capacity, boolean isLinked);\npublic static Collection<T> create(Class<?> collectionType);\npublic static Collection<T> create(Class<?> collectionType, Class<T> elementType);\npublic static ArrayList<T> distinct(Collection<T> collection);\npublic static List<T> distinct(Collection<T> collection, Function<T, K> uniqueGenerator, boolean override);\npublic static List<T> sub(List<T> list, int start, int end);\npublic static List<T> sub(List<T> list, int start, int end, int step);\npublic static List<T> sub(Collection<T> collection, int start, int end);\npublic static List<T> sub(Collection<T> collection, int start, int end, int step);\npublic static List<List<T>> splitList(List<T> list, int size);\npublic static List<List<T>> split(Collection<T> collection, int size);\npublic static Collection<T> edit(Collection<T> collection, Editor<T> editor);\npublic static Collection<T> filterNew(Collection<T> collection, Filter<T> filter);\npublic static T removeAny(T collection, E... elesRemoved);\npublic static T filter(T collection, final Filter<E> filter);\npublic static T removeNull(T collection);\npublic static T removeEmpty(T collection);\npublic static T removeBlank(T collection);\npublic static T removeWithAddIf(T targetCollection, T resultCollection, Predicate<? super E> predicate);\npublic static List<E> removeWithAddIf(T targetCollection, Predicate<? super E> predicate);\npublic static List<Object> extract(Iterable<?> collection, Editor<Object> editor);\npublic static List<Object> extract(Iterable<?> collection, Editor<Object> editor, boolean ignoreNull);\npublic static List<R> map(Iterable<T> collection, Function<? super T, ? extends R> func, boolean ignoreNull);\npublic static List<Object> getFieldValues(Iterable<?> collection, final String fieldName);\npublic static List<Object> getFieldValues(Iterable<?> collection, final String fieldName, boolean ignoreNull);\npublic static List<T> getFieldValues(Iterable<?> collection, final String fieldName, final Class<T> elementType);\npublic static Map<K, V> fieldValueMap(Iterable<V> iterable, String fieldName);\npublic static Map<K, V> fieldValueAsMap(Iterable<?> iterable, String fieldNameForKey, String fieldNameForValue);\npublic static T findOne(Iterable<T> collection, Filter<T> filter);\npublic static T findOneByField(Iterable<T> collection, final String fieldName, final Object fieldValue);\npublic static int count(Iterable<T> iterable, Matcher<T> matcher);\npublic static int indexOf(Collection<T> collection, Matcher<T> matcher);\npublic static int lastIndexOf(Collection<T> collection, Matcher<T> matcher);\npublic static int[] indexOfAll(Collection<T> collection, Matcher<T> matcher);\npublic static boolean isEmpty(Collection<?> collection);\npublic static T defaultIfEmpty(T collection, T defaultCollection);\npublic static T defaultIfEmpty(T collection, Supplier<? extends T> supplier);\npublic static boolean isEmpty(Iterable<?> iterable);\npublic static boolean isEmpty(Iterator<?> Iterator);\npublic static boolean isEmpty(Enumeration<?> enumeration);\npublic static boolean isEmpty(Map<?, ?> map);\npublic static boolean isNotEmpty(Collection<?> collection);\npublic static boolean isNotEmpty(Iterable<?> iterable);\npublic static boolean isNotEmpty(Iterator<?> Iterator);\npublic static boolean isNotEmpty(Enumeration<?> enumeration);\npublic static boolean hasNull(Iterable<?> iterable);\npublic static boolean isNotEmpty(Map<?, ?> map);\npublic static Map<String, String> zip(String keys, String values, String delimiter, boolean isOrder);\npublic static Map<String, String> zip(String keys, String values, String delimiter);\npublic static Map<K, V> zip(Collection<K> keys, Collection<V> values);\npublic static HashMap<K, V> toMap(Iterable<Entry<K, V>> entryIter);\npublic static HashMap<Object, Object> toMap(Object[] array);\npublic static TreeSet<T> toTreeSet(Collection<T> collection, Comparator<T> comparator);\npublic static Enumeration<E> asEnumeration(Iterator<E> iter);\npublic static Iterator<E> asIterator(Enumeration<E> e);\npublic static Iterable<E> asIterable(final Iterator<E> iter);\npublic static Collection<E> toCollection(Iterable<E> iterable);\npublic static Map<K, List<V>> toListMap(Iterable<? extends Map<K, V>> mapList);\npublic static List<Map<K, V>> toMapList(Map<K, ? extends Iterable<V>> listMap);\npublic static Map<K, V> toMap(Iterable<V> values, Map<K, V> map, Func1<V, K> keyFunc);\npublic static Map<K, V> toMap(Iterable<E> values, Map<K, V> map, Func1<E, K> keyFunc, Func1<E, V> valueFunc);\npublic static boolean addIfAbsent(Collection<T> collection, S object);\npublic static Collection<T> addAll(Collection<T> collection, Object value);\npublic static Collection<T> addAll(Collection<T> collection, Object value, Type elementType);\npublic static Collection<T> addAll(Collection<T> collection, Iterator<T> iterator);\npublic static Collection<T> addAll(Collection<T> collection, Iterable<T> iterable);\npublic static Collection<T> addAll(Collection<T> collection, Enumeration<T> enumeration);\npublic static Collection<T> addAll(Collection<T> collection, T[] values);\npublic static List<T> addAllIfNotContains(List<T> list, List<T> otherList);\npublic static T get(Collection<T> collection, int index);\npublic static List<T> getAny(Collection<T> collection, int... indexes);\npublic static T getFirst(Iterable<T> iterable);\npublic static T getFirst(Iterator<T> iterator);\npublic static T getLast(Collection<T> collection);\npublic static Class<?> getElementType(Iterable<?> iterable);\npublic static Class<?> getElementType(Iterator<?> iterator);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, K... keys);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, Iterable<K> keys);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, Iterator<K> keys);\npublic static List<T> sortPageAll(int pageNo, int pageSize, Comparator<T> comparator, Collection<T>... colls);\npublic static List<T> page(int pageNo, int pageSize, List<T> list);\npublic static List<T> sort(Collection<T> collection, Comparator<? super T> comparator);\npublic static List<T> sort(List<T> list, Comparator<? super T> c);\npublic static List<T> sortByProperty(Collection<T> collection, String property);\npublic static List<T> sortByProperty(List<T> list, String property);\npublic static List<String> sortByPinyin(Collection<String> collection);\npublic static List<String> sortByPinyin(List<String> list);\npublic static TreeMap<K, V> sort(Map<K, V> map, Comparator<? super K> comparator);\npublic static LinkedHashMap<K, V> sortToMap(Collection<Map.Entry<K, V>> entryCollection, Comparator<Map.Entry<K, V>> comparator);\npublic static LinkedHashMap<K, V> sortByEntry(Map<K, V> map, Comparator<Map.Entry<K, V>> comparator);\npublic static List<Entry<K, V>> sortEntryToList(Collection<Entry<K, V>> collection);\npublic static void forEach(Iterable<T> iterable, Consumer<T> consumer);\npublic static void forEach(Iterator<T> iterator, Consumer<T> consumer);\npublic static void forEach(Enumeration<T> enumeration, Consumer<T> consumer);\npublic static void forEach(Map<K, V> map, KVConsumer<K, V> kvConsumer);\npublic static List<List<T>> group(Collection<T> collection, Hash32<T> hash);\npublic static List<List<T>> groupByField(Collection<T> collection, final String fieldName);\npublic static List<T> reverse(List<T> list);\npublic static List<T> reverseNew(List<T> list);\npublic static List<T> setOrAppend(List<T> list, int index, T element);\npublic static Set<K> keySet(Collection<Map<K, ?>> mapCollection);\npublic static List<V> values(Collection<Map<?, V>> mapCollection);\npublic static T max(Collection<T> coll);\npublic static T min(Collection<T> coll);\npublic static Collection<T> unmodifiable(Collection<? extends T> c);\npublic static T empty(Class<?> collectionClass);\npublic static void clear(Collection<?>... collections);\npublic static void padLeft(List<T> list, int minLen, T padObj);\npublic static void padRight(Collection<T> list, int minLen, T padObj);\npublic static Collection<T> trans(Collection<F> collection, Function<? super F, ? extends T> function);\npublic static void setValueByMap(Iterable<E> iterable, Map<K, V> map, Function<E, K> keyGenerate, BiConsumer<E, V> biConsumer);\npublic static int size(final Object object);\npublic static boolean isEqualList(final Collection<?> list1, final Collection<?> list2);",
        "Class_name": "CollUtil",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/collection/CollUtil###containsAny",
        "Parameter_num": "2",
        "all_Import_statements": "import cn.hutool.core.bean.BeanUtil;\n\nimport cn.hutool.core.comparator.CompareUtil;\n\nimport cn.hutool.core.comparator.PinyinComparator;\n\nimport cn.hutool.core.comparator.PropertyComparator;\n\nimport cn.hutool.core.convert.Convert;\n\nimport cn.hutool.core.convert.ConverterRegistry;\n\nimport cn.hutool.core.exceptions.UtilException;\n\nimport cn.hutool.core.lang.Assert;\n\nimport cn.hutool.core.lang.Editor;\n\nimport cn.hutool.core.lang.Filter;\n\nimport cn.hutool.core.lang.Matcher;\n\nimport cn.hutool.core.lang.func.Func1;\n\nimport cn.hutool.core.lang.hash.Hash32;\n\nimport cn.hutool.core.map.MapUtil;\n\nimport cn.hutool.core.util.*;\n\nimport java.io.Serializable;\n\nimport java.lang.reflect.Type;\n\nimport java.util.*;\n\nimport java.util.Map.Entry;\n\nimport java.util.concurrent.ArrayBlockingQueue;\n\nimport java.util.concurrent.BlockingQueue;\n\nimport java.util.concurrent.CopyOnWriteArrayList;\n\nimport java.util.concurrent.LinkedBlockingDeque;\n\nimport java.util.function.BiConsumer;\n\nimport java.util.function.Function;\n\nimport java.util.function.Predicate;\n\nimport java.util.function.Supplier;\n",
        "comment": "\n\t * 其中一个集合在另一个集合中是否至少包含一个元素，即是两个集合是否至少有一个共同的元素\n\t *\n\t * @param coll1 集合1\n\t * @param coll2 集合2\n\t * @return 其中一个集合在另一个集合中是否至少包含一个元素\n\t * @see #intersection\n\t * @since 2.1\n\t ",
        "packageName": "cn.hutool.core.collection",
        "method_signature": "public static boolean containsAny(Collection<?> coll1, Collection<?> coll2);",
        "Junit_version": "5",
        "returnType": "boolean"
    },
    {
        "Method_body": "public static String getShortClassName(String className) {\n    final List<String> packages = StrUtil.split(className, CharUtil.DOT);\n    if (null == packages || packages.size() < 2) {\n        return className;\n    }\n    final int size = packages.size();\n    final StringBuilder result = StrUtil.builder();\n    result.append(packages.get(0).charAt(0));\n    for (int i = 1; i < size - 1; i++) {\n        result.append(CharUtil.DOT).append(packages.get(i).charAt(0));\n    }\n    result.append(CharUtil.DOT).append(packages.get(size - 1));\n    return result.toString();\n}",
        "all_field_declaration": "",
        "sub_project_name": "hutool-core",
        "lineNumbers": "8",
        "Filed": "",
        "Parameter_type": "String",
        "Import_statements": "import java.util.List;\n",
        "public_method_signature": "public static Class<T> getClass(T obj);\npublic static Class<?> getEnclosingClass(Class<?> clazz);\npublic static boolean isTopLevelClass(Class<?> clazz);\npublic static String getClassName(Object obj, boolean isSimple);\npublic static String getClassName(Class<?> clazz, boolean isSimple);\npublic static String getShortClassName(String className);\npublic static Class<?>[] getClasses(Object... objects);\npublic static boolean equals(Class<?> clazz, String className, boolean ignoreCase);\npublic static Set<Class<?>> scanPackageByAnnotation(String packageName, final Class<? extends Annotation> annotationClass);\npublic static Set<Class<?>> scanPackageBySuper(String packageName, final Class<?> superClass);\npublic static Set<Class<?>> scanPackage();\npublic static Set<Class<?>> scanPackage(String packageName);\npublic static Set<Class<?>> scanPackage(String packageName, Filter<Class<?>> classFilter);\npublic static Set<String> getPublicMethodNames(Class<?> clazz);\npublic static Method[] getPublicMethods(Class<?> clazz);\npublic static List<Method> getPublicMethods(Class<?> clazz, Filter<Method> filter);\npublic static List<Method> getPublicMethods(Class<?> clazz, Method... excludeMethods);\npublic static List<Method> getPublicMethods(Class<?> clazz, String... excludeMethodNames);\npublic static Method getPublicMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) throws SecurityException;\npublic static Set<String> getDeclaredMethodNames(Class<?> clazz);\npublic static Method[] getDeclaredMethods(Class<?> clazz);\npublic static Method getDeclaredMethodOfObj(Object obj, String methodName, Object... args) throws SecurityException;\npublic static Method getDeclaredMethod(Class<?> clazz, String methodName, Class<?>... parameterTypes) throws SecurityException;\npublic static Field getDeclaredField(Class<?> clazz, String fieldName) throws SecurityException;\npublic static Field[] getDeclaredFields(Class<?> clazz) throws SecurityException;\npublic static Set<String> getClassPathResources();\npublic static Set<String> getClassPathResources(boolean isDecode);\npublic static Set<String> getClassPaths(String packageName);\npublic static Set<String> getClassPaths(String packageName, boolean isDecode);\npublic static String getClassPath();\npublic static String getClassPath(boolean isEncoded);\npublic static URL getClassPathURL();\npublic static URL getResourceURL(String resource) throws IORuntimeException;\npublic static List<URL> getResources(String resource);\npublic static URL getResourceUrl(String resource, Class<?> baseClass);\npublic static String[] getJavaClassPaths();\npublic static ClassLoader getContextClassLoader();\npublic static ClassLoader getClassLoader();\npublic static boolean isAllAssignableFrom(Class<?>[] types1, Class<?>[] types2);\npublic static Class<T> loadClass(String className, boolean isInitialized);\npublic static Class<T> loadClass(String className);\npublic static T invoke(String classNameWithMethodName, Object[] args);\npublic static T invoke(String classNameWithMethodName, boolean isSingleton, Object... args);\npublic static T invoke(String className, String methodName, Object[] args);\npublic static T invoke(String className, String methodName, boolean isSingleton, Object... args);\npublic static boolean isPrimitiveWrapper(Class<?> clazz);\npublic static boolean isBasicType(Class<?> clazz);\npublic static boolean isSimpleTypeOrArray(Class<?> clazz);\npublic static boolean isSimpleValueType(Class<?> clazz);\npublic static boolean isAssignable(Class<?> targetType, Class<?> sourceType);\npublic static boolean isPublic(Class<?> clazz);\npublic static boolean isPublic(Method method);\npublic static boolean isNotPublic(Class<?> clazz);\npublic static boolean isNotPublic(Method method);\npublic static boolean isStatic(Method method);\npublic static Method setAccessible(Method method);\npublic static boolean isAbstract(Class<?> clazz);\npublic static boolean isNormalClass(Class<?> clazz);\npublic static boolean isEnum(Class<?> clazz);\npublic static Class<?> getTypeArgument(Class<?> clazz);\npublic static Class<?> getTypeArgument(Class<?> clazz, int index);\npublic static String getPackage(Class<?> clazz);\npublic static String getPackagePath(Class<?> clazz);\npublic static Object getDefaultValue(Class<?> clazz);\npublic static Object getPrimitiveDefaultValue(Class<?> clazz);\npublic static Object[] getDefaultValues(Class<?>... classes);\npublic static boolean isJdkClass(Class<?> clazz);\npublic static URL getLocation(Class<?> clazz);\npublic static String getLocationPath(Class<?> clazz);\npublic static boolean isAbstractOrInterface(Class<?> clazz);\npublic static boolean isInterface(Class<?> clazz);",
        "public_field": "",
        "Method_statement": "getShortClassName(String className)",
        "Method_name": "getShortClassName",
        "Class_declaration": "public class ClassUtil {\n",
        "constructors": "",
        "all_method_signature": "public static Class<T> getClass(T obj);\npublic static Class<?> getEnclosingClass(Class<?> clazz);\npublic static boolean isTopLevelClass(Class<?> clazz);\npublic static String getClassName(Object obj, boolean isSimple);\npublic static String getClassName(Class<?> clazz, boolean isSimple);\npublic static String getShortClassName(String className);\npublic static Class<?>[] getClasses(Object... objects);\npublic static boolean equals(Class<?> clazz, String className, boolean ignoreCase);\npublic static Set<Class<?>> scanPackageByAnnotation(String packageName, final Class<? extends Annotation> annotationClass);\npublic static Set<Class<?>> scanPackageBySuper(String packageName, final Class<?> superClass);\npublic static Set<Class<?>> scanPackage();\npublic static Set<Class<?>> scanPackage(String packageName);\npublic static Set<Class<?>> scanPackage(String packageName, Filter<Class<?>> classFilter);\npublic static Set<String> getPublicMethodNames(Class<?> clazz);\npublic static Method[] getPublicMethods(Class<?> clazz);\npublic static List<Method> getPublicMethods(Class<?> clazz, Filter<Method> filter);\npublic static List<Method> getPublicMethods(Class<?> clazz, Method... excludeMethods);\npublic static List<Method> getPublicMethods(Class<?> clazz, String... excludeMethodNames);\npublic static Method getPublicMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) throws SecurityException;\npublic static Set<String> getDeclaredMethodNames(Class<?> clazz);\npublic static Method[] getDeclaredMethods(Class<?> clazz);\npublic static Method getDeclaredMethodOfObj(Object obj, String methodName, Object... args) throws SecurityException;\npublic static Method getDeclaredMethod(Class<?> clazz, String methodName, Class<?>... parameterTypes) throws SecurityException;\npublic static Field getDeclaredField(Class<?> clazz, String fieldName) throws SecurityException;\npublic static Field[] getDeclaredFields(Class<?> clazz) throws SecurityException;\npublic static Set<String> getClassPathResources();\npublic static Set<String> getClassPathResources(boolean isDecode);\npublic static Set<String> getClassPaths(String packageName);\npublic static Set<String> getClassPaths(String packageName, boolean isDecode);\npublic static String getClassPath();\npublic static String getClassPath(boolean isEncoded);\npublic static URL getClassPathURL();\npublic static URL getResourceURL(String resource) throws IORuntimeException;\npublic static List<URL> getResources(String resource);\npublic static URL getResourceUrl(String resource, Class<?> baseClass);\npublic static String[] getJavaClassPaths();\npublic static ClassLoader getContextClassLoader();\npublic static ClassLoader getClassLoader();\npublic static boolean isAllAssignableFrom(Class<?>[] types1, Class<?>[] types2);\npublic static Class<T> loadClass(String className, boolean isInitialized);\npublic static Class<T> loadClass(String className);\npublic static T invoke(String classNameWithMethodName, Object[] args);\npublic static T invoke(String classNameWithMethodName, boolean isSingleton, Object... args);\npublic static T invoke(String className, String methodName, Object[] args);\npublic static T invoke(String className, String methodName, boolean isSingleton, Object... args);\npublic static boolean isPrimitiveWrapper(Class<?> clazz);\npublic static boolean isBasicType(Class<?> clazz);\npublic static boolean isSimpleTypeOrArray(Class<?> clazz);\npublic static boolean isSimpleValueType(Class<?> clazz);\npublic static boolean isAssignable(Class<?> targetType, Class<?> sourceType);\npublic static boolean isPublic(Class<?> clazz);\npublic static boolean isPublic(Method method);\npublic static boolean isNotPublic(Class<?> clazz);\npublic static boolean isNotPublic(Method method);\npublic static boolean isStatic(Method method);\npublic static Method setAccessible(Method method);\npublic static boolean isAbstract(Class<?> clazz);\npublic static boolean isNormalClass(Class<?> clazz);\npublic static boolean isEnum(Class<?> clazz);\npublic static Class<?> getTypeArgument(Class<?> clazz);\npublic static Class<?> getTypeArgument(Class<?> clazz, int index);\npublic static String getPackage(Class<?> clazz);\npublic static String getPackagePath(Class<?> clazz);\npublic static Object getDefaultValue(Class<?> clazz);\npublic static Object getPrimitiveDefaultValue(Class<?> clazz);\npublic static Object[] getDefaultValues(Class<?>... classes);\npublic static boolean isJdkClass(Class<?> clazz);\npublic static URL getLocation(Class<?> clazz);\npublic static String getLocationPath(Class<?> clazz);\npublic static boolean isAbstractOrInterface(Class<?> clazz);\npublic static boolean isInterface(Class<?> clazz);",
        "Class_name": "ClassUtil",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/util/ClassUtil###getShortClassName",
        "Parameter_num": "1",
        "all_Import_statements": "import cn.hutool.core.bean.NullWrapperBean;\n\nimport cn.hutool.core.convert.BasicType;\n\nimport cn.hutool.core.exceptions.UtilException;\n\nimport cn.hutool.core.io.FileUtil;\n\nimport cn.hutool.core.io.IORuntimeException;\n\nimport cn.hutool.core.io.resource.ResourceUtil;\n\nimport cn.hutool.core.lang.Assert;\n\nimport cn.hutool.core.lang.ClassScanner;\n\nimport cn.hutool.core.lang.Filter;\n\nimport cn.hutool.core.lang.Singleton;\n\nimport java.io.IOException;\n\nimport java.lang.annotation.Annotation;\n\nimport java.lang.reflect.Field;\n\nimport java.lang.reflect.Method;\n\nimport java.lang.reflect.Modifier;\n\nimport java.lang.reflect.Type;\n\nimport java.net.URI;\n\nimport java.net.URL;\n\nimport java.time.temporal.TemporalAccessor;\n\nimport java.util.Date;\n\nimport java.util.Enumeration;\n\nimport java.util.HashSet;\n\nimport java.util.List;\n\nimport java.util.Locale;\n\nimport java.util.Set;\n",
        "comment": "\n\t * 获取完整类名的短格式如：<br>\n\t * cn.hutool.core.util.StrUtil -》c.h.c.u.StrUtil\n\t *\n\t * @param className 类名\n\t * @return 短格式类名\n\t * @since 4.1.9\n\t ",
        "packageName": "cn.hutool.core.util",
        "method_signature": "public static String getShortClassName(String className);",
        "Junit_version": "5",
        "returnType": "String"
    },
    {
        "Method_body": "public static String getClassName(Object obj, boolean isSimple) {\n    if (null == obj) {\n        return null;\n    }\n    final Class<?> clazz = obj.getClass();\n    return getClassName(clazz, isSimple);\n}",
        "all_field_declaration": "",
        "sub_project_name": "hutool-core",
        "lineNumbers": "3",
        "Filed": "",
        "Parameter_type": "Object,boolean",
        "Import_statements": "",
        "public_method_signature": "public static Class<T> getClass(T obj);\npublic static Class<?> getEnclosingClass(Class<?> clazz);\npublic static boolean isTopLevelClass(Class<?> clazz);\npublic static String getClassName(Object obj, boolean isSimple);\npublic static String getClassName(Class<?> clazz, boolean isSimple);\npublic static String getShortClassName(String className);\npublic static Class<?>[] getClasses(Object... objects);\npublic static boolean equals(Class<?> clazz, String className, boolean ignoreCase);\npublic static Set<Class<?>> scanPackageByAnnotation(String packageName, final Class<? extends Annotation> annotationClass);\npublic static Set<Class<?>> scanPackageBySuper(String packageName, final Class<?> superClass);\npublic static Set<Class<?>> scanPackage();\npublic static Set<Class<?>> scanPackage(String packageName);\npublic static Set<Class<?>> scanPackage(String packageName, Filter<Class<?>> classFilter);\npublic static Set<String> getPublicMethodNames(Class<?> clazz);\npublic static Method[] getPublicMethods(Class<?> clazz);\npublic static List<Method> getPublicMethods(Class<?> clazz, Filter<Method> filter);\npublic static List<Method> getPublicMethods(Class<?> clazz, Method... excludeMethods);\npublic static List<Method> getPublicMethods(Class<?> clazz, String... excludeMethodNames);\npublic static Method getPublicMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) throws SecurityException;\npublic static Set<String> getDeclaredMethodNames(Class<?> clazz);\npublic static Method[] getDeclaredMethods(Class<?> clazz);\npublic static Method getDeclaredMethodOfObj(Object obj, String methodName, Object... args) throws SecurityException;\npublic static Method getDeclaredMethod(Class<?> clazz, String methodName, Class<?>... parameterTypes) throws SecurityException;\npublic static Field getDeclaredField(Class<?> clazz, String fieldName) throws SecurityException;\npublic static Field[] getDeclaredFields(Class<?> clazz) throws SecurityException;\npublic static Set<String> getClassPathResources();\npublic static Set<String> getClassPathResources(boolean isDecode);\npublic static Set<String> getClassPaths(String packageName);\npublic static Set<String> getClassPaths(String packageName, boolean isDecode);\npublic static String getClassPath();\npublic static String getClassPath(boolean isEncoded);\npublic static URL getClassPathURL();\npublic static URL getResourceURL(String resource) throws IORuntimeException;\npublic static List<URL> getResources(String resource);\npublic static URL getResourceUrl(String resource, Class<?> baseClass);\npublic static String[] getJavaClassPaths();\npublic static ClassLoader getContextClassLoader();\npublic static ClassLoader getClassLoader();\npublic static boolean isAllAssignableFrom(Class<?>[] types1, Class<?>[] types2);\npublic static Class<T> loadClass(String className, boolean isInitialized);\npublic static Class<T> loadClass(String className);\npublic static T invoke(String classNameWithMethodName, Object[] args);\npublic static T invoke(String classNameWithMethodName, boolean isSingleton, Object... args);\npublic static T invoke(String className, String methodName, Object[] args);\npublic static T invoke(String className, String methodName, boolean isSingleton, Object... args);\npublic static boolean isPrimitiveWrapper(Class<?> clazz);\npublic static boolean isBasicType(Class<?> clazz);\npublic static boolean isSimpleTypeOrArray(Class<?> clazz);\npublic static boolean isSimpleValueType(Class<?> clazz);\npublic static boolean isAssignable(Class<?> targetType, Class<?> sourceType);\npublic static boolean isPublic(Class<?> clazz);\npublic static boolean isPublic(Method method);\npublic static boolean isNotPublic(Class<?> clazz);\npublic static boolean isNotPublic(Method method);\npublic static boolean isStatic(Method method);\npublic static Method setAccessible(Method method);\npublic static boolean isAbstract(Class<?> clazz);\npublic static boolean isNormalClass(Class<?> clazz);\npublic static boolean isEnum(Class<?> clazz);\npublic static Class<?> getTypeArgument(Class<?> clazz);\npublic static Class<?> getTypeArgument(Class<?> clazz, int index);\npublic static String getPackage(Class<?> clazz);\npublic static String getPackagePath(Class<?> clazz);\npublic static Object getDefaultValue(Class<?> clazz);\npublic static Object getPrimitiveDefaultValue(Class<?> clazz);\npublic static Object[] getDefaultValues(Class<?>... classes);\npublic static boolean isJdkClass(Class<?> clazz);\npublic static URL getLocation(Class<?> clazz);\npublic static String getLocationPath(Class<?> clazz);\npublic static boolean isAbstractOrInterface(Class<?> clazz);\npublic static boolean isInterface(Class<?> clazz);",
        "public_field": "",
        "Method_statement": "getClassName(Object obj, boolean isSimple)",
        "Method_name": "getClassName",
        "Class_declaration": "public class ClassUtil {\n",
        "constructors": "",
        "all_method_signature": "public static Class<T> getClass(T obj);\npublic static Class<?> getEnclosingClass(Class<?> clazz);\npublic static boolean isTopLevelClass(Class<?> clazz);\npublic static String getClassName(Object obj, boolean isSimple);\npublic static String getClassName(Class<?> clazz, boolean isSimple);\npublic static String getShortClassName(String className);\npublic static Class<?>[] getClasses(Object... objects);\npublic static boolean equals(Class<?> clazz, String className, boolean ignoreCase);\npublic static Set<Class<?>> scanPackageByAnnotation(String packageName, final Class<? extends Annotation> annotationClass);\npublic static Set<Class<?>> scanPackageBySuper(String packageName, final Class<?> superClass);\npublic static Set<Class<?>> scanPackage();\npublic static Set<Class<?>> scanPackage(String packageName);\npublic static Set<Class<?>> scanPackage(String packageName, Filter<Class<?>> classFilter);\npublic static Set<String> getPublicMethodNames(Class<?> clazz);\npublic static Method[] getPublicMethods(Class<?> clazz);\npublic static List<Method> getPublicMethods(Class<?> clazz, Filter<Method> filter);\npublic static List<Method> getPublicMethods(Class<?> clazz, Method... excludeMethods);\npublic static List<Method> getPublicMethods(Class<?> clazz, String... excludeMethodNames);\npublic static Method getPublicMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) throws SecurityException;\npublic static Set<String> getDeclaredMethodNames(Class<?> clazz);\npublic static Method[] getDeclaredMethods(Class<?> clazz);\npublic static Method getDeclaredMethodOfObj(Object obj, String methodName, Object... args) throws SecurityException;\npublic static Method getDeclaredMethod(Class<?> clazz, String methodName, Class<?>... parameterTypes) throws SecurityException;\npublic static Field getDeclaredField(Class<?> clazz, String fieldName) throws SecurityException;\npublic static Field[] getDeclaredFields(Class<?> clazz) throws SecurityException;\npublic static Set<String> getClassPathResources();\npublic static Set<String> getClassPathResources(boolean isDecode);\npublic static Set<String> getClassPaths(String packageName);\npublic static Set<String> getClassPaths(String packageName, boolean isDecode);\npublic static String getClassPath();\npublic static String getClassPath(boolean isEncoded);\npublic static URL getClassPathURL();\npublic static URL getResourceURL(String resource) throws IORuntimeException;\npublic static List<URL> getResources(String resource);\npublic static URL getResourceUrl(String resource, Class<?> baseClass);\npublic static String[] getJavaClassPaths();\npublic static ClassLoader getContextClassLoader();\npublic static ClassLoader getClassLoader();\npublic static boolean isAllAssignableFrom(Class<?>[] types1, Class<?>[] types2);\npublic static Class<T> loadClass(String className, boolean isInitialized);\npublic static Class<T> loadClass(String className);\npublic static T invoke(String classNameWithMethodName, Object[] args);\npublic static T invoke(String classNameWithMethodName, boolean isSingleton, Object... args);\npublic static T invoke(String className, String methodName, Object[] args);\npublic static T invoke(String className, String methodName, boolean isSingleton, Object... args);\npublic static boolean isPrimitiveWrapper(Class<?> clazz);\npublic static boolean isBasicType(Class<?> clazz);\npublic static boolean isSimpleTypeOrArray(Class<?> clazz);\npublic static boolean isSimpleValueType(Class<?> clazz);\npublic static boolean isAssignable(Class<?> targetType, Class<?> sourceType);\npublic static boolean isPublic(Class<?> clazz);\npublic static boolean isPublic(Method method);\npublic static boolean isNotPublic(Class<?> clazz);\npublic static boolean isNotPublic(Method method);\npublic static boolean isStatic(Method method);\npublic static Method setAccessible(Method method);\npublic static boolean isAbstract(Class<?> clazz);\npublic static boolean isNormalClass(Class<?> clazz);\npublic static boolean isEnum(Class<?> clazz);\npublic static Class<?> getTypeArgument(Class<?> clazz);\npublic static Class<?> getTypeArgument(Class<?> clazz, int index);\npublic static String getPackage(Class<?> clazz);\npublic static String getPackagePath(Class<?> clazz);\npublic static Object getDefaultValue(Class<?> clazz);\npublic static Object getPrimitiveDefaultValue(Class<?> clazz);\npublic static Object[] getDefaultValues(Class<?>... classes);\npublic static boolean isJdkClass(Class<?> clazz);\npublic static URL getLocation(Class<?> clazz);\npublic static String getLocationPath(Class<?> clazz);\npublic static boolean isAbstractOrInterface(Class<?> clazz);\npublic static boolean isInterface(Class<?> clazz);",
        "Class_name": "ClassUtil",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/util/ClassUtil###getClassName",
        "Parameter_num": "2",
        "all_Import_statements": "import cn.hutool.core.bean.NullWrapperBean;\n\nimport cn.hutool.core.convert.BasicType;\n\nimport cn.hutool.core.exceptions.UtilException;\n\nimport cn.hutool.core.io.FileUtil;\n\nimport cn.hutool.core.io.IORuntimeException;\n\nimport cn.hutool.core.io.resource.ResourceUtil;\n\nimport cn.hutool.core.lang.Assert;\n\nimport cn.hutool.core.lang.ClassScanner;\n\nimport cn.hutool.core.lang.Filter;\n\nimport cn.hutool.core.lang.Singleton;\n\nimport java.io.IOException;\n\nimport java.lang.annotation.Annotation;\n\nimport java.lang.reflect.Field;\n\nimport java.lang.reflect.Method;\n\nimport java.lang.reflect.Modifier;\n\nimport java.lang.reflect.Type;\n\nimport java.net.URI;\n\nimport java.net.URL;\n\nimport java.time.temporal.TemporalAccessor;\n\nimport java.util.Date;\n\nimport java.util.Enumeration;\n\nimport java.util.HashSet;\n\nimport java.util.List;\n\nimport java.util.Locale;\n\nimport java.util.Set;\n",
        "comment": "\n\t * 获取类名\n\t *\n\t * @param obj      获取类名对象\n\t * @param isSimple 是否简单类名，如果为true，返回不带包名的类名\n\t * @return 类名\n\t * @since 3.0.7\n\t ",
        "packageName": "cn.hutool.core.util",
        "method_signature": "public static String getClassName(Object obj, boolean isSimple);",
        "Junit_version": "5",
        "returnType": "String"
    },
    {
        "Method_body": "@SuppressWarnings(\"unchecked\")\npublic static <E, T extends Collection<E>> T empty(Class<?> collectionClass) {\n    if (null == collectionClass) {\n        return (T) Collections.emptyList();\n    }\n    if (Set.class.isAssignableFrom(collectionClass)) {\n        if (NavigableSet.class == collectionClass) {\n            return (T) Collections.emptyNavigableSet();\n        } else if (SortedSet.class == collectionClass) {\n            return (T) Collections.emptySortedSet();\n        } else {\n            return (T) Collections.emptySet();\n        }\n    } else if (List.class.isAssignableFrom(collectionClass)) {\n        return (T) Collections.emptyList();\n    }\n    throw new IllegalArgumentException(StrUtil.format(\"[{}] is not support to get empty!\", collectionClass));\n}",
        "all_field_declaration": "",
        "sub_project_name": "hutool-core",
        "lineNumbers": "3",
        "Filed": "",
        "Parameter_type": "Class<?>",
        "Import_statements": "",
        "public_method_signature": "public static Set<T> emptyIfNull(Set<T> set);\npublic static List<T> emptyIfNull(List<T> list);\npublic static Collection<T> union(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> union(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Set<T> unionDistinct(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static List<T> unionAll(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Collection<T> intersection(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> intersection(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Set<T> intersectionDistinct(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Collection<T> disjunction(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> subtract(Collection<T> coll1, Collection<T> coll2);\npublic static List<T> subtractToList(Collection<T> coll1, Collection<T> coll2);\npublic static boolean contains(Collection<?> collection, Object value);\npublic static boolean safeContains(Collection<?> collection, Object value);\npublic static boolean contains(Collection<T> collection, Predicate<? super T> containFunc);\npublic static boolean containsAny(Collection<?> coll1, Collection<?> coll2);\npublic static boolean containsAll(Collection<?> coll1, Collection<?> coll2);\npublic static Map<T, Integer> countMap(Iterable<T> collection);\npublic static String join(Iterable<T> iterable, CharSequence conjunction, Function<T, ? extends CharSequence> func);\npublic static String join(Iterable<T> iterable, CharSequence conjunction);\npublic static String join(Iterable<T> iterable, CharSequence conjunction, String prefix, String suffix);\npublic static String join(Iterator<T> iterator, CharSequence conjunction);\npublic static List<T> popPart(Stack<T> surplusAlaDatas, int partSize);\npublic static List<T> popPart(Deque<T> surplusAlaDatas, int partSize);\npublic static HashSet<T> newHashSet(T... ts);\npublic static LinkedHashSet<T> newLinkedHashSet(T... ts);\npublic static HashSet<T> set(boolean isSorted, T... ts);\npublic static HashSet<T> newHashSet(Collection<T> collection);\npublic static HashSet<T> newHashSet(boolean isSorted, Collection<T> collection);\npublic static HashSet<T> newHashSet(boolean isSorted, Iterator<T> iter);\npublic static HashSet<T> newHashSet(boolean isSorted, Enumeration<T> enumeration);\npublic static List<T> list(boolean isLinked);\npublic static List<T> list(boolean isLinked, T... values);\npublic static List<T> list(boolean isLinked, Collection<T> collection);\npublic static List<T> list(boolean isLinked, Iterable<T> iterable);\npublic static List<T> list(boolean isLinked, Iterator<T> iter);\npublic static List<T> list(boolean isLinked, Enumeration<T> enumeration);\npublic static ArrayList<T> newArrayList(T... values);\npublic static ArrayList<T> toList(T... values);\npublic static ArrayList<T> newArrayList(Collection<T> collection);\npublic static ArrayList<T> newArrayList(Iterable<T> iterable);\npublic static ArrayList<T> newArrayList(Iterator<T> iterator);\npublic static ArrayList<T> newArrayList(Enumeration<T> enumeration);\npublic static LinkedList<T> newLinkedList(T... values);\npublic static CopyOnWriteArrayList<T> newCopyOnWriteArrayList(Collection<T> collection);\npublic static BlockingQueue<T> newBlockingQueue(int capacity, boolean isLinked);\npublic static Collection<T> create(Class<?> collectionType);\npublic static Collection<T> create(Class<?> collectionType, Class<T> elementType);\npublic static ArrayList<T> distinct(Collection<T> collection);\npublic static List<T> distinct(Collection<T> collection, Function<T, K> uniqueGenerator, boolean override);\npublic static List<T> sub(List<T> list, int start, int end);\npublic static List<T> sub(List<T> list, int start, int end, int step);\npublic static List<T> sub(Collection<T> collection, int start, int end);\npublic static List<T> sub(Collection<T> collection, int start, int end, int step);\npublic static List<List<T>> splitList(List<T> list, int size);\npublic static List<List<T>> split(Collection<T> collection, int size);\npublic static Collection<T> edit(Collection<T> collection, Editor<T> editor);\npublic static Collection<T> filterNew(Collection<T> collection, Filter<T> filter);\npublic static T removeAny(T collection, E... elesRemoved);\npublic static T filter(T collection, final Filter<E> filter);\npublic static T removeNull(T collection);\npublic static T removeEmpty(T collection);\npublic static T removeBlank(T collection);\npublic static T removeWithAddIf(T targetCollection, T resultCollection, Predicate<? super E> predicate);\npublic static List<E> removeWithAddIf(T targetCollection, Predicate<? super E> predicate);\npublic static List<Object> extract(Iterable<?> collection, Editor<Object> editor);\npublic static List<Object> extract(Iterable<?> collection, Editor<Object> editor, boolean ignoreNull);\npublic static List<R> map(Iterable<T> collection, Function<? super T, ? extends R> func, boolean ignoreNull);\npublic static List<Object> getFieldValues(Iterable<?> collection, final String fieldName);\npublic static List<Object> getFieldValues(Iterable<?> collection, final String fieldName, boolean ignoreNull);\npublic static List<T> getFieldValues(Iterable<?> collection, final String fieldName, final Class<T> elementType);\npublic static Map<K, V> fieldValueMap(Iterable<V> iterable, String fieldName);\npublic static Map<K, V> fieldValueAsMap(Iterable<?> iterable, String fieldNameForKey, String fieldNameForValue);\npublic static T findOne(Iterable<T> collection, Filter<T> filter);\npublic static T findOneByField(Iterable<T> collection, final String fieldName, final Object fieldValue);\npublic static int count(Iterable<T> iterable, Matcher<T> matcher);\npublic static int indexOf(Collection<T> collection, Matcher<T> matcher);\npublic static int lastIndexOf(Collection<T> collection, Matcher<T> matcher);\npublic static int[] indexOfAll(Collection<T> collection, Matcher<T> matcher);\npublic static boolean isEmpty(Collection<?> collection);\npublic static T defaultIfEmpty(T collection, T defaultCollection);\npublic static T defaultIfEmpty(T collection, Supplier<? extends T> supplier);\npublic static boolean isEmpty(Iterable<?> iterable);\npublic static boolean isEmpty(Iterator<?> Iterator);\npublic static boolean isEmpty(Enumeration<?> enumeration);\npublic static boolean isEmpty(Map<?, ?> map);\npublic static boolean isNotEmpty(Collection<?> collection);\npublic static boolean isNotEmpty(Iterable<?> iterable);\npublic static boolean isNotEmpty(Iterator<?> Iterator);\npublic static boolean isNotEmpty(Enumeration<?> enumeration);\npublic static boolean hasNull(Iterable<?> iterable);\npublic static boolean isNotEmpty(Map<?, ?> map);\npublic static Map<String, String> zip(String keys, String values, String delimiter, boolean isOrder);\npublic static Map<String, String> zip(String keys, String values, String delimiter);\npublic static Map<K, V> zip(Collection<K> keys, Collection<V> values);\npublic static HashMap<K, V> toMap(Iterable<Entry<K, V>> entryIter);\npublic static HashMap<Object, Object> toMap(Object[] array);\npublic static TreeSet<T> toTreeSet(Collection<T> collection, Comparator<T> comparator);\npublic static Enumeration<E> asEnumeration(Iterator<E> iter);\npublic static Iterator<E> asIterator(Enumeration<E> e);\npublic static Iterable<E> asIterable(final Iterator<E> iter);\npublic static Collection<E> toCollection(Iterable<E> iterable);\npublic static Map<K, List<V>> toListMap(Iterable<? extends Map<K, V>> mapList);\npublic static List<Map<K, V>> toMapList(Map<K, ? extends Iterable<V>> listMap);\npublic static Map<K, V> toMap(Iterable<V> values, Map<K, V> map, Func1<V, K> keyFunc);\npublic static Map<K, V> toMap(Iterable<E> values, Map<K, V> map, Func1<E, K> keyFunc, Func1<E, V> valueFunc);\npublic static boolean addIfAbsent(Collection<T> collection, S object);\npublic static Collection<T> addAll(Collection<T> collection, Object value);\npublic static Collection<T> addAll(Collection<T> collection, Object value, Type elementType);\npublic static Collection<T> addAll(Collection<T> collection, Iterator<T> iterator);\npublic static Collection<T> addAll(Collection<T> collection, Iterable<T> iterable);\npublic static Collection<T> addAll(Collection<T> collection, Enumeration<T> enumeration);\npublic static Collection<T> addAll(Collection<T> collection, T[] values);\npublic static List<T> addAllIfNotContains(List<T> list, List<T> otherList);\npublic static T get(Collection<T> collection, int index);\npublic static List<T> getAny(Collection<T> collection, int... indexes);\npublic static T getFirst(Iterable<T> iterable);\npublic static T getFirst(Iterator<T> iterator);\npublic static T getLast(Collection<T> collection);\npublic static Class<?> getElementType(Iterable<?> iterable);\npublic static Class<?> getElementType(Iterator<?> iterator);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, K... keys);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, Iterable<K> keys);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, Iterator<K> keys);\npublic static List<T> sortPageAll(int pageNo, int pageSize, Comparator<T> comparator, Collection<T>... colls);\npublic static List<T> page(int pageNo, int pageSize, List<T> list);\npublic static List<T> sort(Collection<T> collection, Comparator<? super T> comparator);\npublic static List<T> sort(List<T> list, Comparator<? super T> c);\npublic static List<T> sortByProperty(Collection<T> collection, String property);\npublic static List<T> sortByProperty(List<T> list, String property);\npublic static List<String> sortByPinyin(Collection<String> collection);\npublic static List<String> sortByPinyin(List<String> list);\npublic static TreeMap<K, V> sort(Map<K, V> map, Comparator<? super K> comparator);\npublic static LinkedHashMap<K, V> sortToMap(Collection<Map.Entry<K, V>> entryCollection, Comparator<Map.Entry<K, V>> comparator);\npublic static LinkedHashMap<K, V> sortByEntry(Map<K, V> map, Comparator<Map.Entry<K, V>> comparator);\npublic static List<Entry<K, V>> sortEntryToList(Collection<Entry<K, V>> collection);\npublic static void forEach(Iterable<T> iterable, Consumer<T> consumer);\npublic static void forEach(Iterator<T> iterator, Consumer<T> consumer);\npublic static void forEach(Enumeration<T> enumeration, Consumer<T> consumer);\npublic static void forEach(Map<K, V> map, KVConsumer<K, V> kvConsumer);\npublic static List<List<T>> group(Collection<T> collection, Hash32<T> hash);\npublic static List<List<T>> groupByField(Collection<T> collection, final String fieldName);\npublic static List<T> reverse(List<T> list);\npublic static List<T> reverseNew(List<T> list);\npublic static List<T> setOrAppend(List<T> list, int index, T element);\npublic static Set<K> keySet(Collection<Map<K, ?>> mapCollection);\npublic static List<V> values(Collection<Map<?, V>> mapCollection);\npublic static T max(Collection<T> coll);\npublic static T min(Collection<T> coll);\npublic static Collection<T> unmodifiable(Collection<? extends T> c);\npublic static T empty(Class<?> collectionClass);\npublic static void clear(Collection<?>... collections);\npublic static void padLeft(List<T> list, int minLen, T padObj);\npublic static void padRight(Collection<T> list, int minLen, T padObj);\npublic static Collection<T> trans(Collection<F> collection, Function<? super F, ? extends T> function);\npublic static void setValueByMap(Iterable<E> iterable, Map<K, V> map, Function<E, K> keyGenerate, BiConsumer<E, V> biConsumer);\npublic static int size(final Object object);\npublic static boolean isEqualList(final Collection<?> list1, final Collection<?> list2);",
        "public_field": "",
        "Method_statement": "empty(Class<?> collectionClass)",
        "Method_name": "empty",
        "Class_declaration": "public class CollUtil {\n",
        "constructors": "",
        "all_method_signature": "public static Set<T> emptyIfNull(Set<T> set);\npublic static List<T> emptyIfNull(List<T> list);\npublic static Collection<T> union(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> union(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Set<T> unionDistinct(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static List<T> unionAll(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Collection<T> intersection(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> intersection(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Set<T> intersectionDistinct(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Collection<T> disjunction(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> subtract(Collection<T> coll1, Collection<T> coll2);\npublic static List<T> subtractToList(Collection<T> coll1, Collection<T> coll2);\npublic static boolean contains(Collection<?> collection, Object value);\npublic static boolean safeContains(Collection<?> collection, Object value);\npublic static boolean contains(Collection<T> collection, Predicate<? super T> containFunc);\npublic static boolean containsAny(Collection<?> coll1, Collection<?> coll2);\npublic static boolean containsAll(Collection<?> coll1, Collection<?> coll2);\npublic static Map<T, Integer> countMap(Iterable<T> collection);\npublic static String join(Iterable<T> iterable, CharSequence conjunction, Function<T, ? extends CharSequence> func);\npublic static String join(Iterable<T> iterable, CharSequence conjunction);\npublic static String join(Iterable<T> iterable, CharSequence conjunction, String prefix, String suffix);\npublic static String join(Iterator<T> iterator, CharSequence conjunction);\npublic static List<T> popPart(Stack<T> surplusAlaDatas, int partSize);\npublic static List<T> popPart(Deque<T> surplusAlaDatas, int partSize);\npublic static HashSet<T> newHashSet(T... ts);\npublic static LinkedHashSet<T> newLinkedHashSet(T... ts);\npublic static HashSet<T> set(boolean isSorted, T... ts);\npublic static HashSet<T> newHashSet(Collection<T> collection);\npublic static HashSet<T> newHashSet(boolean isSorted, Collection<T> collection);\npublic static HashSet<T> newHashSet(boolean isSorted, Iterator<T> iter);\npublic static HashSet<T> newHashSet(boolean isSorted, Enumeration<T> enumeration);\npublic static List<T> list(boolean isLinked);\npublic static List<T> list(boolean isLinked, T... values);\npublic static List<T> list(boolean isLinked, Collection<T> collection);\npublic static List<T> list(boolean isLinked, Iterable<T> iterable);\npublic static List<T> list(boolean isLinked, Iterator<T> iter);\npublic static List<T> list(boolean isLinked, Enumeration<T> enumeration);\npublic static ArrayList<T> newArrayList(T... values);\npublic static ArrayList<T> toList(T... values);\npublic static ArrayList<T> newArrayList(Collection<T> collection);\npublic static ArrayList<T> newArrayList(Iterable<T> iterable);\npublic static ArrayList<T> newArrayList(Iterator<T> iterator);\npublic static ArrayList<T> newArrayList(Enumeration<T> enumeration);\npublic static LinkedList<T> newLinkedList(T... values);\npublic static CopyOnWriteArrayList<T> newCopyOnWriteArrayList(Collection<T> collection);\npublic static BlockingQueue<T> newBlockingQueue(int capacity, boolean isLinked);\npublic static Collection<T> create(Class<?> collectionType);\npublic static Collection<T> create(Class<?> collectionType, Class<T> elementType);\npublic static ArrayList<T> distinct(Collection<T> collection);\npublic static List<T> distinct(Collection<T> collection, Function<T, K> uniqueGenerator, boolean override);\npublic static List<T> sub(List<T> list, int start, int end);\npublic static List<T> sub(List<T> list, int start, int end, int step);\npublic static List<T> sub(Collection<T> collection, int start, int end);\npublic static List<T> sub(Collection<T> collection, int start, int end, int step);\npublic static List<List<T>> splitList(List<T> list, int size);\npublic static List<List<T>> split(Collection<T> collection, int size);\npublic static Collection<T> edit(Collection<T> collection, Editor<T> editor);\npublic static Collection<T> filterNew(Collection<T> collection, Filter<T> filter);\npublic static T removeAny(T collection, E... elesRemoved);\npublic static T filter(T collection, final Filter<E> filter);\npublic static T removeNull(T collection);\npublic static T removeEmpty(T collection);\npublic static T removeBlank(T collection);\npublic static T removeWithAddIf(T targetCollection, T resultCollection, Predicate<? super E> predicate);\npublic static List<E> removeWithAddIf(T targetCollection, Predicate<? super E> predicate);\npublic static List<Object> extract(Iterable<?> collection, Editor<Object> editor);\npublic static List<Object> extract(Iterable<?> collection, Editor<Object> editor, boolean ignoreNull);\npublic static List<R> map(Iterable<T> collection, Function<? super T, ? extends R> func, boolean ignoreNull);\npublic static List<Object> getFieldValues(Iterable<?> collection, final String fieldName);\npublic static List<Object> getFieldValues(Iterable<?> collection, final String fieldName, boolean ignoreNull);\npublic static List<T> getFieldValues(Iterable<?> collection, final String fieldName, final Class<T> elementType);\npublic static Map<K, V> fieldValueMap(Iterable<V> iterable, String fieldName);\npublic static Map<K, V> fieldValueAsMap(Iterable<?> iterable, String fieldNameForKey, String fieldNameForValue);\npublic static T findOne(Iterable<T> collection, Filter<T> filter);\npublic static T findOneByField(Iterable<T> collection, final String fieldName, final Object fieldValue);\npublic static int count(Iterable<T> iterable, Matcher<T> matcher);\npublic static int indexOf(Collection<T> collection, Matcher<T> matcher);\npublic static int lastIndexOf(Collection<T> collection, Matcher<T> matcher);\npublic static int[] indexOfAll(Collection<T> collection, Matcher<T> matcher);\npublic static boolean isEmpty(Collection<?> collection);\npublic static T defaultIfEmpty(T collection, T defaultCollection);\npublic static T defaultIfEmpty(T collection, Supplier<? extends T> supplier);\npublic static boolean isEmpty(Iterable<?> iterable);\npublic static boolean isEmpty(Iterator<?> Iterator);\npublic static boolean isEmpty(Enumeration<?> enumeration);\npublic static boolean isEmpty(Map<?, ?> map);\npublic static boolean isNotEmpty(Collection<?> collection);\npublic static boolean isNotEmpty(Iterable<?> iterable);\npublic static boolean isNotEmpty(Iterator<?> Iterator);\npublic static boolean isNotEmpty(Enumeration<?> enumeration);\npublic static boolean hasNull(Iterable<?> iterable);\npublic static boolean isNotEmpty(Map<?, ?> map);\npublic static Map<String, String> zip(String keys, String values, String delimiter, boolean isOrder);\npublic static Map<String, String> zip(String keys, String values, String delimiter);\npublic static Map<K, V> zip(Collection<K> keys, Collection<V> values);\npublic static HashMap<K, V> toMap(Iterable<Entry<K, V>> entryIter);\npublic static HashMap<Object, Object> toMap(Object[] array);\npublic static TreeSet<T> toTreeSet(Collection<T> collection, Comparator<T> comparator);\npublic static Enumeration<E> asEnumeration(Iterator<E> iter);\npublic static Iterator<E> asIterator(Enumeration<E> e);\npublic static Iterable<E> asIterable(final Iterator<E> iter);\npublic static Collection<E> toCollection(Iterable<E> iterable);\npublic static Map<K, List<V>> toListMap(Iterable<? extends Map<K, V>> mapList);\npublic static List<Map<K, V>> toMapList(Map<K, ? extends Iterable<V>> listMap);\npublic static Map<K, V> toMap(Iterable<V> values, Map<K, V> map, Func1<V, K> keyFunc);\npublic static Map<K, V> toMap(Iterable<E> values, Map<K, V> map, Func1<E, K> keyFunc, Func1<E, V> valueFunc);\npublic static boolean addIfAbsent(Collection<T> collection, S object);\npublic static Collection<T> addAll(Collection<T> collection, Object value);\npublic static Collection<T> addAll(Collection<T> collection, Object value, Type elementType);\npublic static Collection<T> addAll(Collection<T> collection, Iterator<T> iterator);\npublic static Collection<T> addAll(Collection<T> collection, Iterable<T> iterable);\npublic static Collection<T> addAll(Collection<T> collection, Enumeration<T> enumeration);\npublic static Collection<T> addAll(Collection<T> collection, T[] values);\npublic static List<T> addAllIfNotContains(List<T> list, List<T> otherList);\npublic static T get(Collection<T> collection, int index);\npublic static List<T> getAny(Collection<T> collection, int... indexes);\npublic static T getFirst(Iterable<T> iterable);\npublic static T getFirst(Iterator<T> iterator);\npublic static T getLast(Collection<T> collection);\npublic static Class<?> getElementType(Iterable<?> iterable);\npublic static Class<?> getElementType(Iterator<?> iterator);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, K... keys);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, Iterable<K> keys);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, Iterator<K> keys);\npublic static List<T> sortPageAll(int pageNo, int pageSize, Comparator<T> comparator, Collection<T>... colls);\npublic static List<T> page(int pageNo, int pageSize, List<T> list);\npublic static List<T> sort(Collection<T> collection, Comparator<? super T> comparator);\npublic static List<T> sort(List<T> list, Comparator<? super T> c);\npublic static List<T> sortByProperty(Collection<T> collection, String property);\npublic static List<T> sortByProperty(List<T> list, String property);\npublic static List<String> sortByPinyin(Collection<String> collection);\npublic static List<String> sortByPinyin(List<String> list);\npublic static TreeMap<K, V> sort(Map<K, V> map, Comparator<? super K> comparator);\npublic static LinkedHashMap<K, V> sortToMap(Collection<Map.Entry<K, V>> entryCollection, Comparator<Map.Entry<K, V>> comparator);\npublic static LinkedHashMap<K, V> sortByEntry(Map<K, V> map, Comparator<Map.Entry<K, V>> comparator);\npublic static List<Entry<K, V>> sortEntryToList(Collection<Entry<K, V>> collection);\npublic static void forEach(Iterable<T> iterable, Consumer<T> consumer);\npublic static void forEach(Iterator<T> iterator, Consumer<T> consumer);\npublic static void forEach(Enumeration<T> enumeration, Consumer<T> consumer);\npublic static void forEach(Map<K, V> map, KVConsumer<K, V> kvConsumer);\npublic static List<List<T>> group(Collection<T> collection, Hash32<T> hash);\npublic static List<List<T>> groupByField(Collection<T> collection, final String fieldName);\npublic static List<T> reverse(List<T> list);\npublic static List<T> reverseNew(List<T> list);\npublic static List<T> setOrAppend(List<T> list, int index, T element);\npublic static Set<K> keySet(Collection<Map<K, ?>> mapCollection);\npublic static List<V> values(Collection<Map<?, V>> mapCollection);\npublic static T max(Collection<T> coll);\npublic static T min(Collection<T> coll);\npublic static Collection<T> unmodifiable(Collection<? extends T> c);\npublic static T empty(Class<?> collectionClass);\npublic static void clear(Collection<?>... collections);\npublic static void padLeft(List<T> list, int minLen, T padObj);\npublic static void padRight(Collection<T> list, int minLen, T padObj);\npublic static Collection<T> trans(Collection<F> collection, Function<? super F, ? extends T> function);\npublic static void setValueByMap(Iterable<E> iterable, Map<K, V> map, Function<E, K> keyGenerate, BiConsumer<E, V> biConsumer);\npublic static int size(final Object object);\npublic static boolean isEqualList(final Collection<?> list1, final Collection<?> list2);",
        "Class_name": "CollUtil",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/collection/CollUtil###empty",
        "Parameter_num": "1",
        "all_Import_statements": "import cn.hutool.core.bean.BeanUtil;\n\nimport cn.hutool.core.comparator.CompareUtil;\n\nimport cn.hutool.core.comparator.PinyinComparator;\n\nimport cn.hutool.core.comparator.PropertyComparator;\n\nimport cn.hutool.core.convert.Convert;\n\nimport cn.hutool.core.convert.ConverterRegistry;\n\nimport cn.hutool.core.exceptions.UtilException;\n\nimport cn.hutool.core.lang.Assert;\n\nimport cn.hutool.core.lang.Editor;\n\nimport cn.hutool.core.lang.Filter;\n\nimport cn.hutool.core.lang.Matcher;\n\nimport cn.hutool.core.lang.func.Func1;\n\nimport cn.hutool.core.lang.hash.Hash32;\n\nimport cn.hutool.core.map.MapUtil;\n\nimport cn.hutool.core.util.*;\n\nimport java.io.Serializable;\n\nimport java.lang.reflect.Type;\n\nimport java.util.*;\n\nimport java.util.Map.Entry;\n\nimport java.util.concurrent.ArrayBlockingQueue;\n\nimport java.util.concurrent.BlockingQueue;\n\nimport java.util.concurrent.CopyOnWriteArrayList;\n\nimport java.util.concurrent.LinkedBlockingDeque;\n\nimport java.util.function.BiConsumer;\n\nimport java.util.function.Function;\n\nimport java.util.function.Predicate;\n\nimport java.util.function.Supplier;\n",
        "comment": "\n\t * 根据给定的集合类型，返回对应的空集合，支持类型包括：\n\t * *\n\t * <pre>\n\t *     1. NavigableSet\n\t *     2. SortedSet\n\t *     3. Set\n\t *     4. List\n\t * </pre>\n\t *\n\t * @param <E>             元素类型\n\t * @param <T>             集合类型\n\t * @param collectionClass 集合类型\n\t * @return 空集合\n\t * @since 5.3.1\n\t ",
        "packageName": "cn.hutool.core.collection",
        "method_signature": "public static T empty(Class<?> collectionClass);",
        "Junit_version": "5",
        "returnType": "T"
    },
    {
        "Method_body": "public static Coordinate bd09ToGcj02(double lng, double lat) {\n    double x = lng - 0.0065;\n    double y = lat - 0.006;\n    double z = Math.sqrt(x * x + y * y) - 0.00002 * Math.sin(y * X_PI);\n    double theta = Math.atan2(y, x) - 0.000003 * Math.cos(x * X_PI);\n    double gg_lng = z * Math.cos(theta);\n    double gg_lat = z * Math.sin(theta);\n    return new Coordinate(gg_lng, gg_lat);\n}",
        "all_field_declaration": "/**\n * 坐标转换参数：(火星坐标系与百度坐标系转换的中间量)\n */\npublic static final double X_PI = 3.1415926535897932384626433832795 * 3000.0 / 180.0;\n/**\n * 坐标转换参数：π\n */\npublic static final double PI = 3.1415926535897932384626433832795D;\n/**\n * 地球半径（Krasovsky 1940）\n */\npublic static final double RADIUS = 6378245.0D;\n/**\n * 修正参数（偏率ee）\n */\npublic static final double CORRECTION_PARAM = 0.00669342162296594323D;",
        "sub_project_name": "hutool-core",
        "lineNumbers": "7",
        "Filed": "public static final double X_PI = 3.1415926535897932384626433832795 * 3000.0 / 180.0;public static final double PI = 3.1415926535897932384626433832795D;",
        "Parameter_type": "double,double",
        "Import_statements": "",
        "public_method_signature": "public static boolean outOfChina(double lng, double lat);\npublic static Coordinate wgs84ToGcj02(double lng, double lat);\npublic static Coordinate wgs84ToBd09(double lng, double lat);\npublic static Coordinate gcj02ToWgs84(double lng, double lat);\npublic static Coordinate gcj02ToBd09(double lng, double lat);\npublic static Coordinate bd09ToGcj02(double lng, double lat);\npublic static Coordinate bd09toWgs84(double lng, double lat);\npublic static Coordinate wgs84ToMercator(double lng, double lat);\npublic static Coordinate mercatorToWgs84(double mercatorX, double mercatorY);",
        "public_field": "/**\n * 坐标转换参数：(火星坐标系与百度坐标系转换的中间量)\n */\npublic static final double X_PI = 3.1415926535897932384626433832795 * 3000.0 / 180.0;\n/**\n * 坐标转换参数：π\n */\npublic static final double PI = 3.1415926535897932384626433832795D;\n/**\n * 地球半径（Krasovsky 1940）\n */\npublic static final double RADIUS = 6378245.0D;\n/**\n * 修正参数（偏率ee）\n */\npublic static final double CORRECTION_PARAM = 0.00669342162296594323D;",
        "Method_statement": "bd09ToGcj02(double lng, double lat)",
        "Method_name": "bd09ToGcj02",
        "Class_declaration": "public class CoordinateUtil {\n",
        "constructors": "",
        "all_method_signature": "public static boolean outOfChina(double lng, double lat);\npublic static Coordinate wgs84ToGcj02(double lng, double lat);\npublic static Coordinate wgs84ToBd09(double lng, double lat);\npublic static Coordinate gcj02ToWgs84(double lng, double lat);\npublic static Coordinate gcj02ToBd09(double lng, double lat);\npublic static Coordinate bd09ToGcj02(double lng, double lat);\npublic static Coordinate bd09toWgs84(double lng, double lat);\npublic static Coordinate wgs84ToMercator(double lng, double lat);\npublic static Coordinate mercatorToWgs84(double mercatorX, double mercatorY);\nprivate static Coordinate offset(double lng, double lat, boolean isPlus);\nprivate static double transLng(double lng, double lat);\nprivate static double transLat(double lng, double lat);",
        "Class_name": "CoordinateUtil",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/util/CoordinateUtil###bd09ToGcj02",
        "Parameter_num": "2",
        "all_Import_statements": "import java.io.Serializable;\n\nimport java.util.Objects;\n",
        "comment": "\n\t * 百度坐标系 (BD-09) 与 火星坐标系 (GCJ-02)的转换\n\t * 即 百度 转 谷歌、高德\n\t *\n\t * @param lng 经度值\n\t * @param lat 纬度值\n\t * @return GCJ-02 坐标\n\t ",
        "packageName": "cn.hutool.core.util",
        "method_signature": "public static Coordinate bd09ToGcj02(double lng, double lat);",
        "Junit_version": "5",
        "returnType": "Coordinate"
    },
    {
        "Method_body": "public static String readLine(ByteBuffer buffer, Charset charset) {\n    final int startPosition = buffer.position();\n    final int endPosition = lineEnd(buffer);\n    if (endPosition > startPosition) {\n        byte[] bs = readBytes(buffer, startPosition, endPosition);\n        return StrUtil.str(bs, charset);\n    } else if (endPosition == startPosition) {\n        return StrUtil.EMPTY;\n    }\n    return null;\n}",
        "all_field_declaration": "",
        "sub_project_name": "hutool-core",
        "lineNumbers": "4",
        "Filed": "",
        "Parameter_type": "ByteBuffer,Charset",
        "Import_statements": "import cn.hutool.core.util.StrUtil;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\n",
        "public_method_signature": "public static ByteBuffer copy(ByteBuffer src, int start, int end);\npublic static ByteBuffer copy(ByteBuffer src, ByteBuffer dest);\npublic static ByteBuffer copy(ByteBuffer src, ByteBuffer dest, int length);\npublic static ByteBuffer copy(ByteBuffer src, int srcStart, ByteBuffer dest, int destStart, int length);\npublic static String readUtf8Str(ByteBuffer buffer);\npublic static String readStr(ByteBuffer buffer, Charset charset);\npublic static byte[] readBytes(ByteBuffer buffer);\npublic static byte[] readBytes(ByteBuffer buffer, int maxLength);\npublic static byte[] readBytes(ByteBuffer buffer, int start, int end);\npublic static int lineEnd(ByteBuffer buffer);\npublic static int lineEnd(ByteBuffer buffer, int maxLength);\npublic static String readLine(ByteBuffer buffer, Charset charset);\npublic static ByteBuffer create(byte[] data);\npublic static ByteBuffer create(CharSequence data, Charset charset);\npublic static ByteBuffer createUtf8(CharSequence data);\npublic static CharBuffer createCharBuffer(int capacity);",
        "public_field": "",
        "Method_statement": "readLine(ByteBuffer buffer, Charset charset)",
        "Method_name": "readLine",
        "Class_declaration": "public class BufferUtil {\n",
        "constructors": "",
        "all_method_signature": "public static ByteBuffer copy(ByteBuffer src, int start, int end);\npublic static ByteBuffer copy(ByteBuffer src, ByteBuffer dest);\npublic static ByteBuffer copy(ByteBuffer src, ByteBuffer dest, int length);\npublic static ByteBuffer copy(ByteBuffer src, int srcStart, ByteBuffer dest, int destStart, int length);\npublic static String readUtf8Str(ByteBuffer buffer);\npublic static String readStr(ByteBuffer buffer, Charset charset);\npublic static byte[] readBytes(ByteBuffer buffer);\npublic static byte[] readBytes(ByteBuffer buffer, int maxLength);\npublic static byte[] readBytes(ByteBuffer buffer, int start, int end);\npublic static int lineEnd(ByteBuffer buffer);\npublic static int lineEnd(ByteBuffer buffer, int maxLength);\npublic static String readLine(ByteBuffer buffer, Charset charset);\npublic static ByteBuffer create(byte[] data);\npublic static ByteBuffer create(CharSequence data, Charset charset);\npublic static ByteBuffer createUtf8(CharSequence data);\npublic static CharBuffer createCharBuffer(int capacity);",
        "Class_name": "BufferUtil",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/io/BufferUtil###readLine",
        "Parameter_num": "2",
        "all_Import_statements": "import cn.hutool.core.util.CharsetUtil;\n\nimport cn.hutool.core.util.StrUtil;\n\nimport java.nio.ByteBuffer;\n\nimport java.nio.CharBuffer;\n\nimport java.nio.charset.Charset;\n",
        "comment": "\n\t * 读取一行，如果buffer中最后一部分并非完整一行，则返回null<br>\n\t * 支持的换行符如下：\n\t *\n\t * <pre>\n\t * 1. \\r\\n\n\t * 2. \\n\n\t * </pre>\n\t *\n\t * @param buffer  ByteBuffer\n\t * @param charset 编码\n\t * @return 一行\n\t ",
        "packageName": "cn.hutool.core.io",
        "method_signature": "public static String readLine(ByteBuffer buffer, Charset charset);",
        "Junit_version": "5",
        "returnType": "String"
    },
    {
        "Method_body": "public static CharSequence commonSuffix(CharSequence str1, CharSequence str2) {\n    if (isEmpty(str1) || isEmpty(str2)) {\n        return EMPTY;\n    }\n    int str1Index = str1.length() - 1;\n    int str2Index = str2.length() - 1;\n    for (; str1Index >= 0 && str2Index >= 0; str1Index--, str2Index--) {\n        if (str1.charAt(str1Index) != str2.charAt(str2Index)) {\n            break;\n        }\n    }\n    return str1.subSequence(str1Index + 1, str1.length());\n}",
        "all_field_declaration": "public static final int INDEX_NOT_FOUND = Finder.INDEX_NOT_FOUND;\n/**\n * 字符串常量：{@code \"null\"} <br>\n * 注意：{@code \"null\" != null}\n */\npublic static final String NULL = \"null\";\n/**\n * 字符串常量：空字符串 {@code \"\"}\n */\npublic static final String EMPTY = \"\";\n/**\n * 字符串常量：空格符 {@code \" \"}\n */\npublic static final String SPACE = \" \";",
        "sub_project_name": "hutool-core",
        "lineNumbers": "5",
        "Filed": "public static final String EMPTY = \"\";",
        "Parameter_type": "CharSequence,CharSequence",
        "Import_statements": "",
        "public_method_signature": "public static boolean isBlank(CharSequence str);\npublic static boolean isNotBlank(CharSequence str);\npublic static boolean hasBlank(CharSequence... strs);\npublic static boolean isAllBlank(CharSequence... strs);\npublic static boolean isEmpty(CharSequence str);\npublic static boolean isNotEmpty(CharSequence str);\npublic static String emptyIfNull(CharSequence str);\npublic static String nullToEmpty(CharSequence str);\npublic static String nullToDefault(CharSequence str, String defaultStr);\npublic static String emptyToDefault(CharSequence str, String defaultStr);\npublic static String blankToDefault(CharSequence str, String defaultStr);\npublic static String emptyToNull(CharSequence str);\npublic static boolean hasEmpty(CharSequence... strs);\npublic static boolean isAllEmpty(CharSequence... strs);\npublic static boolean isAllNotEmpty(CharSequence... args);\npublic static boolean isAllNotBlank(CharSequence... args);\npublic static boolean isNullOrUndefined(CharSequence str);\npublic static boolean isEmptyOrUndefined(CharSequence str);\npublic static boolean isBlankOrUndefined(CharSequence str);\npublic static String trim(CharSequence str);\npublic static String trimToEmpty(CharSequence str);\npublic static String trimToNull(CharSequence str);\npublic static String trimStart(CharSequence str);\npublic static String trimEnd(CharSequence str);\npublic static String trim(CharSequence str, int mode);\npublic static String trim(CharSequence str, int mode, Predicate<Character> predicate);\npublic static boolean startWith(CharSequence str, char c);\npublic static boolean startWith(CharSequence str, CharSequence prefix, boolean ignoreCase);\npublic static boolean startWith(CharSequence str, CharSequence prefix, boolean ignoreCase, boolean ignoreEquals);\npublic static boolean startWith(CharSequence str, CharSequence prefix);\npublic static boolean startWithIgnoreEquals(CharSequence str, CharSequence prefix);\npublic static boolean startWithIgnoreCase(CharSequence str, CharSequence prefix);\npublic static boolean startWithAny(CharSequence str, CharSequence... prefixes);\npublic static boolean startWithAnyIgnoreCase(final CharSequence str, final CharSequence... suffixes);\npublic static boolean endWith(CharSequence str, char c);\npublic static boolean endWith(CharSequence str, CharSequence suffix, boolean ignoreCase);\npublic static boolean endWith(CharSequence str, CharSequence suffix, boolean ignoreCase, boolean ignoreEquals);\npublic static boolean endWith(CharSequence str, CharSequence suffix);\npublic static boolean endWithIgnoreCase(CharSequence str, CharSequence suffix);\npublic static boolean endWithAny(CharSequence str, CharSequence... suffixes);\npublic static boolean endWithAnyIgnoreCase(CharSequence str, CharSequence... suffixes);\npublic static boolean contains(CharSequence str, char searchChar);\npublic static boolean contains(CharSequence str, CharSequence searchStr);\npublic static boolean containsAny(CharSequence str, CharSequence... testStrs);\npublic static boolean containsAny(CharSequence str, char... testChars);\npublic static boolean containsOnly(CharSequence str, char... testChars);\npublic static boolean containsAll(CharSequence str, CharSequence... testChars);\npublic static boolean containsBlank(CharSequence str);\npublic static String getContainsStr(CharSequence str, CharSequence... testStrs);\npublic static boolean containsIgnoreCase(CharSequence str, CharSequence testStr);\npublic static boolean containsAnyIgnoreCase(CharSequence str, CharSequence... testStrs);\npublic static String getContainsStrIgnoreCase(CharSequence str, CharSequence... testStrs);\npublic static int indexOf(CharSequence str, char searchChar);\npublic static int indexOf(CharSequence str, char searchChar, int start);\npublic static int indexOf(CharSequence text, char searchChar, int start, int end);\npublic static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr);\npublic static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int fromIndex);\npublic static int indexOf(CharSequence text, CharSequence searchStr, int from, boolean ignoreCase);\npublic static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr);\npublic static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr, int fromIndex);\npublic static int lastIndexOf(CharSequence text, CharSequence searchStr, int from, boolean ignoreCase);\npublic static int ordinalIndexOf(CharSequence str, CharSequence searchStr, int ordinal);\npublic static String removeAll(CharSequence str, CharSequence strToRemove);\npublic static String removeAny(CharSequence str, CharSequence... strsToRemove);\npublic static String removeAll(CharSequence str, char... chars);\npublic static String removeAllLineBreaks(CharSequence str);\npublic static String removePreAndLowerFirst(CharSequence str, int preLength);\npublic static String removePreAndLowerFirst(CharSequence str, CharSequence prefix);\npublic static String removePrefix(CharSequence str, CharSequence prefix);\npublic static String removePrefixIgnoreCase(CharSequence str, CharSequence prefix);\npublic static String removeSuffix(CharSequence str, CharSequence suffix);\npublic static String removeSufAndLowerFirst(CharSequence str, CharSequence suffix);\npublic static String removeSuffixIgnoreCase(CharSequence str, CharSequence suffix);\npublic static String cleanBlank(CharSequence str);\npublic static String strip(CharSequence str, CharSequence prefixOrSuffix);\npublic static String strip(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String stripIgnoreCase(CharSequence str, CharSequence prefixOrSuffix);\npublic static String stripIgnoreCase(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String addPrefixIfNot(CharSequence str, CharSequence prefix);\npublic static String addSuffixIfNot(CharSequence str, CharSequence suffix);\npublic static long[] splitToLong(CharSequence str, char separator);\npublic static long[] splitToLong(CharSequence str, CharSequence separator);\npublic static int[] splitToInt(CharSequence str, char separator);\npublic static int[] splitToInt(CharSequence str, CharSequence separator);\npublic static List<String> split(CharSequence str, char separator);\npublic static String[] splitToArray(CharSequence str, CharSequence separator);\npublic static String[] splitToArray(CharSequence str, char separator);\npublic static String[] splitToArray(CharSequence text, char separator, int limit);\npublic static List<String> split(CharSequence str, char separator, int limit);\npublic static List<String> splitTrim(CharSequence str, char separator);\npublic static List<String> splitTrim(CharSequence str, CharSequence separator);\npublic static List<String> splitTrim(CharSequence str, char separator, int limit);\npublic static List<String> splitTrim(CharSequence str, CharSequence separator, int limit);\npublic static List<String> split(CharSequence str, char separator, boolean isTrim, boolean ignoreEmpty);\npublic static List<String> split(CharSequence str, char separator, int limit, boolean isTrim, boolean ignoreEmpty);\npublic static List<R> split(CharSequence str, char separator, int limit, boolean ignoreEmpty, Function<String, R> mapping);\npublic static List<String> split(CharSequence str, CharSequence separator);\npublic static List<String> split(CharSequence str, CharSequence separator, boolean isTrim, boolean ignoreEmpty);\npublic static List<String> split(CharSequence str, CharSequence separator, int limit, boolean isTrim, boolean ignoreEmpty);\npublic static String[] split(CharSequence str, int len);\npublic static String[] cut(CharSequence str, int partLength);\npublic static String sub(CharSequence str, int fromIndexInclude, int toIndexExclude);\npublic static String subByCodePoint(CharSequence str, int fromIndex, int toIndex);\npublic static String subPreGbk(CharSequence str, int len, CharSequence suffix);\npublic static String subPreGbk(CharSequence str, int len, boolean halfUp);\npublic static String subPre(CharSequence string, int toIndexExclude);\npublic static String subSuf(CharSequence string, int fromIndex);\npublic static String subSufByLength(CharSequence string, int length);\npublic static String subWithLength(String input, int fromIndex, int length);\npublic static String subBefore(CharSequence string, CharSequence separator, boolean isLastSeparator);\npublic static String subBefore(CharSequence string, char separator, boolean isLastSeparator);\npublic static String subAfter(CharSequence string, CharSequence separator, boolean isLastSeparator);\npublic static String subAfter(CharSequence string, char separator, boolean isLastSeparator);\npublic static String subBetween(CharSequence str, CharSequence before, CharSequence after);\npublic static String subBetween(CharSequence str, CharSequence beforeAndAfter);\npublic static String[] subBetweenAll(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String[] subBetweenAll(CharSequence str, CharSequence prefixAndSuffix);\npublic static String repeat(char c, int count);\npublic static String repeat(CharSequence str, int count);\npublic static String repeatByLength(CharSequence str, int padLen);\npublic static String repeatAndJoin(CharSequence str, int count, CharSequence delimiter);\npublic static boolean equals(CharSequence str1, CharSequence str2);\npublic static boolean equalsIgnoreCase(CharSequence str1, CharSequence str2);\npublic static boolean equals(CharSequence str1, CharSequence str2, boolean ignoreCase);\npublic static boolean equalsAnyIgnoreCase(CharSequence str1, CharSequence... strs);\npublic static boolean equalsAny(CharSequence str1, CharSequence... strs);\npublic static boolean equalsAny(CharSequence str1, boolean ignoreCase, CharSequence... strs);\npublic static boolean equalsCharAt(CharSequence str, int position, char c);\npublic static boolean isSubEquals(CharSequence str1, int start1, CharSequence str2, boolean ignoreCase);\npublic static boolean isSubEquals(CharSequence str1, int start1, CharSequence str2, int start2, int length, boolean ignoreCase);\npublic static String format(CharSequence template, Object... params);\npublic static String indexedFormat(CharSequence pattern, Object... arguments);\npublic static byte[] utf8Bytes(CharSequence str);\npublic static byte[] bytes(CharSequence str);\npublic static byte[] bytes(CharSequence str, String charset);\npublic static byte[] bytes(CharSequence str, Charset charset);\npublic static ByteBuffer byteBuffer(CharSequence str, String charset);\npublic static String wrap(CharSequence str, CharSequence prefixAndSuffix);\npublic static String wrap(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String[] wrapAllWithPair(CharSequence prefixAndSuffix, CharSequence... strs);\npublic static String[] wrapAll(CharSequence prefix, CharSequence suffix, CharSequence... strs);\npublic static String wrapIfMissing(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String[] wrapAllWithPairIfMissing(CharSequence prefixAndSuffix, CharSequence... strs);\npublic static String[] wrapAllIfMissing(CharSequence prefix, CharSequence suffix, CharSequence... strs);\npublic static String unWrap(CharSequence str, String prefix, String suffix);\npublic static String unWrap(CharSequence str, char prefix, char suffix);\npublic static String unWrap(CharSequence str, char prefixAndSuffix);\npublic static boolean isWrap(CharSequence str, String prefix, String suffix);\npublic static boolean isWrap(CharSequence str, String wrapper);\npublic static boolean isWrap(CharSequence str, char wrapper);\npublic static boolean isWrap(CharSequence str, char prefixChar, char suffixChar);\npublic static String padPre(CharSequence str, int length, CharSequence padStr);\npublic static String padPre(CharSequence str, int length, char padChar);\npublic static String padAfter(CharSequence str, int length, char padChar);\npublic static String padAfter(CharSequence str, int length, CharSequence padStr);\npublic static String center(CharSequence str, final int size);\npublic static String center(CharSequence str, final int size, char padChar);\npublic static String center(CharSequence str, final int size, CharSequence padStr);\npublic static String str(CharSequence cs);\npublic static int count(CharSequence content, CharSequence strForSearch);\npublic static int count(CharSequence content, char charForSearch);\npublic static int compare(final CharSequence str1, final CharSequence str2, final boolean nullIsLess);\npublic static int compareIgnoreCase(CharSequence str1, CharSequence str2, boolean nullIsLess);\npublic static int compareVersion(CharSequence version1, CharSequence version2);\npublic static String appendIfMissing(CharSequence str, CharSequence suffix, CharSequence... suffixes);\npublic static String appendIfMissingIgnoreCase(CharSequence str, CharSequence suffix, CharSequence... suffixes);\npublic static String appendIfMissing(CharSequence str, CharSequence suffix, boolean ignoreCase, CharSequence... testSuffixes);\npublic static String prependIfMissing(CharSequence str, CharSequence prefix, CharSequence... prefixes);\npublic static String prependIfMissingIgnoreCase(CharSequence str, CharSequence prefix, CharSequence... prefixes);\npublic static String prependIfMissing(CharSequence str, CharSequence prefix, boolean ignoreCase, CharSequence... prefixes);\npublic static String replaceIgnoreCase(CharSequence str, CharSequence searchStr, CharSequence replacement);\npublic static String replace(CharSequence str, CharSequence searchStr, CharSequence replacement);\npublic static String replace(CharSequence str, CharSequence searchStr, CharSequence replacement, boolean ignoreCase);\npublic static String replace(CharSequence str, int fromIndex, CharSequence searchStr, CharSequence replacement, boolean ignoreCase);\npublic static String replace(CharSequence str, int startInclude, int endExclude, char replacedChar);\npublic static String replace(CharSequence str, int startInclude, int endExclude, CharSequence replacedStr);\npublic static String replace(CharSequence str, java.util.regex.Pattern pattern, Func1<java.util.regex.Matcher, String> replaceFun);\npublic static String replace(CharSequence str, String regex, Func1<java.util.regex.Matcher, String> replaceFun);\npublic static String replaceLast(CharSequence str, CharSequence searchStr, CharSequence replacedStr);\npublic static String replaceLast(CharSequence str, CharSequence searchStr, CharSequence replacedStr, boolean ignoreCase);\npublic static String replaceFirst(CharSequence str, CharSequence searchStr, CharSequence replacedStr);\npublic static String replaceFirst(CharSequence str, CharSequence searchStr, CharSequence replacedStr, boolean ignoreCase);\npublic static String hide(CharSequence str, int startInclude, int endExclude);\npublic static String desensitized(CharSequence str, DesensitizedUtil.DesensitizedType desensitizedType);\npublic static String replaceChars(CharSequence str, String chars, CharSequence replacedStr);\npublic static String replaceChars(CharSequence str, char[] chars, CharSequence replacedStr);\npublic static int length(CharSequence cs);\npublic static int byteLength(CharSequence cs, Charset charset);\npublic static int totalLength(CharSequence... strs);\npublic static String maxLength(CharSequence string, int length);\npublic static T firstNonNull(T... strs);\npublic static T firstNonEmpty(T... strs);\npublic static T firstNonBlank(T... strs);\npublic static String upperFirstAndAddPre(CharSequence str, String preString);\npublic static String upperFirst(CharSequence str);\npublic static String lowerFirst(CharSequence str);\npublic static String filter(CharSequence str, final Filter<Character> filter);\npublic static boolean isUpperCase(CharSequence str);\npublic static boolean isLowerCase(CharSequence str);\npublic static String swapCase(final String str);\npublic static String toUnderlineCase(CharSequence str);\npublic static String toSymbolCase(CharSequence str, char symbol);\npublic static String toCamelCase(CharSequence name);\npublic static String toCamelCase(CharSequence name, char symbol);\npublic static boolean isSurround(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static boolean isSurround(CharSequence str, char prefix, char suffix);\npublic static StringBuilder builder(CharSequence... strs);\npublic static StrBuilder strBuilder(CharSequence... strs);\npublic static String getGeneralField(CharSequence getOrSetMethodName);\npublic static String genSetter(CharSequence fieldName);\npublic static String genGetter(CharSequence fieldName);\npublic static String concat(boolean isNullToEmpty, CharSequence... strs);\npublic static String brief(CharSequence str, int maxLength);\npublic static String join(CharSequence conjunction, Object... objs);\npublic static String join(CharSequence conjunction, Iterable<T> iterable);\npublic static boolean isAllCharMatch(CharSequence value, Matcher<Character> matcher);\npublic static boolean isNumeric(CharSequence str);\npublic static String move(CharSequence str, int startInclude, int endExclude, int moveLength);\npublic static boolean isCharEquals(CharSequence str);\npublic static String normalize(CharSequence str);\npublic static String fixLength(CharSequence str, char fixedChar, int length);\npublic static boolean hasLetter(CharSequence str);\npublic static CharSequence commonPrefix(CharSequence str1, CharSequence str2);\npublic static CharSequence commonSuffix(CharSequence str1, CharSequence str2);",
        "public_field": "public static final int INDEX_NOT_FOUND = Finder.INDEX_NOT_FOUND;\n/**\n * 字符串常量：{@code \"null\"} <br>\n * 注意：{@code \"null\" != null}\n */\npublic static final String NULL = \"null\";\n/**\n * 字符串常量：空字符串 {@code \"\"}\n */\npublic static final String EMPTY = \"\";\n/**\n * 字符串常量：空格符 {@code \" \"}\n */\npublic static final String SPACE = \" \";",
        "Method_statement": "commonSuffix(CharSequence str1, CharSequence str2)",
        "Method_name": "commonSuffix",
        "Class_declaration": "public class CharSequenceUtil {\n",
        "constructors": "",
        "all_method_signature": "public static boolean isBlank(CharSequence str);\npublic static boolean isNotBlank(CharSequence str);\npublic static boolean hasBlank(CharSequence... strs);\npublic static boolean isAllBlank(CharSequence... strs);\npublic static boolean isEmpty(CharSequence str);\npublic static boolean isNotEmpty(CharSequence str);\npublic static String emptyIfNull(CharSequence str);\npublic static String nullToEmpty(CharSequence str);\npublic static String nullToDefault(CharSequence str, String defaultStr);\npublic static String emptyToDefault(CharSequence str, String defaultStr);\npublic static String blankToDefault(CharSequence str, String defaultStr);\npublic static String emptyToNull(CharSequence str);\npublic static boolean hasEmpty(CharSequence... strs);\npublic static boolean isAllEmpty(CharSequence... strs);\npublic static boolean isAllNotEmpty(CharSequence... args);\npublic static boolean isAllNotBlank(CharSequence... args);\npublic static boolean isNullOrUndefined(CharSequence str);\npublic static boolean isEmptyOrUndefined(CharSequence str);\npublic static boolean isBlankOrUndefined(CharSequence str);\nprivate static boolean isNullOrUndefinedStr(CharSequence str);\npublic static String trim(CharSequence str);\npublic static String trimToEmpty(CharSequence str);\npublic static String trimToNull(CharSequence str);\npublic static String trimStart(CharSequence str);\npublic static String trimEnd(CharSequence str);\npublic static String trim(CharSequence str, int mode);\npublic static String trim(CharSequence str, int mode, Predicate<Character> predicate);\npublic static boolean startWith(CharSequence str, char c);\npublic static boolean startWith(CharSequence str, CharSequence prefix, boolean ignoreCase);\npublic static boolean startWith(CharSequence str, CharSequence prefix, boolean ignoreCase, boolean ignoreEquals);\npublic static boolean startWith(CharSequence str, CharSequence prefix);\npublic static boolean startWithIgnoreEquals(CharSequence str, CharSequence prefix);\npublic static boolean startWithIgnoreCase(CharSequence str, CharSequence prefix);\npublic static boolean startWithAny(CharSequence str, CharSequence... prefixes);\npublic static boolean startWithAnyIgnoreCase(final CharSequence str, final CharSequence... suffixes);\npublic static boolean endWith(CharSequence str, char c);\npublic static boolean endWith(CharSequence str, CharSequence suffix, boolean ignoreCase);\npublic static boolean endWith(CharSequence str, CharSequence suffix, boolean ignoreCase, boolean ignoreEquals);\npublic static boolean endWith(CharSequence str, CharSequence suffix);\npublic static boolean endWithIgnoreCase(CharSequence str, CharSequence suffix);\npublic static boolean endWithAny(CharSequence str, CharSequence... suffixes);\npublic static boolean endWithAnyIgnoreCase(CharSequence str, CharSequence... suffixes);\npublic static boolean contains(CharSequence str, char searchChar);\npublic static boolean contains(CharSequence str, CharSequence searchStr);\npublic static boolean containsAny(CharSequence str, CharSequence... testStrs);\npublic static boolean containsAny(CharSequence str, char... testChars);\npublic static boolean containsOnly(CharSequence str, char... testChars);\npublic static boolean containsAll(CharSequence str, CharSequence... testChars);\npublic static boolean containsBlank(CharSequence str);\npublic static String getContainsStr(CharSequence str, CharSequence... testStrs);\npublic static boolean containsIgnoreCase(CharSequence str, CharSequence testStr);\npublic static boolean containsAnyIgnoreCase(CharSequence str, CharSequence... testStrs);\npublic static String getContainsStrIgnoreCase(CharSequence str, CharSequence... testStrs);\npublic static int indexOf(CharSequence str, char searchChar);\npublic static int indexOf(CharSequence str, char searchChar, int start);\npublic static int indexOf(CharSequence text, char searchChar, int start, int end);\npublic static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr);\npublic static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int fromIndex);\npublic static int indexOf(CharSequence text, CharSequence searchStr, int from, boolean ignoreCase);\npublic static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr);\npublic static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr, int fromIndex);\npublic static int lastIndexOf(CharSequence text, CharSequence searchStr, int from, boolean ignoreCase);\npublic static int ordinalIndexOf(CharSequence str, CharSequence searchStr, int ordinal);\npublic static String removeAll(CharSequence str, CharSequence strToRemove);\npublic static String removeAny(CharSequence str, CharSequence... strsToRemove);\npublic static String removeAll(CharSequence str, char... chars);\npublic static String removeAllLineBreaks(CharSequence str);\npublic static String removePreAndLowerFirst(CharSequence str, int preLength);\npublic static String removePreAndLowerFirst(CharSequence str, CharSequence prefix);\npublic static String removePrefix(CharSequence str, CharSequence prefix);\npublic static String removePrefixIgnoreCase(CharSequence str, CharSequence prefix);\npublic static String removeSuffix(CharSequence str, CharSequence suffix);\npublic static String removeSufAndLowerFirst(CharSequence str, CharSequence suffix);\npublic static String removeSuffixIgnoreCase(CharSequence str, CharSequence suffix);\npublic static String cleanBlank(CharSequence str);\npublic static String strip(CharSequence str, CharSequence prefixOrSuffix);\npublic static String strip(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String stripIgnoreCase(CharSequence str, CharSequence prefixOrSuffix);\npublic static String stripIgnoreCase(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String addPrefixIfNot(CharSequence str, CharSequence prefix);\npublic static String addSuffixIfNot(CharSequence str, CharSequence suffix);\npublic static long[] splitToLong(CharSequence str, char separator);\npublic static long[] splitToLong(CharSequence str, CharSequence separator);\npublic static int[] splitToInt(CharSequence str, char separator);\npublic static int[] splitToInt(CharSequence str, CharSequence separator);\npublic static List<String> split(CharSequence str, char separator);\npublic static String[] splitToArray(CharSequence str, CharSequence separator);\npublic static String[] splitToArray(CharSequence str, char separator);\npublic static String[] splitToArray(CharSequence text, char separator, int limit);\npublic static List<String> split(CharSequence str, char separator, int limit);\npublic static List<String> splitTrim(CharSequence str, char separator);\npublic static List<String> splitTrim(CharSequence str, CharSequence separator);\npublic static List<String> splitTrim(CharSequence str, char separator, int limit);\npublic static List<String> splitTrim(CharSequence str, CharSequence separator, int limit);\npublic static List<String> split(CharSequence str, char separator, boolean isTrim, boolean ignoreEmpty);\npublic static List<String> split(CharSequence str, char separator, int limit, boolean isTrim, boolean ignoreEmpty);\npublic static List<R> split(CharSequence str, char separator, int limit, boolean ignoreEmpty, Function<String, R> mapping);\npublic static List<String> split(CharSequence str, CharSequence separator);\npublic static List<String> split(CharSequence str, CharSequence separator, boolean isTrim, boolean ignoreEmpty);\npublic static List<String> split(CharSequence str, CharSequence separator, int limit, boolean isTrim, boolean ignoreEmpty);\npublic static String[] split(CharSequence str, int len);\npublic static String[] cut(CharSequence str, int partLength);\npublic static String sub(CharSequence str, int fromIndexInclude, int toIndexExclude);\npublic static String subByCodePoint(CharSequence str, int fromIndex, int toIndex);\npublic static String subPreGbk(CharSequence str, int len, CharSequence suffix);\npublic static String subPreGbk(CharSequence str, int len, boolean halfUp);\npublic static String subPre(CharSequence string, int toIndexExclude);\npublic static String subSuf(CharSequence string, int fromIndex);\npublic static String subSufByLength(CharSequence string, int length);\npublic static String subWithLength(String input, int fromIndex, int length);\npublic static String subBefore(CharSequence string, CharSequence separator, boolean isLastSeparator);\npublic static String subBefore(CharSequence string, char separator, boolean isLastSeparator);\npublic static String subAfter(CharSequence string, CharSequence separator, boolean isLastSeparator);\npublic static String subAfter(CharSequence string, char separator, boolean isLastSeparator);\npublic static String subBetween(CharSequence str, CharSequence before, CharSequence after);\npublic static String subBetween(CharSequence str, CharSequence beforeAndAfter);\npublic static String[] subBetweenAll(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String[] subBetweenAll(CharSequence str, CharSequence prefixAndSuffix);\npublic static String repeat(char c, int count);\npublic static String repeat(CharSequence str, int count);\npublic static String repeatByLength(CharSequence str, int padLen);\npublic static String repeatAndJoin(CharSequence str, int count, CharSequence delimiter);\npublic static boolean equals(CharSequence str1, CharSequence str2);\npublic static boolean equalsIgnoreCase(CharSequence str1, CharSequence str2);\npublic static boolean equals(CharSequence str1, CharSequence str2, boolean ignoreCase);\npublic static boolean equalsAnyIgnoreCase(CharSequence str1, CharSequence... strs);\npublic static boolean equalsAny(CharSequence str1, CharSequence... strs);\npublic static boolean equalsAny(CharSequence str1, boolean ignoreCase, CharSequence... strs);\npublic static boolean equalsCharAt(CharSequence str, int position, char c);\npublic static boolean isSubEquals(CharSequence str1, int start1, CharSequence str2, boolean ignoreCase);\npublic static boolean isSubEquals(CharSequence str1, int start1, CharSequence str2, int start2, int length, boolean ignoreCase);\npublic static String format(CharSequence template, Object... params);\npublic static String indexedFormat(CharSequence pattern, Object... arguments);\npublic static byte[] utf8Bytes(CharSequence str);\npublic static byte[] bytes(CharSequence str);\npublic static byte[] bytes(CharSequence str, String charset);\npublic static byte[] bytes(CharSequence str, Charset charset);\npublic static ByteBuffer byteBuffer(CharSequence str, String charset);\npublic static String wrap(CharSequence str, CharSequence prefixAndSuffix);\npublic static String wrap(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String[] wrapAllWithPair(CharSequence prefixAndSuffix, CharSequence... strs);\npublic static String[] wrapAll(CharSequence prefix, CharSequence suffix, CharSequence... strs);\npublic static String wrapIfMissing(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String[] wrapAllWithPairIfMissing(CharSequence prefixAndSuffix, CharSequence... strs);\npublic static String[] wrapAllIfMissing(CharSequence prefix, CharSequence suffix, CharSequence... strs);\npublic static String unWrap(CharSequence str, String prefix, String suffix);\npublic static String unWrap(CharSequence str, char prefix, char suffix);\npublic static String unWrap(CharSequence str, char prefixAndSuffix);\npublic static boolean isWrap(CharSequence str, String prefix, String suffix);\npublic static boolean isWrap(CharSequence str, String wrapper);\npublic static boolean isWrap(CharSequence str, char wrapper);\npublic static boolean isWrap(CharSequence str, char prefixChar, char suffixChar);\npublic static String padPre(CharSequence str, int length, CharSequence padStr);\npublic static String padPre(CharSequence str, int length, char padChar);\npublic static String padAfter(CharSequence str, int length, char padChar);\npublic static String padAfter(CharSequence str, int length, CharSequence padStr);\npublic static String center(CharSequence str, final int size);\npublic static String center(CharSequence str, final int size, char padChar);\npublic static String center(CharSequence str, final int size, CharSequence padStr);\npublic static String str(CharSequence cs);\npublic static int count(CharSequence content, CharSequence strForSearch);\npublic static int count(CharSequence content, char charForSearch);\npublic static int compare(final CharSequence str1, final CharSequence str2, final boolean nullIsLess);\npublic static int compareIgnoreCase(CharSequence str1, CharSequence str2, boolean nullIsLess);\npublic static int compareVersion(CharSequence version1, CharSequence version2);\npublic static String appendIfMissing(CharSequence str, CharSequence suffix, CharSequence... suffixes);\npublic static String appendIfMissingIgnoreCase(CharSequence str, CharSequence suffix, CharSequence... suffixes);\npublic static String appendIfMissing(CharSequence str, CharSequence suffix, boolean ignoreCase, CharSequence... testSuffixes);\npublic static String prependIfMissing(CharSequence str, CharSequence prefix, CharSequence... prefixes);\npublic static String prependIfMissingIgnoreCase(CharSequence str, CharSequence prefix, CharSequence... prefixes);\npublic static String prependIfMissing(CharSequence str, CharSequence prefix, boolean ignoreCase, CharSequence... prefixes);\npublic static String replaceIgnoreCase(CharSequence str, CharSequence searchStr, CharSequence replacement);\npublic static String replace(CharSequence str, CharSequence searchStr, CharSequence replacement);\npublic static String replace(CharSequence str, CharSequence searchStr, CharSequence replacement, boolean ignoreCase);\npublic static String replace(CharSequence str, int fromIndex, CharSequence searchStr, CharSequence replacement, boolean ignoreCase);\npublic static String replace(CharSequence str, int startInclude, int endExclude, char replacedChar);\npublic static String replace(CharSequence str, int startInclude, int endExclude, CharSequence replacedStr);\npublic static String replace(CharSequence str, java.util.regex.Pattern pattern, Func1<java.util.regex.Matcher, String> replaceFun);\npublic static String replace(CharSequence str, String regex, Func1<java.util.regex.Matcher, String> replaceFun);\npublic static String replaceLast(CharSequence str, CharSequence searchStr, CharSequence replacedStr);\npublic static String replaceLast(CharSequence str, CharSequence searchStr, CharSequence replacedStr, boolean ignoreCase);\npublic static String replaceFirst(CharSequence str, CharSequence searchStr, CharSequence replacedStr);\npublic static String replaceFirst(CharSequence str, CharSequence searchStr, CharSequence replacedStr, boolean ignoreCase);\npublic static String hide(CharSequence str, int startInclude, int endExclude);\npublic static String desensitized(CharSequence str, DesensitizedUtil.DesensitizedType desensitizedType);\npublic static String replaceChars(CharSequence str, String chars, CharSequence replacedStr);\npublic static String replaceChars(CharSequence str, char[] chars, CharSequence replacedStr);\npublic static int length(CharSequence cs);\npublic static int byteLength(CharSequence cs, Charset charset);\npublic static int totalLength(CharSequence... strs);\npublic static String maxLength(CharSequence string, int length);\npublic static T firstNonNull(T... strs);\npublic static T firstNonEmpty(T... strs);\npublic static T firstNonBlank(T... strs);\npublic static String upperFirstAndAddPre(CharSequence str, String preString);\npublic static String upperFirst(CharSequence str);\npublic static String lowerFirst(CharSequence str);\npublic static String filter(CharSequence str, final Filter<Character> filter);\npublic static boolean isUpperCase(CharSequence str);\npublic static boolean isLowerCase(CharSequence str);\npublic static String swapCase(final String str);\npublic static String toUnderlineCase(CharSequence str);\npublic static String toSymbolCase(CharSequence str, char symbol);\npublic static String toCamelCase(CharSequence name);\npublic static String toCamelCase(CharSequence name, char symbol);\npublic static boolean isSurround(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static boolean isSurround(CharSequence str, char prefix, char suffix);\npublic static StringBuilder builder(CharSequence... strs);\npublic static StrBuilder strBuilder(CharSequence... strs);\npublic static String getGeneralField(CharSequence getOrSetMethodName);\npublic static String genSetter(CharSequence fieldName);\npublic static String genGetter(CharSequence fieldName);\npublic static String concat(boolean isNullToEmpty, CharSequence... strs);\npublic static String brief(CharSequence str, int maxLength);\npublic static String join(CharSequence conjunction, Object... objs);\npublic static String join(CharSequence conjunction, Iterable<T> iterable);\npublic static boolean isAllCharMatch(CharSequence value, Matcher<Character> matcher);\npublic static boolean isNumeric(CharSequence str);\npublic static String move(CharSequence str, int startInclude, int endExclude, int moveLength);\npublic static boolean isCharEquals(CharSequence str);\npublic static String normalize(CharSequence str);\npublic static String fixLength(CharSequence str, char fixedChar, int length);\npublic static boolean hasLetter(CharSequence str);\npublic static CharSequence commonPrefix(CharSequence str1, CharSequence str2);\npublic static CharSequence commonSuffix(CharSequence str1, CharSequence str2);",
        "Class_name": "CharSequenceUtil",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/text/CharSequenceUtil###commonSuffix",
        "Parameter_num": "2",
        "all_Import_statements": "import cn.hutool.core.collection.CollUtil;\n\nimport cn.hutool.core.comparator.VersionComparator;\n\nimport cn.hutool.core.convert.Convert;\n\nimport cn.hutool.core.lang.Assert;\n\nimport cn.hutool.core.lang.Filter;\n\nimport cn.hutool.core.lang.Matcher;\n\nimport cn.hutool.core.lang.func.Func1;\n\nimport cn.hutool.core.text.finder.CharFinder;\n\nimport cn.hutool.core.text.finder.Finder;\n\nimport cn.hutool.core.text.finder.StrFinder;\n\nimport cn.hutool.core.util.ArrayUtil;\n\nimport cn.hutool.core.util.CharUtil;\n\nimport cn.hutool.core.util.CharsetUtil;\n\nimport cn.hutool.core.util.DesensitizedUtil;\n\nimport cn.hutool.core.util.NumberUtil;\n\nimport cn.hutool.core.util.ReUtil;\n\nimport cn.hutool.core.util.StrUtil;\n\nimport java.nio.ByteBuffer;\n\nimport java.nio.charset.Charset;\n\nimport java.text.MessageFormat;\n\nimport java.text.Normalizer;\n\nimport java.util.HashSet;\n\nimport java.util.LinkedList;\n\nimport java.util.List;\n\nimport java.util.Set;\n\nimport java.util.function.Function;\n\nimport java.util.function.Predicate;\n",
        "comment": "\n\t * 字符串1和字符串2的公共后缀\n\t *\n\t * @param str1 字符串1\n\t * @param str2 字符串2\n\t * @return 字符串1和字符串2的公共后缀\n\t ",
        "packageName": "cn.hutool.core.text",
        "method_signature": "public static CharSequence commonSuffix(CharSequence str1, CharSequence str2);",
        "Junit_version": "5",
        "returnType": "CharSequence"
    },
    {
        "Method_body": "@SuppressWarnings({ \"unchecked\", \"SuspiciousSystemArraycopy\" })\npublic static <T> Object insert(Object array, int index, T... newElements) {\n    if (isEmpty(newElements)) {\n        return array;\n    }\n    if (isEmpty(array)) {\n        return newElements;\n    }\n    final int len = length(array);\n    if (index < 0) {\n        index = (index % len) + len;\n    }\n    final Class<?> originComponentType = array.getClass().getComponentType();\n    Object newEleArr = newElements;\n    if (originComponentType.isPrimitive()) {\n        newEleArr = Convert.convert(array.getClass(), newElements);\n    }\n    final Object result = Array.newInstance(originComponentType, Math.max(len, index) + newElements.length);\n    System.arraycopy(array, 0, result, 0, Math.min(len, index));\n    System.arraycopy(newEleArr, 0, result, index, newElements.length);\n    if (index < len) {\n        System.arraycopy(array, index, result, index + newElements.length, len - index);\n    }\n    return result;\n}",
        "all_field_declaration": "",
        "sub_project_name": "hutool-core",
        "lineNumbers": "12",
        "Filed": "",
        "Parameter_type": "Object,int,T",
        "Import_statements": "import cn.hutool.core.convert.Convert;\nimport java.lang.reflect.Array;\n",
        "public_method_signature": "public static boolean isEmpty(T[] array);\npublic static T[] defaultIfEmpty(T[] array, T[] defaultArray);\npublic static boolean isEmpty(Object array);\npublic static boolean isNotEmpty(T[] array);\npublic static boolean isNotEmpty(Object array);\npublic static boolean hasNull(T... array);\npublic static boolean isAllNull(T... array);\npublic static T firstNonNull(T... array);\npublic static T firstMatch(Matcher<T> matcher, T... array);\npublic static int matchIndex(Matcher<T> matcher, T... array);\npublic static int matchIndex(Matcher<T> matcher, int beginIndexInclude, T... array);\npublic static T[] newArray(Class<?> componentType, int newSize);\npublic static Object[] newArray(int newSize);\npublic static Class<?> getComponentType(Object array);\npublic static Class<?> getComponentType(Class<?> arrayClass);\npublic static Class<?> getArrayType(Class<?> componentType);\npublic static Object[] cast(Class<?> type, Object arrayObj) throws NullPointerException, IllegalArgumentException;\npublic static T[] append(T[] buffer, T... newElements);\npublic static Object append(Object array, T... newElements);\npublic static T[] setOrAppend(T[] buffer, int index, T value);\npublic static Object setOrAppend(Object array, int index, Object value);\npublic static T[] replace(T[] buffer, int index, T... values);\npublic static T[] insert(T[] buffer, int index, T... newElements);\npublic static Object insert(Object array, int index, T... newElements);\npublic static T[] resize(T[] data, int newSize, Class<?> componentType);\npublic static Object resize(Object array, int newSize);\npublic static T[] resize(T[] buffer, int newSize);\npublic static T[] addAll(T[]... arrays);\npublic static Object copy(Object src, int srcPos, Object dest, int destPos, int length);\npublic static Object copy(Object src, Object dest, int length);\npublic static T[] clone(T[] array);\npublic static T clone(final T obj);\npublic static T[] edit(T[] array, Editor<T> editor);\npublic static T[] filter(T[] array, Filter<T> filter);\npublic static T[] removeNull(T[] array);\npublic static T[] removeEmpty(T[] array);\npublic static T[] removeBlank(T[] array);\npublic static String[] nullToEmpty(String[] array);\npublic static Map<K, V> zip(K[] keys, V[] values, boolean isOrder);\npublic static Map<K, V> zip(K[] keys, V[] values);\npublic static int indexOf(T[] array, Object value, int beginIndexInclude);\npublic static int indexOf(T[] array, Object value);\npublic static int indexOfIgnoreCase(CharSequence[] array, CharSequence value);\npublic static int lastIndexOf(T[] array, Object value);\npublic static int lastIndexOf(T[] array, Object value, int endInclude);\npublic static boolean contains(T[] array, T value);\npublic static boolean containsAny(T[] array, T... values);\npublic static boolean containsAll(T[] array, T... values);\npublic static boolean containsIgnoreCase(CharSequence[] array, CharSequence value);\npublic static Object[] wrap(Object obj);\npublic static boolean isArray(Object obj);\npublic static T get(Object array, int index);\npublic static T[] getAny(Object array, int... indexes);\npublic static T[] sub(T[] array, int start, int end);\npublic static Object[] sub(Object array, int start, int end);\npublic static Object[] sub(Object array, int start, int end, int step);\npublic static String toString(Object obj);\npublic static int length(Object array) throws IllegalArgumentException;\npublic static String join(T[] array, CharSequence conjunction);\npublic static String join(T[] array, CharSequence delimiter, String prefix, String suffix);\npublic static String join(T[] array, CharSequence conjunction, Editor<T> editor);\npublic static String join(Object array, CharSequence conjunction);\npublic static byte[] toArray(ByteBuffer bytebuffer);\npublic static T[] toArray(Iterator<T> iterator, Class<T> componentType);\npublic static T[] toArray(Iterable<T> iterable, Class<T> componentType);\npublic static T[] toArray(Collection<T> collection, Class<T> componentType);\npublic static T[] remove(T[] array, int index) throws IllegalArgumentException;\npublic static T[] removeEle(T[] array, T element) throws IllegalArgumentException;\npublic static T[] reverse(T[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static T[] reverse(T[] array);\npublic static T min(T[] numberArray);\npublic static T min(T[] numberArray, Comparator<T> comparator);\npublic static T max(T[] numberArray);\npublic static T max(T[] numberArray, Comparator<T> comparator);\npublic static T[] shuffle(T[] array);\npublic static T[] shuffle(T[] array, Random random);\npublic static T[] swap(T[] array, int index1, int index2);\npublic static Object swap(Object array, int index1, int index2);\npublic static int emptyCount(Object... args);\npublic static boolean hasEmpty(Object... args);\npublic static boolean isAllEmpty(Object... args);\npublic static boolean isAllNotEmpty(Object... args);\npublic static boolean isAllNotNull(T... array);\npublic static T[] distinct(T[] array);\npublic static T[] distinct(T[] array, Function<T, K> uniqueGenerator, boolean override);\npublic static R[] map(T[] array, Class<R> targetComponentType, Function<? super T, ? extends R> func);\npublic static R[] map(Object array, Class<R> targetComponentType, Function<? super T, ? extends R> func);\npublic static List<R> map(T[] array, Function<? super T, ? extends R> func);\npublic static Set<R> mapToSet(T[] array, Function<? super T, ? extends R> func);\npublic static boolean equals(Object array1, Object array2);\npublic static boolean isSub(T[] array, T[] subArray);\npublic static int indexOfSub(T[] array, T[] subArray);\npublic static int indexOfSub(T[] array, int beginInclude, T[] subArray);\npublic static int lastIndexOfSub(T[] array, T[] subArray);\npublic static int lastIndexOfSub(T[] array, int endInclude, T[] subArray);\npublic static boolean isSorted(T[] array, Comparator<? super T> comparator);\npublic static boolean isSorted(T[] array);\npublic static boolean isSortedASC(T[] array);\npublic static boolean isSortedDESC(T[] array);",
        "public_field": "",
        "Method_statement": "insert(Object array, int index, T... newElements)",
        "Method_name": "insert",
        "Class_declaration": "public class ArrayUtil {\n",
        "constructors": "",
        "all_method_signature": "public static boolean isEmpty(T[] array);\npublic static T[] defaultIfEmpty(T[] array, T[] defaultArray);\npublic static boolean isEmpty(Object array);\npublic static boolean isNotEmpty(T[] array);\npublic static boolean isNotEmpty(Object array);\npublic static boolean hasNull(T... array);\npublic static boolean isAllNull(T... array);\npublic static T firstNonNull(T... array);\npublic static T firstMatch(Matcher<T> matcher, T... array);\npublic static int matchIndex(Matcher<T> matcher, T... array);\npublic static int matchIndex(Matcher<T> matcher, int beginIndexInclude, T... array);\npublic static T[] newArray(Class<?> componentType, int newSize);\npublic static Object[] newArray(int newSize);\npublic static Class<?> getComponentType(Object array);\npublic static Class<?> getComponentType(Class<?> arrayClass);\npublic static Class<?> getArrayType(Class<?> componentType);\npublic static Object[] cast(Class<?> type, Object arrayObj) throws NullPointerException, IllegalArgumentException;\npublic static T[] append(T[] buffer, T... newElements);\npublic static Object append(Object array, T... newElements);\npublic static T[] setOrAppend(T[] buffer, int index, T value);\npublic static Object setOrAppend(Object array, int index, Object value);\npublic static T[] replace(T[] buffer, int index, T... values);\npublic static T[] insert(T[] buffer, int index, T... newElements);\npublic static Object insert(Object array, int index, T... newElements);\npublic static T[] resize(T[] data, int newSize, Class<?> componentType);\npublic static Object resize(Object array, int newSize);\npublic static T[] resize(T[] buffer, int newSize);\npublic static T[] addAll(T[]... arrays);\npublic static Object copy(Object src, int srcPos, Object dest, int destPos, int length);\npublic static Object copy(Object src, Object dest, int length);\npublic static T[] clone(T[] array);\npublic static T clone(final T obj);\npublic static T[] edit(T[] array, Editor<T> editor);\npublic static T[] filter(T[] array, Filter<T> filter);\npublic static T[] removeNull(T[] array);\npublic static T[] removeEmpty(T[] array);\npublic static T[] removeBlank(T[] array);\npublic static String[] nullToEmpty(String[] array);\npublic static Map<K, V> zip(K[] keys, V[] values, boolean isOrder);\npublic static Map<K, V> zip(K[] keys, V[] values);\npublic static int indexOf(T[] array, Object value, int beginIndexInclude);\npublic static int indexOf(T[] array, Object value);\npublic static int indexOfIgnoreCase(CharSequence[] array, CharSequence value);\npublic static int lastIndexOf(T[] array, Object value);\npublic static int lastIndexOf(T[] array, Object value, int endInclude);\npublic static boolean contains(T[] array, T value);\npublic static boolean containsAny(T[] array, T... values);\npublic static boolean containsAll(T[] array, T... values);\npublic static boolean containsIgnoreCase(CharSequence[] array, CharSequence value);\npublic static Object[] wrap(Object obj);\npublic static boolean isArray(Object obj);\npublic static T get(Object array, int index);\npublic static T[] getAny(Object array, int... indexes);\npublic static T[] sub(T[] array, int start, int end);\npublic static Object[] sub(Object array, int start, int end);\npublic static Object[] sub(Object array, int start, int end, int step);\npublic static String toString(Object obj);\npublic static int length(Object array) throws IllegalArgumentException;\npublic static String join(T[] array, CharSequence conjunction);\npublic static String join(T[] array, CharSequence delimiter, String prefix, String suffix);\npublic static String join(T[] array, CharSequence conjunction, Editor<T> editor);\npublic static String join(Object array, CharSequence conjunction);\npublic static byte[] toArray(ByteBuffer bytebuffer);\npublic static T[] toArray(Iterator<T> iterator, Class<T> componentType);\npublic static T[] toArray(Iterable<T> iterable, Class<T> componentType);\npublic static T[] toArray(Collection<T> collection, Class<T> componentType);\npublic static T[] remove(T[] array, int index) throws IllegalArgumentException;\npublic static T[] removeEle(T[] array, T element) throws IllegalArgumentException;\npublic static T[] reverse(T[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static T[] reverse(T[] array);\npublic static T min(T[] numberArray);\npublic static T min(T[] numberArray, Comparator<T> comparator);\npublic static T max(T[] numberArray);\npublic static T max(T[] numberArray, Comparator<T> comparator);\npublic static T[] shuffle(T[] array);\npublic static T[] shuffle(T[] array, Random random);\npublic static T[] swap(T[] array, int index1, int index2);\npublic static Object swap(Object array, int index1, int index2);\npublic static int emptyCount(Object... args);\npublic static boolean hasEmpty(Object... args);\npublic static boolean isAllEmpty(Object... args);\npublic static boolean isAllNotEmpty(Object... args);\npublic static boolean isAllNotNull(T... array);\npublic static T[] distinct(T[] array);\npublic static T[] distinct(T[] array, Function<T, K> uniqueGenerator, boolean override);\npublic static R[] map(T[] array, Class<R> targetComponentType, Function<? super T, ? extends R> func);\npublic static R[] map(Object array, Class<R> targetComponentType, Function<? super T, ? extends R> func);\npublic static List<R> map(T[] array, Function<? super T, ? extends R> func);\npublic static Set<R> mapToSet(T[] array, Function<? super T, ? extends R> func);\npublic static boolean equals(Object array1, Object array2);\npublic static boolean isSub(T[] array, T[] subArray);\npublic static int indexOfSub(T[] array, T[] subArray);\npublic static int indexOfSub(T[] array, int beginInclude, T[] subArray);\npublic static int lastIndexOfSub(T[] array, T[] subArray);\npublic static int lastIndexOfSub(T[] array, int endInclude, T[] subArray);\npublic static boolean isSorted(T[] array, Comparator<? super T> comparator);\npublic static boolean isSorted(T[] array);\npublic static boolean isSortedASC(T[] array);\npublic static boolean isSortedDESC(T[] array);",
        "Class_name": "ArrayUtil",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/util/ArrayUtil###insert",
        "Parameter_num": "3",
        "all_Import_statements": "import cn.hutool.core.collection.CollUtil;\n\nimport cn.hutool.core.collection.CollectionUtil;\n\nimport cn.hutool.core.collection.UniqueKeySet;\n\nimport cn.hutool.core.comparator.CompareUtil;\n\nimport cn.hutool.core.convert.Convert;\n\nimport cn.hutool.core.exceptions.UtilException;\n\nimport cn.hutool.core.lang.Assert;\n\nimport cn.hutool.core.lang.Editor;\n\nimport cn.hutool.core.lang.Filter;\n\nimport cn.hutool.core.lang.Matcher;\n\nimport cn.hutool.core.map.MapUtil;\n\nimport cn.hutool.core.text.StrJoiner;\n\nimport java.lang.reflect.Array;\n\nimport java.nio.ByteBuffer;\n\nimport java.util.ArrayList;\n\nimport java.util.Arrays;\n\nimport java.util.Collection;\n\nimport java.util.Collections;\n\nimport java.util.Comparator;\n\nimport java.util.Iterator;\n\nimport java.util.LinkedHashSet;\n\nimport java.util.List;\n\nimport java.util.Map;\n\nimport java.util.Random;\n\nimport java.util.Set;\n\nimport java.util.function.Function;\n\nimport java.util.stream.Collectors;\n",
        "comment": "\n\t * 将新元素插入到到已有数组中的某个位置<br>\n\t * 添加新元素会生成一个新的数组，不影响原数组<br>\n\t * 如果插入位置为为负数，从原数组从后向前计数，若大于原数组长度，则空白处用null填充\n\t *\n\t * @param <T>         数组元素类型\n\t * @param array       已有数组\n\t * @param index       插入位置，此位置为对应此位置元素之前的空档\n\t * @param newElements 新元素\n\t * @return 新数组\n\t * @since 4.0.8\n\t ",
        "packageName": "cn.hutool.core.util",
        "method_signature": "public static Object insert(Object array, int index, T... newElements);",
        "Junit_version": "5",
        "returnType": "Object"
    },
    {
        "Method_body": "public static Object[][] toObjectArray(Map<?, ?> map) {\n    if (map == null) {\n        return null;\n    }\n    final Object[][] result = new Object[map.size()][2];\n    if (map.isEmpty()) {\n        return result;\n    }\n    int index = 0;\n    for (Entry<?, ?> entry : map.entrySet()) {\n        result[index][0] = entry.getKey();\n        result[index][1] = entry.getValue();\n        index++;\n    }\n    return result;\n}",
        "all_field_declaration": "/**\n * 默认初始大小\n */\npublic static final int DEFAULT_INITIAL_CAPACITY = 16;\n/**\n * 默认增长因子，当Map的size达到 容量*增长因子时，开始扩充Map\n */\npublic static final float DEFAULT_LOAD_FACTOR = 0.75f;",
        "sub_project_name": "hutool-core",
        "lineNumbers": "6",
        "Filed": "",
        "Parameter_type": "Map<?, ?>",
        "Import_statements": "import java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n",
        "public_method_signature": "public static boolean isEmpty(Map<?, ?> map);\npublic static boolean isNotEmpty(Map<?, ?> map);\npublic static Map<K, V> emptyIfNull(Map<K, V> set);\npublic static T defaultIfEmpty(T map, T defaultMap);\npublic static HashMap<K, V> newHashMap();\npublic static HashMap<K, V> newHashMap(int size, boolean isLinked);\npublic static HashMap<K, V> newHashMap(int size);\npublic static HashMap<K, V> newHashMap(boolean isLinked);\npublic static TreeMap<K, V> newTreeMap(Comparator<? super K> comparator);\npublic static TreeMap<K, V> newTreeMap(Map<K, V> map, Comparator<? super K> comparator);\npublic static Map<K, V> newIdentityMap(int size);\npublic static ConcurrentHashMap<K, V> newConcurrentHashMap();\npublic static ConcurrentHashMap<K, V> newConcurrentHashMap(int size);\npublic static ConcurrentHashMap<K, V> newConcurrentHashMap(Map<K, V> map);\npublic static Map<K, V> createMap(Class<?> mapType);\npublic static HashMap<K, V> of(K key, V value);\npublic static HashMap<K, V> of(K key, V value, boolean isOrder);\npublic static Map<K, V> of(Pair<K, V>... pairs);\npublic static Map<K, V> ofEntries(Map.Entry<K, V>... entries);\npublic static HashMap<Object, Object> of(Object[] array);\npublic static Map<K, List<V>> toListMap(Iterable<? extends Map<K, V>> mapList);\npublic static List<Map<K, V>> toMapList(Map<K, ? extends Iterable<V>> listMap);\npublic static Map<K, List<V>> grouping(Iterable<Map.Entry<K, V>> entries);\npublic static Map<K, V> toCamelCaseMap(Map<K, V> map);\npublic static Object[][] toObjectArray(Map<?, ?> map);\npublic static String join(Map<K, V> map, String separator, String keyValueSeparator, String... otherParams);\npublic static String sortJoin(Map<?, ?> params, String separator, String keyValueSeparator, boolean isIgnoreNull, String... otherParams);\npublic static String joinIgnoreNull(Map<K, V> map, String separator, String keyValueSeparator, String... otherParams);\npublic static String join(Map<K, V> map, String separator, String keyValueSeparator, boolean isIgnoreNull, String... otherParams);\npublic static Map<K, V> edit(Map<K, V> map, Editor<Entry<K, V>> editor);\npublic static Map<K, V> filter(Map<K, V> map, Filter<Entry<K, V>> filter);\npublic static Map<K, R> map(Map<K, V> map, BiFunction<K, V, R> biFunction);\npublic static Map<K, V> filter(Map<K, V> map, K... keys);\npublic static Map<T, T> reverse(Map<T, T> map);\npublic static Map<V, K> inverse(Map<K, V> map);\npublic static TreeMap<K, V> sort(Map<K, V> map);\npublic static TreeMap<K, V> sort(Map<K, V> map, Comparator<? super K> comparator);\npublic static Map<K, V> sortByValue(Map<K, V> map, boolean isDesc);\npublic static MapProxy createProxy(Map<?, ?> map);\npublic static MapWrapper<K, V> wrap(Map<K, V> map);\npublic static Map<K, V> unmodifiable(Map<K, V> map);\npublic static MapBuilder<K, V> builder();\npublic static MapBuilder<K, V> builder(Map<K, V> map);\npublic static MapBuilder<K, V> builder(K k, V v);\npublic static Map<K, V> getAny(Map<K, V> map, final K... keys);\npublic static Map<K, V> removeAny(Map<K, V> map, final K... keys);\npublic static String getStr(Map<?, ?> map, Object key);\npublic static String getStr(Map<?, ?> map, Object key, String defaultValue);\npublic static Integer getInt(Map<?, ?> map, Object key);\npublic static Integer getInt(Map<?, ?> map, Object key, Integer defaultValue);\npublic static Double getDouble(Map<?, ?> map, Object key);\npublic static Double getDouble(Map<?, ?> map, Object key, Double defaultValue);\npublic static Float getFloat(Map<?, ?> map, Object key);\npublic static Float getFloat(Map<?, ?> map, Object key, Float defaultValue);\npublic static Short getShort(Map<?, ?> map, Object key);\npublic static Short getShort(Map<?, ?> map, Object key, Short defaultValue);\npublic static Boolean getBool(Map<?, ?> map, Object key);\npublic static Boolean getBool(Map<?, ?> map, Object key, Boolean defaultValue);\npublic static Character getChar(Map<?, ?> map, Object key);\npublic static Character getChar(Map<?, ?> map, Object key, Character defaultValue);\npublic static Long getLong(Map<?, ?> map, Object key);\npublic static Long getLong(Map<?, ?> map, Object key, Long defaultValue);\npublic static Date getDate(Map<?, ?> map, Object key);\npublic static Date getDate(Map<?, ?> map, Object key, Date defaultValue);\npublic static T get(Map<?, ?> map, Object key, Class<T> type);\npublic static T get(Map<?, ?> map, Object key, Class<T> type, T defaultValue);\npublic static T getQuietly(Map<?, ?> map, Object key, Class<T> type, T defaultValue);\npublic static T get(Map<?, ?> map, Object key, TypeReference<T> type);\npublic static T get(Map<?, ?> map, Object key, TypeReference<T> type, T defaultValue);\npublic static T getQuietly(Map<?, ?> map, Object key, TypeReference<T> type, T defaultValue);\npublic static Map<K, V> renameKey(Map<K, V> map, K oldKey, K newKey);\npublic static Map<K, V> removeNullValue(Map<K, V> map);\npublic static Map<K, V> empty();\npublic static T empty(Class<?> mapClass);\npublic static void clear(Map<?, ?>... maps);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, Iterator<K> keys);\npublic static Map.Entry<K, V> entry(K key, V value);\npublic static Map.Entry<K, V> entry(K key, V value, boolean isImmutable);\npublic static V computeIfAbsent(Map<K, V> map, K key, Function<? super K, ? extends V> mappingFunction);\npublic static V computeIfAbsentForJdk8(final Map<K, V> map, final K key, final Function<? super K, ? extends V> mappingFunction);",
        "public_field": "/**\n * 默认初始大小\n */\npublic static final int DEFAULT_INITIAL_CAPACITY = 16;\n/**\n * 默认增长因子，当Map的size达到 容量*增长因子时，开始扩充Map\n */\npublic static final float DEFAULT_LOAD_FACTOR = 0.75f;",
        "Method_statement": "toObjectArray(Map<?, ?> map)",
        "Method_name": "toObjectArray",
        "Class_declaration": "public class MapUtil {\n",
        "constructors": "",
        "all_method_signature": "public static boolean isEmpty(Map<?, ?> map);\npublic static boolean isNotEmpty(Map<?, ?> map);\npublic static Map<K, V> emptyIfNull(Map<K, V> set);\npublic static T defaultIfEmpty(T map, T defaultMap);\npublic static HashMap<K, V> newHashMap();\npublic static HashMap<K, V> newHashMap(int size, boolean isLinked);\npublic static HashMap<K, V> newHashMap(int size);\npublic static HashMap<K, V> newHashMap(boolean isLinked);\npublic static TreeMap<K, V> newTreeMap(Comparator<? super K> comparator);\npublic static TreeMap<K, V> newTreeMap(Map<K, V> map, Comparator<? super K> comparator);\npublic static Map<K, V> newIdentityMap(int size);\npublic static ConcurrentHashMap<K, V> newConcurrentHashMap();\npublic static ConcurrentHashMap<K, V> newConcurrentHashMap(int size);\npublic static ConcurrentHashMap<K, V> newConcurrentHashMap(Map<K, V> map);\npublic static Map<K, V> createMap(Class<?> mapType);\npublic static HashMap<K, V> of(K key, V value);\npublic static HashMap<K, V> of(K key, V value, boolean isOrder);\npublic static Map<K, V> of(Pair<K, V>... pairs);\npublic static Map<K, V> ofEntries(Map.Entry<K, V>... entries);\npublic static HashMap<Object, Object> of(Object[] array);\npublic static Map<K, List<V>> toListMap(Iterable<? extends Map<K, V>> mapList);\npublic static List<Map<K, V>> toMapList(Map<K, ? extends Iterable<V>> listMap);\npublic static Map<K, List<V>> grouping(Iterable<Map.Entry<K, V>> entries);\npublic static Map<K, V> toCamelCaseMap(Map<K, V> map);\npublic static Object[][] toObjectArray(Map<?, ?> map);\npublic static String join(Map<K, V> map, String separator, String keyValueSeparator, String... otherParams);\npublic static String sortJoin(Map<?, ?> params, String separator, String keyValueSeparator, boolean isIgnoreNull, String... otherParams);\npublic static String joinIgnoreNull(Map<K, V> map, String separator, String keyValueSeparator, String... otherParams);\npublic static String join(Map<K, V> map, String separator, String keyValueSeparator, boolean isIgnoreNull, String... otherParams);\npublic static Map<K, V> edit(Map<K, V> map, Editor<Entry<K, V>> editor);\npublic static Map<K, V> filter(Map<K, V> map, Filter<Entry<K, V>> filter);\npublic static Map<K, R> map(Map<K, V> map, BiFunction<K, V, R> biFunction);\npublic static Map<K, V> filter(Map<K, V> map, K... keys);\npublic static Map<T, T> reverse(Map<T, T> map);\npublic static Map<V, K> inverse(Map<K, V> map);\npublic static TreeMap<K, V> sort(Map<K, V> map);\npublic static TreeMap<K, V> sort(Map<K, V> map, Comparator<? super K> comparator);\npublic static Map<K, V> sortByValue(Map<K, V> map, boolean isDesc);\npublic static MapProxy createProxy(Map<?, ?> map);\npublic static MapWrapper<K, V> wrap(Map<K, V> map);\npublic static Map<K, V> unmodifiable(Map<K, V> map);\npublic static MapBuilder<K, V> builder();\npublic static MapBuilder<K, V> builder(Map<K, V> map);\npublic static MapBuilder<K, V> builder(K k, V v);\npublic static Map<K, V> getAny(Map<K, V> map, final K... keys);\npublic static Map<K, V> removeAny(Map<K, V> map, final K... keys);\npublic static String getStr(Map<?, ?> map, Object key);\npublic static String getStr(Map<?, ?> map, Object key, String defaultValue);\npublic static Integer getInt(Map<?, ?> map, Object key);\npublic static Integer getInt(Map<?, ?> map, Object key, Integer defaultValue);\npublic static Double getDouble(Map<?, ?> map, Object key);\npublic static Double getDouble(Map<?, ?> map, Object key, Double defaultValue);\npublic static Float getFloat(Map<?, ?> map, Object key);\npublic static Float getFloat(Map<?, ?> map, Object key, Float defaultValue);\npublic static Short getShort(Map<?, ?> map, Object key);\npublic static Short getShort(Map<?, ?> map, Object key, Short defaultValue);\npublic static Boolean getBool(Map<?, ?> map, Object key);\npublic static Boolean getBool(Map<?, ?> map, Object key, Boolean defaultValue);\npublic static Character getChar(Map<?, ?> map, Object key);\npublic static Character getChar(Map<?, ?> map, Object key, Character defaultValue);\npublic static Long getLong(Map<?, ?> map, Object key);\npublic static Long getLong(Map<?, ?> map, Object key, Long defaultValue);\npublic static Date getDate(Map<?, ?> map, Object key);\npublic static Date getDate(Map<?, ?> map, Object key, Date defaultValue);\npublic static T get(Map<?, ?> map, Object key, Class<T> type);\npublic static T get(Map<?, ?> map, Object key, Class<T> type, T defaultValue);\npublic static T getQuietly(Map<?, ?> map, Object key, Class<T> type, T defaultValue);\npublic static T get(Map<?, ?> map, Object key, TypeReference<T> type);\npublic static T get(Map<?, ?> map, Object key, TypeReference<T> type, T defaultValue);\npublic static T getQuietly(Map<?, ?> map, Object key, TypeReference<T> type, T defaultValue);\npublic static Map<K, V> renameKey(Map<K, V> map, K oldKey, K newKey);\npublic static Map<K, V> removeNullValue(Map<K, V> map);\npublic static Map<K, V> empty();\npublic static T empty(Class<?> mapClass);\npublic static void clear(Map<?, ?>... maps);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, Iterator<K> keys);\npublic static Map.Entry<K, V> entry(K key, V value);\npublic static Map.Entry<K, V> entry(K key, V value, boolean isImmutable);\npublic static V computeIfAbsent(Map<K, V> map, K key, Function<? super K, ? extends V> mappingFunction);\npublic static V computeIfAbsentForJdk8(final Map<K, V> map, final K key, final Function<? super K, ? extends V> mappingFunction);",
        "Class_name": "MapUtil",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/map/MapUtil###toObjectArray",
        "Parameter_num": "1",
        "all_Import_statements": "import cn.hutool.core.collection.CollUtil;\n\nimport cn.hutool.core.convert.Convert;\n\nimport cn.hutool.core.exceptions.UtilException;\n\nimport cn.hutool.core.lang.Editor;\n\nimport cn.hutool.core.lang.Filter;\n\nimport cn.hutool.core.lang.Pair;\n\nimport cn.hutool.core.lang.TypeReference;\n\nimport cn.hutool.core.stream.CollectorUtil;\n\nimport cn.hutool.core.util.ArrayUtil;\n\nimport cn.hutool.core.util.JdkUtil;\n\nimport cn.hutool.core.util.ReflectUtil;\n\nimport cn.hutool.core.util.StrUtil;\n\nimport java.util.AbstractMap;\n\nimport java.util.ArrayList;\n\nimport java.util.Collections;\n\nimport java.util.Comparator;\n\nimport java.util.Date;\n\nimport java.util.HashMap;\n\nimport java.util.IdentityHashMap;\n\nimport java.util.Iterator;\n\nimport java.util.LinkedHashMap;\n\nimport java.util.List;\n\nimport java.util.Map;\n\nimport java.util.Map.Entry;\n\nimport java.util.NavigableMap;\n\nimport java.util.Set;\n\nimport java.util.SortedMap;\n\nimport java.util.TreeMap;\n\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport java.util.function.BiFunction;\n\nimport java.util.function.Function;\n",
        "comment": "\n\t * 将键值对转换为二维数组，第一维是key，第二纬是value\n\t *\n\t * @param map map\n\t * @return 数组\n\t * @since 4.1.9\n\t ",
        "packageName": "cn.hutool.core.map",
        "method_signature": "public static Object[][] toObjectArray(Map<?, ?> map);",
        "Junit_version": "5",
        "returnType": "Object[][]"
    },
    {
        "Method_body": "@SuppressWarnings(\"unchecked\")\n@Override\npublic <T> T getAttributeValue(String attributeName, Class<T> attributeType, Collection<? extends SynthesizedAnnotation> synthesizedAnnotations) {\n    Object value = valueCaches.get(attributeName, attributeType);\n    if (ObjectUtil.isNotNull(value)) {\n        return (T) value;\n    }\n    value = synthesizedAnnotations.stream().filter(ma -> ma.hasAttribute(attributeName, attributeType)).min(annotationComparator).map(ma -> ma.getAttributeValue(attributeName)).orElse(null);\n    valueCaches.put(attributeName, attributeType, value);\n    return (T) value;\n}",
        "all_field_declaration": "private final Table<String, Class<?>, Object> valueCaches = new RowKeyTable<>();\nprivate final Comparator<Hierarchical> annotationComparator;",
        "sub_project_name": "hutool-core",
        "lineNumbers": "5",
        "Filed": "private final Table<String, Class<?>, Object> valueCaches = new RowKeyTable<>();private final Comparator<Hierarchical> annotationComparator;",
        "Parameter_type": "String,Class<T>,Collection<? extends SynthesizedAnnotation>",
        "Import_statements": "import cn.hutool.core.util.ObjectUtil;\nimport java.util.Collection;\nimport java.util.Comparator;\n",
        "public_method_signature": "public CacheableSynthesizedAnnotationAttributeProcessor(Comparator<Hierarchical> annotationComparator);\npublic CacheableSynthesizedAnnotationAttributeProcessor();\npublic T getAttributeValue(String attributeName, Class<T> attributeType, Collection<? extends SynthesizedAnnotation> synthesizedAnnotations);",
        "public_field": "",
        "Method_statement": "getAttributeValue(String attributeName, Class<T> attributeType, Collection<? extends SynthesizedAnnotation> synthesizedAnnotations)",
        "Method_name": "getAttributeValue",
        "Class_declaration": "public class CacheableSynthesizedAnnotationAttributeProcessor {\n",
        "constructors": "public CacheableSynthesizedAnnotationAttributeProcessor(Comparator<Hierarchical> annotationComparator) {\n    Assert.notNull(annotationComparator, \"annotationComparator must not null\");\n    this.annotationComparator = annotationComparator;\n}public CacheableSynthesizedAnnotationAttributeProcessor() {\n    this(Hierarchical.DEFAULT_HIERARCHICAL_COMPARATOR);\n}",
        "all_method_signature": "public CacheableSynthesizedAnnotationAttributeProcessor(Comparator<Hierarchical> annotationComparator);\npublic CacheableSynthesizedAnnotationAttributeProcessor();\npublic T getAttributeValue(String attributeName, Class<T> attributeType, Collection<? extends SynthesizedAnnotation> synthesizedAnnotations);",
        "Class_name": "CacheableSynthesizedAnnotationAttributeProcessor",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/annotation/CacheableSynthesizedAnnotationAttributeProcessor###getAttributeValue",
        "Parameter_num": "3",
        "all_Import_statements": "import cn.hutool.core.lang.Assert;\n\nimport cn.hutool.core.map.multi.RowKeyTable;\n\nimport cn.hutool.core.map.multi.Table;\n\nimport cn.hutool.core.util.ObjectUtil;\n\nimport java.util.Collection;\n\nimport java.util.Comparator;\n",
        "comment": "",
        "packageName": "cn.hutool.core.annotation",
        "method_signature": "public T getAttributeValue(String attributeName, Class<T> attributeType, Collection<? extends SynthesizedAnnotation> synthesizedAnnotations);",
        "Junit_version": "5",
        "returnType": "T"
    },
    {
        "Method_body": "@SuppressWarnings(\"unchecked\")\npublic static <T> T clone(final T obj) {\n    if (null == obj) {\n        return null;\n    }\n    if (isArray(obj)) {\n        final Object result;\n        final Class<?> componentType = obj.getClass().getComponentType();\n        if (componentType.isPrimitive()) {\n            int length = Array.getLength(obj);\n            result = Array.newInstance(componentType, length);\n            while (length-- > 0) {\n                Array.set(result, length, Array.get(obj, length));\n            }\n        } else {\n            result = ((Object[]) obj).clone();\n        }\n        return (T) result;\n    }\n    return null;\n}",
        "all_field_declaration": "",
        "sub_project_name": "hutool-core",
        "lineNumbers": "3",
        "Filed": "",
        "Parameter_type": "T",
        "Import_statements": "import java.lang.reflect.Array;\n",
        "public_method_signature": "public static boolean isEmpty(T[] array);\npublic static T[] defaultIfEmpty(T[] array, T[] defaultArray);\npublic static boolean isEmpty(Object array);\npublic static boolean isNotEmpty(T[] array);\npublic static boolean isNotEmpty(Object array);\npublic static boolean hasNull(T... array);\npublic static boolean isAllNull(T... array);\npublic static T firstNonNull(T... array);\npublic static T firstMatch(Matcher<T> matcher, T... array);\npublic static int matchIndex(Matcher<T> matcher, T... array);\npublic static int matchIndex(Matcher<T> matcher, int beginIndexInclude, T... array);\npublic static T[] newArray(Class<?> componentType, int newSize);\npublic static Object[] newArray(int newSize);\npublic static Class<?> getComponentType(Object array);\npublic static Class<?> getComponentType(Class<?> arrayClass);\npublic static Class<?> getArrayType(Class<?> componentType);\npublic static Object[] cast(Class<?> type, Object arrayObj) throws NullPointerException, IllegalArgumentException;\npublic static T[] append(T[] buffer, T... newElements);\npublic static Object append(Object array, T... newElements);\npublic static T[] setOrAppend(T[] buffer, int index, T value);\npublic static Object setOrAppend(Object array, int index, Object value);\npublic static T[] replace(T[] buffer, int index, T... values);\npublic static T[] insert(T[] buffer, int index, T... newElements);\npublic static Object insert(Object array, int index, T... newElements);\npublic static T[] resize(T[] data, int newSize, Class<?> componentType);\npublic static Object resize(Object array, int newSize);\npublic static T[] resize(T[] buffer, int newSize);\npublic static T[] addAll(T[]... arrays);\npublic static Object copy(Object src, int srcPos, Object dest, int destPos, int length);\npublic static Object copy(Object src, Object dest, int length);\npublic static T[] clone(T[] array);\npublic static T clone(final T obj);\npublic static T[] edit(T[] array, Editor<T> editor);\npublic static T[] filter(T[] array, Filter<T> filter);\npublic static T[] removeNull(T[] array);\npublic static T[] removeEmpty(T[] array);\npublic static T[] removeBlank(T[] array);\npublic static String[] nullToEmpty(String[] array);\npublic static Map<K, V> zip(K[] keys, V[] values, boolean isOrder);\npublic static Map<K, V> zip(K[] keys, V[] values);\npublic static int indexOf(T[] array, Object value, int beginIndexInclude);\npublic static int indexOf(T[] array, Object value);\npublic static int indexOfIgnoreCase(CharSequence[] array, CharSequence value);\npublic static int lastIndexOf(T[] array, Object value);\npublic static int lastIndexOf(T[] array, Object value, int endInclude);\npublic static boolean contains(T[] array, T value);\npublic static boolean containsAny(T[] array, T... values);\npublic static boolean containsAll(T[] array, T... values);\npublic static boolean containsIgnoreCase(CharSequence[] array, CharSequence value);\npublic static Object[] wrap(Object obj);\npublic static boolean isArray(Object obj);\npublic static T get(Object array, int index);\npublic static T[] getAny(Object array, int... indexes);\npublic static T[] sub(T[] array, int start, int end);\npublic static Object[] sub(Object array, int start, int end);\npublic static Object[] sub(Object array, int start, int end, int step);\npublic static String toString(Object obj);\npublic static int length(Object array) throws IllegalArgumentException;\npublic static String join(T[] array, CharSequence conjunction);\npublic static String join(T[] array, CharSequence delimiter, String prefix, String suffix);\npublic static String join(T[] array, CharSequence conjunction, Editor<T> editor);\npublic static String join(Object array, CharSequence conjunction);\npublic static byte[] toArray(ByteBuffer bytebuffer);\npublic static T[] toArray(Iterator<T> iterator, Class<T> componentType);\npublic static T[] toArray(Iterable<T> iterable, Class<T> componentType);\npublic static T[] toArray(Collection<T> collection, Class<T> componentType);\npublic static T[] remove(T[] array, int index) throws IllegalArgumentException;\npublic static T[] removeEle(T[] array, T element) throws IllegalArgumentException;\npublic static T[] reverse(T[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static T[] reverse(T[] array);\npublic static T min(T[] numberArray);\npublic static T min(T[] numberArray, Comparator<T> comparator);\npublic static T max(T[] numberArray);\npublic static T max(T[] numberArray, Comparator<T> comparator);\npublic static T[] shuffle(T[] array);\npublic static T[] shuffle(T[] array, Random random);\npublic static T[] swap(T[] array, int index1, int index2);\npublic static Object swap(Object array, int index1, int index2);\npublic static int emptyCount(Object... args);\npublic static boolean hasEmpty(Object... args);\npublic static boolean isAllEmpty(Object... args);\npublic static boolean isAllNotEmpty(Object... args);\npublic static boolean isAllNotNull(T... array);\npublic static T[] distinct(T[] array);\npublic static T[] distinct(T[] array, Function<T, K> uniqueGenerator, boolean override);\npublic static R[] map(T[] array, Class<R> targetComponentType, Function<? super T, ? extends R> func);\npublic static R[] map(Object array, Class<R> targetComponentType, Function<? super T, ? extends R> func);\npublic static List<R> map(T[] array, Function<? super T, ? extends R> func);\npublic static Set<R> mapToSet(T[] array, Function<? super T, ? extends R> func);\npublic static boolean equals(Object array1, Object array2);\npublic static boolean isSub(T[] array, T[] subArray);\npublic static int indexOfSub(T[] array, T[] subArray);\npublic static int indexOfSub(T[] array, int beginInclude, T[] subArray);\npublic static int lastIndexOfSub(T[] array, T[] subArray);\npublic static int lastIndexOfSub(T[] array, int endInclude, T[] subArray);\npublic static boolean isSorted(T[] array, Comparator<? super T> comparator);\npublic static boolean isSorted(T[] array);\npublic static boolean isSortedASC(T[] array);\npublic static boolean isSortedDESC(T[] array);",
        "public_field": "",
        "Method_statement": "clone(final T obj)",
        "Method_name": "clone",
        "Class_declaration": "public class ArrayUtil {\n",
        "constructors": "",
        "all_method_signature": "public static boolean isEmpty(T[] array);\npublic static T[] defaultIfEmpty(T[] array, T[] defaultArray);\npublic static boolean isEmpty(Object array);\npublic static boolean isNotEmpty(T[] array);\npublic static boolean isNotEmpty(Object array);\npublic static boolean hasNull(T... array);\npublic static boolean isAllNull(T... array);\npublic static T firstNonNull(T... array);\npublic static T firstMatch(Matcher<T> matcher, T... array);\npublic static int matchIndex(Matcher<T> matcher, T... array);\npublic static int matchIndex(Matcher<T> matcher, int beginIndexInclude, T... array);\npublic static T[] newArray(Class<?> componentType, int newSize);\npublic static Object[] newArray(int newSize);\npublic static Class<?> getComponentType(Object array);\npublic static Class<?> getComponentType(Class<?> arrayClass);\npublic static Class<?> getArrayType(Class<?> componentType);\npublic static Object[] cast(Class<?> type, Object arrayObj) throws NullPointerException, IllegalArgumentException;\npublic static T[] append(T[] buffer, T... newElements);\npublic static Object append(Object array, T... newElements);\npublic static T[] setOrAppend(T[] buffer, int index, T value);\npublic static Object setOrAppend(Object array, int index, Object value);\npublic static T[] replace(T[] buffer, int index, T... values);\npublic static T[] insert(T[] buffer, int index, T... newElements);\npublic static Object insert(Object array, int index, T... newElements);\npublic static T[] resize(T[] data, int newSize, Class<?> componentType);\npublic static Object resize(Object array, int newSize);\npublic static T[] resize(T[] buffer, int newSize);\npublic static T[] addAll(T[]... arrays);\npublic static Object copy(Object src, int srcPos, Object dest, int destPos, int length);\npublic static Object copy(Object src, Object dest, int length);\npublic static T[] clone(T[] array);\npublic static T clone(final T obj);\npublic static T[] edit(T[] array, Editor<T> editor);\npublic static T[] filter(T[] array, Filter<T> filter);\npublic static T[] removeNull(T[] array);\npublic static T[] removeEmpty(T[] array);\npublic static T[] removeBlank(T[] array);\npublic static String[] nullToEmpty(String[] array);\npublic static Map<K, V> zip(K[] keys, V[] values, boolean isOrder);\npublic static Map<K, V> zip(K[] keys, V[] values);\npublic static int indexOf(T[] array, Object value, int beginIndexInclude);\npublic static int indexOf(T[] array, Object value);\npublic static int indexOfIgnoreCase(CharSequence[] array, CharSequence value);\npublic static int lastIndexOf(T[] array, Object value);\npublic static int lastIndexOf(T[] array, Object value, int endInclude);\npublic static boolean contains(T[] array, T value);\npublic static boolean containsAny(T[] array, T... values);\npublic static boolean containsAll(T[] array, T... values);\npublic static boolean containsIgnoreCase(CharSequence[] array, CharSequence value);\npublic static Object[] wrap(Object obj);\npublic static boolean isArray(Object obj);\npublic static T get(Object array, int index);\npublic static T[] getAny(Object array, int... indexes);\npublic static T[] sub(T[] array, int start, int end);\npublic static Object[] sub(Object array, int start, int end);\npublic static Object[] sub(Object array, int start, int end, int step);\npublic static String toString(Object obj);\npublic static int length(Object array) throws IllegalArgumentException;\npublic static String join(T[] array, CharSequence conjunction);\npublic static String join(T[] array, CharSequence delimiter, String prefix, String suffix);\npublic static String join(T[] array, CharSequence conjunction, Editor<T> editor);\npublic static String join(Object array, CharSequence conjunction);\npublic static byte[] toArray(ByteBuffer bytebuffer);\npublic static T[] toArray(Iterator<T> iterator, Class<T> componentType);\npublic static T[] toArray(Iterable<T> iterable, Class<T> componentType);\npublic static T[] toArray(Collection<T> collection, Class<T> componentType);\npublic static T[] remove(T[] array, int index) throws IllegalArgumentException;\npublic static T[] removeEle(T[] array, T element) throws IllegalArgumentException;\npublic static T[] reverse(T[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static T[] reverse(T[] array);\npublic static T min(T[] numberArray);\npublic static T min(T[] numberArray, Comparator<T> comparator);\npublic static T max(T[] numberArray);\npublic static T max(T[] numberArray, Comparator<T> comparator);\npublic static T[] shuffle(T[] array);\npublic static T[] shuffle(T[] array, Random random);\npublic static T[] swap(T[] array, int index1, int index2);\npublic static Object swap(Object array, int index1, int index2);\npublic static int emptyCount(Object... args);\npublic static boolean hasEmpty(Object... args);\npublic static boolean isAllEmpty(Object... args);\npublic static boolean isAllNotEmpty(Object... args);\npublic static boolean isAllNotNull(T... array);\npublic static T[] distinct(T[] array);\npublic static T[] distinct(T[] array, Function<T, K> uniqueGenerator, boolean override);\npublic static R[] map(T[] array, Class<R> targetComponentType, Function<? super T, ? extends R> func);\npublic static R[] map(Object array, Class<R> targetComponentType, Function<? super T, ? extends R> func);\npublic static List<R> map(T[] array, Function<? super T, ? extends R> func);\npublic static Set<R> mapToSet(T[] array, Function<? super T, ? extends R> func);\npublic static boolean equals(Object array1, Object array2);\npublic static boolean isSub(T[] array, T[] subArray);\npublic static int indexOfSub(T[] array, T[] subArray);\npublic static int indexOfSub(T[] array, int beginInclude, T[] subArray);\npublic static int lastIndexOfSub(T[] array, T[] subArray);\npublic static int lastIndexOfSub(T[] array, int endInclude, T[] subArray);\npublic static boolean isSorted(T[] array, Comparator<? super T> comparator);\npublic static boolean isSorted(T[] array);\npublic static boolean isSortedASC(T[] array);\npublic static boolean isSortedDESC(T[] array);",
        "Class_name": "ArrayUtil",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/util/ArrayUtil###clone",
        "Parameter_num": "1",
        "all_Import_statements": "import cn.hutool.core.collection.CollUtil;\n\nimport cn.hutool.core.collection.CollectionUtil;\n\nimport cn.hutool.core.collection.UniqueKeySet;\n\nimport cn.hutool.core.comparator.CompareUtil;\n\nimport cn.hutool.core.convert.Convert;\n\nimport cn.hutool.core.exceptions.UtilException;\n\nimport cn.hutool.core.lang.Assert;\n\nimport cn.hutool.core.lang.Editor;\n\nimport cn.hutool.core.lang.Filter;\n\nimport cn.hutool.core.lang.Matcher;\n\nimport cn.hutool.core.map.MapUtil;\n\nimport cn.hutool.core.text.StrJoiner;\n\nimport java.lang.reflect.Array;\n\nimport java.nio.ByteBuffer;\n\nimport java.util.ArrayList;\n\nimport java.util.Arrays;\n\nimport java.util.Collection;\n\nimport java.util.Collections;\n\nimport java.util.Comparator;\n\nimport java.util.Iterator;\n\nimport java.util.LinkedHashSet;\n\nimport java.util.List;\n\nimport java.util.Map;\n\nimport java.util.Random;\n\nimport java.util.Set;\n\nimport java.util.function.Function;\n\nimport java.util.stream.Collectors;\n",
        "comment": "\n\t * 克隆数组，如果非数组返回{@code null}\n\t *\n\t * @param <T> 数组元素类型\n\t * @param obj 数组对象\n\t * @return 克隆后的数组对象\n\t ",
        "packageName": "cn.hutool.core.util",
        "method_signature": "public static T clone(final T obj);",
        "Junit_version": "5",
        "returnType": "T"
    },
    {
        "Method_body": "public long betweenMonth(boolean isReset) {\n    final Calendar beginCal = DateUtil.calendar(begin);\n    final Calendar endCal = DateUtil.calendar(end);\n    final int betweenYear = endCal.get(Calendar.YEAR) - beginCal.get(Calendar.YEAR);\n    final int betweenMonthOfYear = endCal.get(Calendar.MONTH) - beginCal.get(Calendar.MONTH);\n    int result = betweenYear * 12 + betweenMonthOfYear;\n    if (false == isReset) {\n        endCal.set(Calendar.YEAR, beginCal.get(Calendar.YEAR));\n        endCal.set(Calendar.MONTH, beginCal.get(Calendar.MONTH));\n        long between = endCal.getTimeInMillis() - beginCal.getTimeInMillis();\n        if (between < 0) {\n            return result - 1;\n        }\n    }\n    return result;\n}",
        "all_field_declaration": "private static final long serialVersionUID = 1L;\n/**\n * 开始日期\n */\nprivate final Date begin;\n/**\n * 结束日期\n */\nprivate final Date end;",
        "sub_project_name": "hutool-core",
        "lineNumbers": "7",
        "Filed": "private final Date begin;private final Date end;",
        "Parameter_type": "boolean",
        "Import_statements": "import java.util.Calendar;\nimport java.util.Date;\n",
        "public_method_signature": "public static DateBetween create(Date begin, Date end);\npublic static DateBetween create(Date begin, Date end, boolean isAbs);\npublic DateBetween(Date begin, Date end);\npublic DateBetween(Date begin, Date end, boolean isAbs);\npublic long between(DateUnit unit);\npublic long betweenMonth(boolean isReset);\npublic long betweenYear(boolean isReset);\npublic String toString(DateUnit unit, BetweenFormatter.Level level);\npublic String toString(BetweenFormatter.Level level);\npublic String toString();",
        "public_field": "",
        "Method_statement": "betweenMonth(boolean isReset)",
        "Method_name": "betweenMonth",
        "Class_declaration": "public class DateBetween {\n",
        "constructors": "public DateBetween(Date begin, Date end) {\n    this(begin, end, true);\n}public DateBetween(Date begin, Date end, boolean isAbs) {\n    Assert.notNull(begin, \"Begin date is null !\");\n    Assert.notNull(end, \"End date is null !\");\n    if (isAbs && begin.after(end)) {\n        this.begin = end;\n        this.end = begin;\n    } else {\n        this.begin = begin;\n        this.end = end;\n    }\n}",
        "all_method_signature": "public static DateBetween create(Date begin, Date end);\npublic static DateBetween create(Date begin, Date end, boolean isAbs);\npublic DateBetween(Date begin, Date end);\npublic DateBetween(Date begin, Date end, boolean isAbs);\npublic long between(DateUnit unit);\npublic long betweenMonth(boolean isReset);\npublic long betweenYear(boolean isReset);\npublic String toString(DateUnit unit, BetweenFormatter.Level level);\npublic String toString(BetweenFormatter.Level level);\npublic String toString();",
        "Class_name": "DateBetween",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/date/DateBetween###betweenMonth",
        "Parameter_num": "1",
        "all_Import_statements": "import cn.hutool.core.lang.Assert;\n\nimport java.io.Serializable;\n\nimport java.util.Calendar;\n\nimport java.util.Date;\n",
        "comment": "\n\t * 计算两个日期相差月数<br>\n\t * 在非重置情况下，如果起始日期的天大于结束日期的天，月数要少算1（不足1个月）\n\t *\n\t * @param isReset 是否重置时间为起始时间（重置天时分秒）\n\t * @return 相差月数\n\t * @since 3.0.8\n\t ",
        "packageName": "cn.hutool.core.date",
        "method_signature": "public long betweenMonth(boolean isReset);",
        "Junit_version": "5",
        "returnType": "long"
    },
    {
        "Method_body": "public static <K, X, Y, V> Map<K, V> merge(Map<K, X> map1, Map<K, Y> map2, BiFunction<X, Y, V> merge) {\n    if (MapUtil.isEmpty(map1) && MapUtil.isEmpty(map2)) {\n        return MapUtil.newHashMap(0);\n    } else if (MapUtil.isEmpty(map1)) {\n        map1 = MapUtil.newHashMap(0);\n    } else if (MapUtil.isEmpty(map2)) {\n        map2 = MapUtil.newHashMap(0);\n    }\n    Set<K> key = new HashSet<>();\n    key.addAll(map1.keySet());\n    key.addAll(map2.keySet());\n    Map<K, V> map = MapUtil.newHashMap(key.size());\n    for (K t : key) {\n        X x = map1.get(t);\n        Y y = map2.get(t);\n        V z = merge.apply(x, y);\n        if (z != null) {\n            map.put(t, z);\n        }\n    }\n    return map;\n}",
        "all_field_declaration": "",
        "sub_project_name": "hutool-core",
        "lineNumbers": "7",
        "Filed": "",
        "Parameter_type": "Map<K, X>,Map<K, Y>,BiFunction<X, Y, V>",
        "Import_statements": "import cn.hutool.core.map.MapUtil;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\n",
        "public_method_signature": "public static Map<K, V> toIdentityMap(Collection<V> collection, Function<V, K> key);\npublic static Map<K, V> toIdentityMap(Collection<V> collection, Function<V, K> key, boolean isParallel);\npublic static Map<K, V> toMap(Collection<E> collection, Function<E, K> key, Function<E, V> value);\npublic static Map<K, V> toMap(Collection<E> collection, Function<E, K> key, Function<E, V> value, boolean isParallel);\npublic static Map<K, List<E>> groupByKey(Collection<E> collection, Function<E, K> key);\npublic static Map<K, List<E>> groupByKey(Collection<E> collection, Function<E, K> key, boolean isParallel);\npublic static Map<K, Map<U, List<E>>> groupBy2Key(Collection<E> collection, Function<E, K> key1, Function<E, U> key2);\npublic static Map<K, Map<U, List<E>>> groupBy2Key(Collection<E> collection, Function<E, K> key1, Function<E, U> key2, boolean isParallel);\npublic static Map<T, Map<U, E>> group2Map(Collection<E> collection, Function<E, T> key1, Function<E, U> key2);\npublic static Map<T, Map<U, E>> group2Map(Collection<E> collection, Function<E, T> key1, Function<E, U> key2, boolean isParallel);\npublic static Map<K, List<V>> groupKeyValue(Collection<E> collection, Function<E, K> key, Function<E, V> value);\npublic static Map<K, List<V>> groupKeyValue(Collection<E> collection, Function<E, K> key, Function<E, V> value, boolean isParallel);\npublic static Map<K, D> groupBy(Collection<E> collection, Function<E, K> key, Collector<E, ?, D> downstream);\npublic static Map<K, D> groupBy(Collection<E> collection, Function<E, K> key, Collector<E, ?, D> downstream, boolean isParallel);\npublic static List<T> toList(Collection<E> collection, Function<E, T> function);\npublic static List<T> toList(Collection<E> collection, Function<E, T> function, boolean isParallel);\npublic static Set<T> toSet(Collection<E> collection, Function<E, T> function);\npublic static Set<T> toSet(Collection<E> collection, Function<E, T> function, boolean isParallel);\npublic static Map<K, V> merge(Map<K, X> map1, Map<K, Y> map2, BiFunction<X, Y, V> merge);",
        "public_field": "",
        "Method_statement": "merge(Map<K, X> map1, Map<K, Y> map2, BiFunction<X, Y, V> merge)",
        "Method_name": "merge",
        "Class_declaration": "public class CollStreamUtil {\n",
        "constructors": "",
        "all_method_signature": "public static Map<K, V> toIdentityMap(Collection<V> collection, Function<V, K> key);\npublic static Map<K, V> toIdentityMap(Collection<V> collection, Function<V, K> key, boolean isParallel);\npublic static Map<K, V> toMap(Collection<E> collection, Function<E, K> key, Function<E, V> value);\npublic static Map<K, V> toMap(Collection<E> collection, Function<E, K> key, Function<E, V> value, boolean isParallel);\npublic static Map<K, List<E>> groupByKey(Collection<E> collection, Function<E, K> key);\npublic static Map<K, List<E>> groupByKey(Collection<E> collection, Function<E, K> key, boolean isParallel);\npublic static Map<K, Map<U, List<E>>> groupBy2Key(Collection<E> collection, Function<E, K> key1, Function<E, U> key2);\npublic static Map<K, Map<U, List<E>>> groupBy2Key(Collection<E> collection, Function<E, K> key1, Function<E, U> key2, boolean isParallel);\npublic static Map<T, Map<U, E>> group2Map(Collection<E> collection, Function<E, T> key1, Function<E, U> key2);\npublic static Map<T, Map<U, E>> group2Map(Collection<E> collection, Function<E, T> key1, Function<E, U> key2, boolean isParallel);\npublic static Map<K, List<V>> groupKeyValue(Collection<E> collection, Function<E, K> key, Function<E, V> value);\npublic static Map<K, List<V>> groupKeyValue(Collection<E> collection, Function<E, K> key, Function<E, V> value, boolean isParallel);\npublic static Map<K, D> groupBy(Collection<E> collection, Function<E, K> key, Collector<E, ?, D> downstream);\npublic static Map<K, D> groupBy(Collection<E> collection, Function<E, K> key, Collector<E, ?, D> downstream, boolean isParallel);\npublic static List<T> toList(Collection<E> collection, Function<E, T> function);\npublic static List<T> toList(Collection<E> collection, Function<E, T> function, boolean isParallel);\npublic static Set<T> toSet(Collection<E> collection, Function<E, T> function);\npublic static Set<T> toSet(Collection<E> collection, Function<E, T> function, boolean isParallel);\npublic static Map<K, V> merge(Map<K, X> map1, Map<K, Y> map2, BiFunction<X, Y, V> merge);",
        "Class_name": "CollStreamUtil",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/collection/CollStreamUtil###merge",
        "Parameter_num": "3",
        "all_Import_statements": "import cn.hutool.core.lang.Opt;\n\nimport cn.hutool.core.map.MapUtil;\n\nimport cn.hutool.core.stream.CollectorUtil;\n\nimport cn.hutool.core.stream.StreamUtil;\n\nimport java.util.Collection;\n\nimport java.util.Collections;\n\nimport java.util.HashMap;\n\nimport java.util.HashSet;\n\nimport java.util.List;\n\nimport java.util.Map;\n\nimport java.util.Objects;\n\nimport java.util.Set;\n\nimport java.util.function.BiFunction;\n\nimport java.util.function.Function;\n\nimport java.util.stream.Collector;\n\nimport java.util.stream.Collectors;\n",
        "comment": "\n\t * 合并两个相同key类型的map\n\t *\n\t * @param map1  第一个需要合并的 map\n\t * @param map2  第二个需要合并的 map\n\t * @param merge 合并的lambda，将key  value1 value2合并成最终的类型,注意value可能为空的情况\n\t * @param <K>   map中的key类型\n\t * @param <X>   第一个 map的value类型\n\t * @param <Y>   第二个 map的value类型\n\t * @param <V>   最终map的value类型\n\t * @return 合并后的map\n\t ",
        "packageName": "cn.hutool.core.collection",
        "method_signature": "public static Map<K, V> merge(Map<K, X> map1, Map<K, Y> map2, BiFunction<X, Y, V> merge);",
        "Junit_version": "5",
        "returnType": "Map<K,V>"
    },
    {
        "Method_body": "public static String subPreGbk(CharSequence str, int len, boolean halfUp) {\n    if (isEmpty(str)) {\n        return str(str);\n    }\n    int counterOfDoubleByte = 0;\n    final byte[] b = bytes(str, CharsetUtil.CHARSET_GBK);\n    if (b.length <= len) {\n        return str.toString();\n    }\n    for (int i = 0; i < len; i++) {\n        if (b[i] < 0) {\n            counterOfDoubleByte++;\n        }\n    }\n    if (counterOfDoubleByte % 2 != 0) {\n        if (halfUp) {\n            len += 1;\n        } else {\n            len -= 1;\n        }\n    }\n    return new String(b, 0, len, CharsetUtil.CHARSET_GBK);\n}",
        "all_field_declaration": "public static final int INDEX_NOT_FOUND = Finder.INDEX_NOT_FOUND;\n/**\n * 字符串常量：{@code \"null\"} <br>\n * 注意：{@code \"null\" != null}\n */\npublic static final String NULL = \"null\";\n/**\n * 字符串常量：空字符串 {@code \"\"}\n */\npublic static final String EMPTY = \"\";\n/**\n * 字符串常量：空格符 {@code \" \"}\n */\npublic static final String SPACE = \" \";",
        "sub_project_name": "hutool-core",
        "lineNumbers": "7",
        "Filed": "",
        "Parameter_type": "CharSequence,int,boolean",
        "Import_statements": "import cn.hutool.core.util.CharsetUtil;\nimport java.nio.charset.Charset;\n",
        "public_method_signature": "public static boolean isBlank(CharSequence str);\npublic static boolean isNotBlank(CharSequence str);\npublic static boolean hasBlank(CharSequence... strs);\npublic static boolean isAllBlank(CharSequence... strs);\npublic static boolean isEmpty(CharSequence str);\npublic static boolean isNotEmpty(CharSequence str);\npublic static String emptyIfNull(CharSequence str);\npublic static String nullToEmpty(CharSequence str);\npublic static String nullToDefault(CharSequence str, String defaultStr);\npublic static String emptyToDefault(CharSequence str, String defaultStr);\npublic static String blankToDefault(CharSequence str, String defaultStr);\npublic static String emptyToNull(CharSequence str);\npublic static boolean hasEmpty(CharSequence... strs);\npublic static boolean isAllEmpty(CharSequence... strs);\npublic static boolean isAllNotEmpty(CharSequence... args);\npublic static boolean isAllNotBlank(CharSequence... args);\npublic static boolean isNullOrUndefined(CharSequence str);\npublic static boolean isEmptyOrUndefined(CharSequence str);\npublic static boolean isBlankOrUndefined(CharSequence str);\npublic static String trim(CharSequence str);\npublic static String trimToEmpty(CharSequence str);\npublic static String trimToNull(CharSequence str);\npublic static String trimStart(CharSequence str);\npublic static String trimEnd(CharSequence str);\npublic static String trim(CharSequence str, int mode);\npublic static String trim(CharSequence str, int mode, Predicate<Character> predicate);\npublic static boolean startWith(CharSequence str, char c);\npublic static boolean startWith(CharSequence str, CharSequence prefix, boolean ignoreCase);\npublic static boolean startWith(CharSequence str, CharSequence prefix, boolean ignoreCase, boolean ignoreEquals);\npublic static boolean startWith(CharSequence str, CharSequence prefix);\npublic static boolean startWithIgnoreEquals(CharSequence str, CharSequence prefix);\npublic static boolean startWithIgnoreCase(CharSequence str, CharSequence prefix);\npublic static boolean startWithAny(CharSequence str, CharSequence... prefixes);\npublic static boolean startWithAnyIgnoreCase(final CharSequence str, final CharSequence... suffixes);\npublic static boolean endWith(CharSequence str, char c);\npublic static boolean endWith(CharSequence str, CharSequence suffix, boolean ignoreCase);\npublic static boolean endWith(CharSequence str, CharSequence suffix, boolean ignoreCase, boolean ignoreEquals);\npublic static boolean endWith(CharSequence str, CharSequence suffix);\npublic static boolean endWithIgnoreCase(CharSequence str, CharSequence suffix);\npublic static boolean endWithAny(CharSequence str, CharSequence... suffixes);\npublic static boolean endWithAnyIgnoreCase(CharSequence str, CharSequence... suffixes);\npublic static boolean contains(CharSequence str, char searchChar);\npublic static boolean contains(CharSequence str, CharSequence searchStr);\npublic static boolean containsAny(CharSequence str, CharSequence... testStrs);\npublic static boolean containsAny(CharSequence str, char... testChars);\npublic static boolean containsOnly(CharSequence str, char... testChars);\npublic static boolean containsAll(CharSequence str, CharSequence... testChars);\npublic static boolean containsBlank(CharSequence str);\npublic static String getContainsStr(CharSequence str, CharSequence... testStrs);\npublic static boolean containsIgnoreCase(CharSequence str, CharSequence testStr);\npublic static boolean containsAnyIgnoreCase(CharSequence str, CharSequence... testStrs);\npublic static String getContainsStrIgnoreCase(CharSequence str, CharSequence... testStrs);\npublic static int indexOf(CharSequence str, char searchChar);\npublic static int indexOf(CharSequence str, char searchChar, int start);\npublic static int indexOf(CharSequence text, char searchChar, int start, int end);\npublic static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr);\npublic static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int fromIndex);\npublic static int indexOf(CharSequence text, CharSequence searchStr, int from, boolean ignoreCase);\npublic static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr);\npublic static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr, int fromIndex);\npublic static int lastIndexOf(CharSequence text, CharSequence searchStr, int from, boolean ignoreCase);\npublic static int ordinalIndexOf(CharSequence str, CharSequence searchStr, int ordinal);\npublic static String removeAll(CharSequence str, CharSequence strToRemove);\npublic static String removeAny(CharSequence str, CharSequence... strsToRemove);\npublic static String removeAll(CharSequence str, char... chars);\npublic static String removeAllLineBreaks(CharSequence str);\npublic static String removePreAndLowerFirst(CharSequence str, int preLength);\npublic static String removePreAndLowerFirst(CharSequence str, CharSequence prefix);\npublic static String removePrefix(CharSequence str, CharSequence prefix);\npublic static String removePrefixIgnoreCase(CharSequence str, CharSequence prefix);\npublic static String removeSuffix(CharSequence str, CharSequence suffix);\npublic static String removeSufAndLowerFirst(CharSequence str, CharSequence suffix);\npublic static String removeSuffixIgnoreCase(CharSequence str, CharSequence suffix);\npublic static String cleanBlank(CharSequence str);\npublic static String strip(CharSequence str, CharSequence prefixOrSuffix);\npublic static String strip(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String stripIgnoreCase(CharSequence str, CharSequence prefixOrSuffix);\npublic static String stripIgnoreCase(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String addPrefixIfNot(CharSequence str, CharSequence prefix);\npublic static String addSuffixIfNot(CharSequence str, CharSequence suffix);\npublic static long[] splitToLong(CharSequence str, char separator);\npublic static long[] splitToLong(CharSequence str, CharSequence separator);\npublic static int[] splitToInt(CharSequence str, char separator);\npublic static int[] splitToInt(CharSequence str, CharSequence separator);\npublic static List<String> split(CharSequence str, char separator);\npublic static String[] splitToArray(CharSequence str, CharSequence separator);\npublic static String[] splitToArray(CharSequence str, char separator);\npublic static String[] splitToArray(CharSequence text, char separator, int limit);\npublic static List<String> split(CharSequence str, char separator, int limit);\npublic static List<String> splitTrim(CharSequence str, char separator);\npublic static List<String> splitTrim(CharSequence str, CharSequence separator);\npublic static List<String> splitTrim(CharSequence str, char separator, int limit);\npublic static List<String> splitTrim(CharSequence str, CharSequence separator, int limit);\npublic static List<String> split(CharSequence str, char separator, boolean isTrim, boolean ignoreEmpty);\npublic static List<String> split(CharSequence str, char separator, int limit, boolean isTrim, boolean ignoreEmpty);\npublic static List<R> split(CharSequence str, char separator, int limit, boolean ignoreEmpty, Function<String, R> mapping);\npublic static List<String> split(CharSequence str, CharSequence separator);\npublic static List<String> split(CharSequence str, CharSequence separator, boolean isTrim, boolean ignoreEmpty);\npublic static List<String> split(CharSequence str, CharSequence separator, int limit, boolean isTrim, boolean ignoreEmpty);\npublic static String[] split(CharSequence str, int len);\npublic static String[] cut(CharSequence str, int partLength);\npublic static String sub(CharSequence str, int fromIndexInclude, int toIndexExclude);\npublic static String subByCodePoint(CharSequence str, int fromIndex, int toIndex);\npublic static String subPreGbk(CharSequence str, int len, CharSequence suffix);\npublic static String subPreGbk(CharSequence str, int len, boolean halfUp);\npublic static String subPre(CharSequence string, int toIndexExclude);\npublic static String subSuf(CharSequence string, int fromIndex);\npublic static String subSufByLength(CharSequence string, int length);\npublic static String subWithLength(String input, int fromIndex, int length);\npublic static String subBefore(CharSequence string, CharSequence separator, boolean isLastSeparator);\npublic static String subBefore(CharSequence string, char separator, boolean isLastSeparator);\npublic static String subAfter(CharSequence string, CharSequence separator, boolean isLastSeparator);\npublic static String subAfter(CharSequence string, char separator, boolean isLastSeparator);\npublic static String subBetween(CharSequence str, CharSequence before, CharSequence after);\npublic static String subBetween(CharSequence str, CharSequence beforeAndAfter);\npublic static String[] subBetweenAll(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String[] subBetweenAll(CharSequence str, CharSequence prefixAndSuffix);\npublic static String repeat(char c, int count);\npublic static String repeat(CharSequence str, int count);\npublic static String repeatByLength(CharSequence str, int padLen);\npublic static String repeatAndJoin(CharSequence str, int count, CharSequence delimiter);\npublic static boolean equals(CharSequence str1, CharSequence str2);\npublic static boolean equalsIgnoreCase(CharSequence str1, CharSequence str2);\npublic static boolean equals(CharSequence str1, CharSequence str2, boolean ignoreCase);\npublic static boolean equalsAnyIgnoreCase(CharSequence str1, CharSequence... strs);\npublic static boolean equalsAny(CharSequence str1, CharSequence... strs);\npublic static boolean equalsAny(CharSequence str1, boolean ignoreCase, CharSequence... strs);\npublic static boolean equalsCharAt(CharSequence str, int position, char c);\npublic static boolean isSubEquals(CharSequence str1, int start1, CharSequence str2, boolean ignoreCase);\npublic static boolean isSubEquals(CharSequence str1, int start1, CharSequence str2, int start2, int length, boolean ignoreCase);\npublic static String format(CharSequence template, Object... params);\npublic static String indexedFormat(CharSequence pattern, Object... arguments);\npublic static byte[] utf8Bytes(CharSequence str);\npublic static byte[] bytes(CharSequence str);\npublic static byte[] bytes(CharSequence str, String charset);\npublic static byte[] bytes(CharSequence str, Charset charset);\npublic static ByteBuffer byteBuffer(CharSequence str, String charset);\npublic static String wrap(CharSequence str, CharSequence prefixAndSuffix);\npublic static String wrap(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String[] wrapAllWithPair(CharSequence prefixAndSuffix, CharSequence... strs);\npublic static String[] wrapAll(CharSequence prefix, CharSequence suffix, CharSequence... strs);\npublic static String wrapIfMissing(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String[] wrapAllWithPairIfMissing(CharSequence prefixAndSuffix, CharSequence... strs);\npublic static String[] wrapAllIfMissing(CharSequence prefix, CharSequence suffix, CharSequence... strs);\npublic static String unWrap(CharSequence str, String prefix, String suffix);\npublic static String unWrap(CharSequence str, char prefix, char suffix);\npublic static String unWrap(CharSequence str, char prefixAndSuffix);\npublic static boolean isWrap(CharSequence str, String prefix, String suffix);\npublic static boolean isWrap(CharSequence str, String wrapper);\npublic static boolean isWrap(CharSequence str, char wrapper);\npublic static boolean isWrap(CharSequence str, char prefixChar, char suffixChar);\npublic static String padPre(CharSequence str, int length, CharSequence padStr);\npublic static String padPre(CharSequence str, int length, char padChar);\npublic static String padAfter(CharSequence str, int length, char padChar);\npublic static String padAfter(CharSequence str, int length, CharSequence padStr);\npublic static String center(CharSequence str, final int size);\npublic static String center(CharSequence str, final int size, char padChar);\npublic static String center(CharSequence str, final int size, CharSequence padStr);\npublic static String str(CharSequence cs);\npublic static int count(CharSequence content, CharSequence strForSearch);\npublic static int count(CharSequence content, char charForSearch);\npublic static int compare(final CharSequence str1, final CharSequence str2, final boolean nullIsLess);\npublic static int compareIgnoreCase(CharSequence str1, CharSequence str2, boolean nullIsLess);\npublic static int compareVersion(CharSequence version1, CharSequence version2);\npublic static String appendIfMissing(CharSequence str, CharSequence suffix, CharSequence... suffixes);\npublic static String appendIfMissingIgnoreCase(CharSequence str, CharSequence suffix, CharSequence... suffixes);\npublic static String appendIfMissing(CharSequence str, CharSequence suffix, boolean ignoreCase, CharSequence... testSuffixes);\npublic static String prependIfMissing(CharSequence str, CharSequence prefix, CharSequence... prefixes);\npublic static String prependIfMissingIgnoreCase(CharSequence str, CharSequence prefix, CharSequence... prefixes);\npublic static String prependIfMissing(CharSequence str, CharSequence prefix, boolean ignoreCase, CharSequence... prefixes);\npublic static String replaceIgnoreCase(CharSequence str, CharSequence searchStr, CharSequence replacement);\npublic static String replace(CharSequence str, CharSequence searchStr, CharSequence replacement);\npublic static String replace(CharSequence str, CharSequence searchStr, CharSequence replacement, boolean ignoreCase);\npublic static String replace(CharSequence str, int fromIndex, CharSequence searchStr, CharSequence replacement, boolean ignoreCase);\npublic static String replace(CharSequence str, int startInclude, int endExclude, char replacedChar);\npublic static String replace(CharSequence str, int startInclude, int endExclude, CharSequence replacedStr);\npublic static String replace(CharSequence str, java.util.regex.Pattern pattern, Func1<java.util.regex.Matcher, String> replaceFun);\npublic static String replace(CharSequence str, String regex, Func1<java.util.regex.Matcher, String> replaceFun);\npublic static String replaceLast(CharSequence str, CharSequence searchStr, CharSequence replacedStr);\npublic static String replaceLast(CharSequence str, CharSequence searchStr, CharSequence replacedStr, boolean ignoreCase);\npublic static String replaceFirst(CharSequence str, CharSequence searchStr, CharSequence replacedStr);\npublic static String replaceFirst(CharSequence str, CharSequence searchStr, CharSequence replacedStr, boolean ignoreCase);\npublic static String hide(CharSequence str, int startInclude, int endExclude);\npublic static String desensitized(CharSequence str, DesensitizedUtil.DesensitizedType desensitizedType);\npublic static String replaceChars(CharSequence str, String chars, CharSequence replacedStr);\npublic static String replaceChars(CharSequence str, char[] chars, CharSequence replacedStr);\npublic static int length(CharSequence cs);\npublic static int byteLength(CharSequence cs, Charset charset);\npublic static int totalLength(CharSequence... strs);\npublic static String maxLength(CharSequence string, int length);\npublic static T firstNonNull(T... strs);\npublic static T firstNonEmpty(T... strs);\npublic static T firstNonBlank(T... strs);\npublic static String upperFirstAndAddPre(CharSequence str, String preString);\npublic static String upperFirst(CharSequence str);\npublic static String lowerFirst(CharSequence str);\npublic static String filter(CharSequence str, final Filter<Character> filter);\npublic static boolean isUpperCase(CharSequence str);\npublic static boolean isLowerCase(CharSequence str);\npublic static String swapCase(final String str);\npublic static String toUnderlineCase(CharSequence str);\npublic static String toSymbolCase(CharSequence str, char symbol);\npublic static String toCamelCase(CharSequence name);\npublic static String toCamelCase(CharSequence name, char symbol);\npublic static boolean isSurround(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static boolean isSurround(CharSequence str, char prefix, char suffix);\npublic static StringBuilder builder(CharSequence... strs);\npublic static StrBuilder strBuilder(CharSequence... strs);\npublic static String getGeneralField(CharSequence getOrSetMethodName);\npublic static String genSetter(CharSequence fieldName);\npublic static String genGetter(CharSequence fieldName);\npublic static String concat(boolean isNullToEmpty, CharSequence... strs);\npublic static String brief(CharSequence str, int maxLength);\npublic static String join(CharSequence conjunction, Object... objs);\npublic static String join(CharSequence conjunction, Iterable<T> iterable);\npublic static boolean isAllCharMatch(CharSequence value, Matcher<Character> matcher);\npublic static boolean isNumeric(CharSequence str);\npublic static String move(CharSequence str, int startInclude, int endExclude, int moveLength);\npublic static boolean isCharEquals(CharSequence str);\npublic static String normalize(CharSequence str);\npublic static String fixLength(CharSequence str, char fixedChar, int length);\npublic static boolean hasLetter(CharSequence str);\npublic static CharSequence commonPrefix(CharSequence str1, CharSequence str2);\npublic static CharSequence commonSuffix(CharSequence str1, CharSequence str2);",
        "public_field": "public static final int INDEX_NOT_FOUND = Finder.INDEX_NOT_FOUND;\n/**\n * 字符串常量：{@code \"null\"} <br>\n * 注意：{@code \"null\" != null}\n */\npublic static final String NULL = \"null\";\n/**\n * 字符串常量：空字符串 {@code \"\"}\n */\npublic static final String EMPTY = \"\";\n/**\n * 字符串常量：空格符 {@code \" \"}\n */\npublic static final String SPACE = \" \";",
        "Method_statement": "subPreGbk(CharSequence str, int len, boolean halfUp)",
        "Method_name": "subPreGbk",
        "Class_declaration": "public class CharSequenceUtil {\n",
        "constructors": "",
        "all_method_signature": "public static boolean isBlank(CharSequence str);\npublic static boolean isNotBlank(CharSequence str);\npublic static boolean hasBlank(CharSequence... strs);\npublic static boolean isAllBlank(CharSequence... strs);\npublic static boolean isEmpty(CharSequence str);\npublic static boolean isNotEmpty(CharSequence str);\npublic static String emptyIfNull(CharSequence str);\npublic static String nullToEmpty(CharSequence str);\npublic static String nullToDefault(CharSequence str, String defaultStr);\npublic static String emptyToDefault(CharSequence str, String defaultStr);\npublic static String blankToDefault(CharSequence str, String defaultStr);\npublic static String emptyToNull(CharSequence str);\npublic static boolean hasEmpty(CharSequence... strs);\npublic static boolean isAllEmpty(CharSequence... strs);\npublic static boolean isAllNotEmpty(CharSequence... args);\npublic static boolean isAllNotBlank(CharSequence... args);\npublic static boolean isNullOrUndefined(CharSequence str);\npublic static boolean isEmptyOrUndefined(CharSequence str);\npublic static boolean isBlankOrUndefined(CharSequence str);\nprivate static boolean isNullOrUndefinedStr(CharSequence str);\npublic static String trim(CharSequence str);\npublic static String trimToEmpty(CharSequence str);\npublic static String trimToNull(CharSequence str);\npublic static String trimStart(CharSequence str);\npublic static String trimEnd(CharSequence str);\npublic static String trim(CharSequence str, int mode);\npublic static String trim(CharSequence str, int mode, Predicate<Character> predicate);\npublic static boolean startWith(CharSequence str, char c);\npublic static boolean startWith(CharSequence str, CharSequence prefix, boolean ignoreCase);\npublic static boolean startWith(CharSequence str, CharSequence prefix, boolean ignoreCase, boolean ignoreEquals);\npublic static boolean startWith(CharSequence str, CharSequence prefix);\npublic static boolean startWithIgnoreEquals(CharSequence str, CharSequence prefix);\npublic static boolean startWithIgnoreCase(CharSequence str, CharSequence prefix);\npublic static boolean startWithAny(CharSequence str, CharSequence... prefixes);\npublic static boolean startWithAnyIgnoreCase(final CharSequence str, final CharSequence... suffixes);\npublic static boolean endWith(CharSequence str, char c);\npublic static boolean endWith(CharSequence str, CharSequence suffix, boolean ignoreCase);\npublic static boolean endWith(CharSequence str, CharSequence suffix, boolean ignoreCase, boolean ignoreEquals);\npublic static boolean endWith(CharSequence str, CharSequence suffix);\npublic static boolean endWithIgnoreCase(CharSequence str, CharSequence suffix);\npublic static boolean endWithAny(CharSequence str, CharSequence... suffixes);\npublic static boolean endWithAnyIgnoreCase(CharSequence str, CharSequence... suffixes);\npublic static boolean contains(CharSequence str, char searchChar);\npublic static boolean contains(CharSequence str, CharSequence searchStr);\npublic static boolean containsAny(CharSequence str, CharSequence... testStrs);\npublic static boolean containsAny(CharSequence str, char... testChars);\npublic static boolean containsOnly(CharSequence str, char... testChars);\npublic static boolean containsAll(CharSequence str, CharSequence... testChars);\npublic static boolean containsBlank(CharSequence str);\npublic static String getContainsStr(CharSequence str, CharSequence... testStrs);\npublic static boolean containsIgnoreCase(CharSequence str, CharSequence testStr);\npublic static boolean containsAnyIgnoreCase(CharSequence str, CharSequence... testStrs);\npublic static String getContainsStrIgnoreCase(CharSequence str, CharSequence... testStrs);\npublic static int indexOf(CharSequence str, char searchChar);\npublic static int indexOf(CharSequence str, char searchChar, int start);\npublic static int indexOf(CharSequence text, char searchChar, int start, int end);\npublic static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr);\npublic static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int fromIndex);\npublic static int indexOf(CharSequence text, CharSequence searchStr, int from, boolean ignoreCase);\npublic static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr);\npublic static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr, int fromIndex);\npublic static int lastIndexOf(CharSequence text, CharSequence searchStr, int from, boolean ignoreCase);\npublic static int ordinalIndexOf(CharSequence str, CharSequence searchStr, int ordinal);\npublic static String removeAll(CharSequence str, CharSequence strToRemove);\npublic static String removeAny(CharSequence str, CharSequence... strsToRemove);\npublic static String removeAll(CharSequence str, char... chars);\npublic static String removeAllLineBreaks(CharSequence str);\npublic static String removePreAndLowerFirst(CharSequence str, int preLength);\npublic static String removePreAndLowerFirst(CharSequence str, CharSequence prefix);\npublic static String removePrefix(CharSequence str, CharSequence prefix);\npublic static String removePrefixIgnoreCase(CharSequence str, CharSequence prefix);\npublic static String removeSuffix(CharSequence str, CharSequence suffix);\npublic static String removeSufAndLowerFirst(CharSequence str, CharSequence suffix);\npublic static String removeSuffixIgnoreCase(CharSequence str, CharSequence suffix);\npublic static String cleanBlank(CharSequence str);\npublic static String strip(CharSequence str, CharSequence prefixOrSuffix);\npublic static String strip(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String stripIgnoreCase(CharSequence str, CharSequence prefixOrSuffix);\npublic static String stripIgnoreCase(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String addPrefixIfNot(CharSequence str, CharSequence prefix);\npublic static String addSuffixIfNot(CharSequence str, CharSequence suffix);\npublic static long[] splitToLong(CharSequence str, char separator);\npublic static long[] splitToLong(CharSequence str, CharSequence separator);\npublic static int[] splitToInt(CharSequence str, char separator);\npublic static int[] splitToInt(CharSequence str, CharSequence separator);\npublic static List<String> split(CharSequence str, char separator);\npublic static String[] splitToArray(CharSequence str, CharSequence separator);\npublic static String[] splitToArray(CharSequence str, char separator);\npublic static String[] splitToArray(CharSequence text, char separator, int limit);\npublic static List<String> split(CharSequence str, char separator, int limit);\npublic static List<String> splitTrim(CharSequence str, char separator);\npublic static List<String> splitTrim(CharSequence str, CharSequence separator);\npublic static List<String> splitTrim(CharSequence str, char separator, int limit);\npublic static List<String> splitTrim(CharSequence str, CharSequence separator, int limit);\npublic static List<String> split(CharSequence str, char separator, boolean isTrim, boolean ignoreEmpty);\npublic static List<String> split(CharSequence str, char separator, int limit, boolean isTrim, boolean ignoreEmpty);\npublic static List<R> split(CharSequence str, char separator, int limit, boolean ignoreEmpty, Function<String, R> mapping);\npublic static List<String> split(CharSequence str, CharSequence separator);\npublic static List<String> split(CharSequence str, CharSequence separator, boolean isTrim, boolean ignoreEmpty);\npublic static List<String> split(CharSequence str, CharSequence separator, int limit, boolean isTrim, boolean ignoreEmpty);\npublic static String[] split(CharSequence str, int len);\npublic static String[] cut(CharSequence str, int partLength);\npublic static String sub(CharSequence str, int fromIndexInclude, int toIndexExclude);\npublic static String subByCodePoint(CharSequence str, int fromIndex, int toIndex);\npublic static String subPreGbk(CharSequence str, int len, CharSequence suffix);\npublic static String subPreGbk(CharSequence str, int len, boolean halfUp);\npublic static String subPre(CharSequence string, int toIndexExclude);\npublic static String subSuf(CharSequence string, int fromIndex);\npublic static String subSufByLength(CharSequence string, int length);\npublic static String subWithLength(String input, int fromIndex, int length);\npublic static String subBefore(CharSequence string, CharSequence separator, boolean isLastSeparator);\npublic static String subBefore(CharSequence string, char separator, boolean isLastSeparator);\npublic static String subAfter(CharSequence string, CharSequence separator, boolean isLastSeparator);\npublic static String subAfter(CharSequence string, char separator, boolean isLastSeparator);\npublic static String subBetween(CharSequence str, CharSequence before, CharSequence after);\npublic static String subBetween(CharSequence str, CharSequence beforeAndAfter);\npublic static String[] subBetweenAll(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String[] subBetweenAll(CharSequence str, CharSequence prefixAndSuffix);\npublic static String repeat(char c, int count);\npublic static String repeat(CharSequence str, int count);\npublic static String repeatByLength(CharSequence str, int padLen);\npublic static String repeatAndJoin(CharSequence str, int count, CharSequence delimiter);\npublic static boolean equals(CharSequence str1, CharSequence str2);\npublic static boolean equalsIgnoreCase(CharSequence str1, CharSequence str2);\npublic static boolean equals(CharSequence str1, CharSequence str2, boolean ignoreCase);\npublic static boolean equalsAnyIgnoreCase(CharSequence str1, CharSequence... strs);\npublic static boolean equalsAny(CharSequence str1, CharSequence... strs);\npublic static boolean equalsAny(CharSequence str1, boolean ignoreCase, CharSequence... strs);\npublic static boolean equalsCharAt(CharSequence str, int position, char c);\npublic static boolean isSubEquals(CharSequence str1, int start1, CharSequence str2, boolean ignoreCase);\npublic static boolean isSubEquals(CharSequence str1, int start1, CharSequence str2, int start2, int length, boolean ignoreCase);\npublic static String format(CharSequence template, Object... params);\npublic static String indexedFormat(CharSequence pattern, Object... arguments);\npublic static byte[] utf8Bytes(CharSequence str);\npublic static byte[] bytes(CharSequence str);\npublic static byte[] bytes(CharSequence str, String charset);\npublic static byte[] bytes(CharSequence str, Charset charset);\npublic static ByteBuffer byteBuffer(CharSequence str, String charset);\npublic static String wrap(CharSequence str, CharSequence prefixAndSuffix);\npublic static String wrap(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String[] wrapAllWithPair(CharSequence prefixAndSuffix, CharSequence... strs);\npublic static String[] wrapAll(CharSequence prefix, CharSequence suffix, CharSequence... strs);\npublic static String wrapIfMissing(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String[] wrapAllWithPairIfMissing(CharSequence prefixAndSuffix, CharSequence... strs);\npublic static String[] wrapAllIfMissing(CharSequence prefix, CharSequence suffix, CharSequence... strs);\npublic static String unWrap(CharSequence str, String prefix, String suffix);\npublic static String unWrap(CharSequence str, char prefix, char suffix);\npublic static String unWrap(CharSequence str, char prefixAndSuffix);\npublic static boolean isWrap(CharSequence str, String prefix, String suffix);\npublic static boolean isWrap(CharSequence str, String wrapper);\npublic static boolean isWrap(CharSequence str, char wrapper);\npublic static boolean isWrap(CharSequence str, char prefixChar, char suffixChar);\npublic static String padPre(CharSequence str, int length, CharSequence padStr);\npublic static String padPre(CharSequence str, int length, char padChar);\npublic static String padAfter(CharSequence str, int length, char padChar);\npublic static String padAfter(CharSequence str, int length, CharSequence padStr);\npublic static String center(CharSequence str, final int size);\npublic static String center(CharSequence str, final int size, char padChar);\npublic static String center(CharSequence str, final int size, CharSequence padStr);\npublic static String str(CharSequence cs);\npublic static int count(CharSequence content, CharSequence strForSearch);\npublic static int count(CharSequence content, char charForSearch);\npublic static int compare(final CharSequence str1, final CharSequence str2, final boolean nullIsLess);\npublic static int compareIgnoreCase(CharSequence str1, CharSequence str2, boolean nullIsLess);\npublic static int compareVersion(CharSequence version1, CharSequence version2);\npublic static String appendIfMissing(CharSequence str, CharSequence suffix, CharSequence... suffixes);\npublic static String appendIfMissingIgnoreCase(CharSequence str, CharSequence suffix, CharSequence... suffixes);\npublic static String appendIfMissing(CharSequence str, CharSequence suffix, boolean ignoreCase, CharSequence... testSuffixes);\npublic static String prependIfMissing(CharSequence str, CharSequence prefix, CharSequence... prefixes);\npublic static String prependIfMissingIgnoreCase(CharSequence str, CharSequence prefix, CharSequence... prefixes);\npublic static String prependIfMissing(CharSequence str, CharSequence prefix, boolean ignoreCase, CharSequence... prefixes);\npublic static String replaceIgnoreCase(CharSequence str, CharSequence searchStr, CharSequence replacement);\npublic static String replace(CharSequence str, CharSequence searchStr, CharSequence replacement);\npublic static String replace(CharSequence str, CharSequence searchStr, CharSequence replacement, boolean ignoreCase);\npublic static String replace(CharSequence str, int fromIndex, CharSequence searchStr, CharSequence replacement, boolean ignoreCase);\npublic static String replace(CharSequence str, int startInclude, int endExclude, char replacedChar);\npublic static String replace(CharSequence str, int startInclude, int endExclude, CharSequence replacedStr);\npublic static String replace(CharSequence str, java.util.regex.Pattern pattern, Func1<java.util.regex.Matcher, String> replaceFun);\npublic static String replace(CharSequence str, String regex, Func1<java.util.regex.Matcher, String> replaceFun);\npublic static String replaceLast(CharSequence str, CharSequence searchStr, CharSequence replacedStr);\npublic static String replaceLast(CharSequence str, CharSequence searchStr, CharSequence replacedStr, boolean ignoreCase);\npublic static String replaceFirst(CharSequence str, CharSequence searchStr, CharSequence replacedStr);\npublic static String replaceFirst(CharSequence str, CharSequence searchStr, CharSequence replacedStr, boolean ignoreCase);\npublic static String hide(CharSequence str, int startInclude, int endExclude);\npublic static String desensitized(CharSequence str, DesensitizedUtil.DesensitizedType desensitizedType);\npublic static String replaceChars(CharSequence str, String chars, CharSequence replacedStr);\npublic static String replaceChars(CharSequence str, char[] chars, CharSequence replacedStr);\npublic static int length(CharSequence cs);\npublic static int byteLength(CharSequence cs, Charset charset);\npublic static int totalLength(CharSequence... strs);\npublic static String maxLength(CharSequence string, int length);\npublic static T firstNonNull(T... strs);\npublic static T firstNonEmpty(T... strs);\npublic static T firstNonBlank(T... strs);\npublic static String upperFirstAndAddPre(CharSequence str, String preString);\npublic static String upperFirst(CharSequence str);\npublic static String lowerFirst(CharSequence str);\npublic static String filter(CharSequence str, final Filter<Character> filter);\npublic static boolean isUpperCase(CharSequence str);\npublic static boolean isLowerCase(CharSequence str);\npublic static String swapCase(final String str);\npublic static String toUnderlineCase(CharSequence str);\npublic static String toSymbolCase(CharSequence str, char symbol);\npublic static String toCamelCase(CharSequence name);\npublic static String toCamelCase(CharSequence name, char symbol);\npublic static boolean isSurround(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static boolean isSurround(CharSequence str, char prefix, char suffix);\npublic static StringBuilder builder(CharSequence... strs);\npublic static StrBuilder strBuilder(CharSequence... strs);\npublic static String getGeneralField(CharSequence getOrSetMethodName);\npublic static String genSetter(CharSequence fieldName);\npublic static String genGetter(CharSequence fieldName);\npublic static String concat(boolean isNullToEmpty, CharSequence... strs);\npublic static String brief(CharSequence str, int maxLength);\npublic static String join(CharSequence conjunction, Object... objs);\npublic static String join(CharSequence conjunction, Iterable<T> iterable);\npublic static boolean isAllCharMatch(CharSequence value, Matcher<Character> matcher);\npublic static boolean isNumeric(CharSequence str);\npublic static String move(CharSequence str, int startInclude, int endExclude, int moveLength);\npublic static boolean isCharEquals(CharSequence str);\npublic static String normalize(CharSequence str);\npublic static String fixLength(CharSequence str, char fixedChar, int length);\npublic static boolean hasLetter(CharSequence str);\npublic static CharSequence commonPrefix(CharSequence str1, CharSequence str2);\npublic static CharSequence commonSuffix(CharSequence str1, CharSequence str2);",
        "Class_name": "CharSequenceUtil",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/text/CharSequenceUtil###subPreGbk",
        "Parameter_num": "3",
        "all_Import_statements": "import cn.hutool.core.collection.CollUtil;\n\nimport cn.hutool.core.comparator.VersionComparator;\n\nimport cn.hutool.core.convert.Convert;\n\nimport cn.hutool.core.lang.Assert;\n\nimport cn.hutool.core.lang.Filter;\n\nimport cn.hutool.core.lang.Matcher;\n\nimport cn.hutool.core.lang.func.Func1;\n\nimport cn.hutool.core.text.finder.CharFinder;\n\nimport cn.hutool.core.text.finder.Finder;\n\nimport cn.hutool.core.text.finder.StrFinder;\n\nimport cn.hutool.core.util.ArrayUtil;\n\nimport cn.hutool.core.util.CharUtil;\n\nimport cn.hutool.core.util.CharsetUtil;\n\nimport cn.hutool.core.util.DesensitizedUtil;\n\nimport cn.hutool.core.util.NumberUtil;\n\nimport cn.hutool.core.util.ReUtil;\n\nimport cn.hutool.core.util.StrUtil;\n\nimport java.nio.ByteBuffer;\n\nimport java.nio.charset.Charset;\n\nimport java.text.MessageFormat;\n\nimport java.text.Normalizer;\n\nimport java.util.HashSet;\n\nimport java.util.LinkedList;\n\nimport java.util.List;\n\nimport java.util.Set;\n\nimport java.util.function.Function;\n\nimport java.util.function.Predicate;\n",
        "comment": "\n\t * 截取部分字符串，这里一个汉字的长度认为是2<br>\n\t * 可以自定义halfUp，如len为10，如果截取后最后一个字符是半个字符，{@code true}表示保留，则长度是11，否则长度9\n\t *\n\t * @param str    字符串\n\t * @param len    bytes切割到的位置（包含）\n\t * @param halfUp 遇到截取一半的GBK字符，是否保留。\n\t * @return 切割后的字符串\n\t * @since 5.7.17\n\t ",
        "packageName": "cn.hutool.core.text",
        "method_signature": "public static String subPreGbk(CharSequence str, int len, boolean halfUp);",
        "Junit_version": "5",
        "returnType": "String"
    },
    {
        "Method_body": "public static <T> List<List<T>> split(Collection<T> collection, int size) {\n    final List<List<T>> result = new ArrayList<>();\n    if (CollUtil.isEmpty(collection)) {\n        return result;\n    }\n    final int initSize = Math.min(collection.size(), size);\n    List<T> subList = new ArrayList<>(initSize);\n    for (T t : collection) {\n        if (subList.size() >= size) {\n            result.add(subList);\n            subList = new ArrayList<>(initSize);\n        }\n        subList.add(t);\n    }\n    result.add(subList);\n    return result;\n}",
        "all_field_declaration": "",
        "sub_project_name": "hutool-core",
        "lineNumbers": "7",
        "Filed": "",
        "Parameter_type": "Collection<T>,int",
        "Import_statements": "",
        "public_method_signature": "public static Set<T> emptyIfNull(Set<T> set);\npublic static List<T> emptyIfNull(List<T> list);\npublic static Collection<T> union(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> union(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Set<T> unionDistinct(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static List<T> unionAll(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Collection<T> intersection(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> intersection(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Set<T> intersectionDistinct(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Collection<T> disjunction(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> subtract(Collection<T> coll1, Collection<T> coll2);\npublic static List<T> subtractToList(Collection<T> coll1, Collection<T> coll2);\npublic static boolean contains(Collection<?> collection, Object value);\npublic static boolean safeContains(Collection<?> collection, Object value);\npublic static boolean contains(Collection<T> collection, Predicate<? super T> containFunc);\npublic static boolean containsAny(Collection<?> coll1, Collection<?> coll2);\npublic static boolean containsAll(Collection<?> coll1, Collection<?> coll2);\npublic static Map<T, Integer> countMap(Iterable<T> collection);\npublic static String join(Iterable<T> iterable, CharSequence conjunction, Function<T, ? extends CharSequence> func);\npublic static String join(Iterable<T> iterable, CharSequence conjunction);\npublic static String join(Iterable<T> iterable, CharSequence conjunction, String prefix, String suffix);\npublic static String join(Iterator<T> iterator, CharSequence conjunction);\npublic static List<T> popPart(Stack<T> surplusAlaDatas, int partSize);\npublic static List<T> popPart(Deque<T> surplusAlaDatas, int partSize);\npublic static HashSet<T> newHashSet(T... ts);\npublic static LinkedHashSet<T> newLinkedHashSet(T... ts);\npublic static HashSet<T> set(boolean isSorted, T... ts);\npublic static HashSet<T> newHashSet(Collection<T> collection);\npublic static HashSet<T> newHashSet(boolean isSorted, Collection<T> collection);\npublic static HashSet<T> newHashSet(boolean isSorted, Iterator<T> iter);\npublic static HashSet<T> newHashSet(boolean isSorted, Enumeration<T> enumeration);\npublic static List<T> list(boolean isLinked);\npublic static List<T> list(boolean isLinked, T... values);\npublic static List<T> list(boolean isLinked, Collection<T> collection);\npublic static List<T> list(boolean isLinked, Iterable<T> iterable);\npublic static List<T> list(boolean isLinked, Iterator<T> iter);\npublic static List<T> list(boolean isLinked, Enumeration<T> enumeration);\npublic static ArrayList<T> newArrayList(T... values);\npublic static ArrayList<T> toList(T... values);\npublic static ArrayList<T> newArrayList(Collection<T> collection);\npublic static ArrayList<T> newArrayList(Iterable<T> iterable);\npublic static ArrayList<T> newArrayList(Iterator<T> iterator);\npublic static ArrayList<T> newArrayList(Enumeration<T> enumeration);\npublic static LinkedList<T> newLinkedList(T... values);\npublic static CopyOnWriteArrayList<T> newCopyOnWriteArrayList(Collection<T> collection);\npublic static BlockingQueue<T> newBlockingQueue(int capacity, boolean isLinked);\npublic static Collection<T> create(Class<?> collectionType);\npublic static Collection<T> create(Class<?> collectionType, Class<T> elementType);\npublic static ArrayList<T> distinct(Collection<T> collection);\npublic static List<T> distinct(Collection<T> collection, Function<T, K> uniqueGenerator, boolean override);\npublic static List<T> sub(List<T> list, int start, int end);\npublic static List<T> sub(List<T> list, int start, int end, int step);\npublic static List<T> sub(Collection<T> collection, int start, int end);\npublic static List<T> sub(Collection<T> collection, int start, int end, int step);\npublic static List<List<T>> splitList(List<T> list, int size);\npublic static List<List<T>> split(Collection<T> collection, int size);\npublic static Collection<T> edit(Collection<T> collection, Editor<T> editor);\npublic static Collection<T> filterNew(Collection<T> collection, Filter<T> filter);\npublic static T removeAny(T collection, E... elesRemoved);\npublic static T filter(T collection, final Filter<E> filter);\npublic static T removeNull(T collection);\npublic static T removeEmpty(T collection);\npublic static T removeBlank(T collection);\npublic static T removeWithAddIf(T targetCollection, T resultCollection, Predicate<? super E> predicate);\npublic static List<E> removeWithAddIf(T targetCollection, Predicate<? super E> predicate);\npublic static List<Object> extract(Iterable<?> collection, Editor<Object> editor);\npublic static List<Object> extract(Iterable<?> collection, Editor<Object> editor, boolean ignoreNull);\npublic static List<R> map(Iterable<T> collection, Function<? super T, ? extends R> func, boolean ignoreNull);\npublic static List<Object> getFieldValues(Iterable<?> collection, final String fieldName);\npublic static List<Object> getFieldValues(Iterable<?> collection, final String fieldName, boolean ignoreNull);\npublic static List<T> getFieldValues(Iterable<?> collection, final String fieldName, final Class<T> elementType);\npublic static Map<K, V> fieldValueMap(Iterable<V> iterable, String fieldName);\npublic static Map<K, V> fieldValueAsMap(Iterable<?> iterable, String fieldNameForKey, String fieldNameForValue);\npublic static T findOne(Iterable<T> collection, Filter<T> filter);\npublic static T findOneByField(Iterable<T> collection, final String fieldName, final Object fieldValue);\npublic static int count(Iterable<T> iterable, Matcher<T> matcher);\npublic static int indexOf(Collection<T> collection, Matcher<T> matcher);\npublic static int lastIndexOf(Collection<T> collection, Matcher<T> matcher);\npublic static int[] indexOfAll(Collection<T> collection, Matcher<T> matcher);\npublic static boolean isEmpty(Collection<?> collection);\npublic static T defaultIfEmpty(T collection, T defaultCollection);\npublic static T defaultIfEmpty(T collection, Supplier<? extends T> supplier);\npublic static boolean isEmpty(Iterable<?> iterable);\npublic static boolean isEmpty(Iterator<?> Iterator);\npublic static boolean isEmpty(Enumeration<?> enumeration);\npublic static boolean isEmpty(Map<?, ?> map);\npublic static boolean isNotEmpty(Collection<?> collection);\npublic static boolean isNotEmpty(Iterable<?> iterable);\npublic static boolean isNotEmpty(Iterator<?> Iterator);\npublic static boolean isNotEmpty(Enumeration<?> enumeration);\npublic static boolean hasNull(Iterable<?> iterable);\npublic static boolean isNotEmpty(Map<?, ?> map);\npublic static Map<String, String> zip(String keys, String values, String delimiter, boolean isOrder);\npublic static Map<String, String> zip(String keys, String values, String delimiter);\npublic static Map<K, V> zip(Collection<K> keys, Collection<V> values);\npublic static HashMap<K, V> toMap(Iterable<Entry<K, V>> entryIter);\npublic static HashMap<Object, Object> toMap(Object[] array);\npublic static TreeSet<T> toTreeSet(Collection<T> collection, Comparator<T> comparator);\npublic static Enumeration<E> asEnumeration(Iterator<E> iter);\npublic static Iterator<E> asIterator(Enumeration<E> e);\npublic static Iterable<E> asIterable(final Iterator<E> iter);\npublic static Collection<E> toCollection(Iterable<E> iterable);\npublic static Map<K, List<V>> toListMap(Iterable<? extends Map<K, V>> mapList);\npublic static List<Map<K, V>> toMapList(Map<K, ? extends Iterable<V>> listMap);\npublic static Map<K, V> toMap(Iterable<V> values, Map<K, V> map, Func1<V, K> keyFunc);\npublic static Map<K, V> toMap(Iterable<E> values, Map<K, V> map, Func1<E, K> keyFunc, Func1<E, V> valueFunc);\npublic static boolean addIfAbsent(Collection<T> collection, S object);\npublic static Collection<T> addAll(Collection<T> collection, Object value);\npublic static Collection<T> addAll(Collection<T> collection, Object value, Type elementType);\npublic static Collection<T> addAll(Collection<T> collection, Iterator<T> iterator);\npublic static Collection<T> addAll(Collection<T> collection, Iterable<T> iterable);\npublic static Collection<T> addAll(Collection<T> collection, Enumeration<T> enumeration);\npublic static Collection<T> addAll(Collection<T> collection, T[] values);\npublic static List<T> addAllIfNotContains(List<T> list, List<T> otherList);\npublic static T get(Collection<T> collection, int index);\npublic static List<T> getAny(Collection<T> collection, int... indexes);\npublic static T getFirst(Iterable<T> iterable);\npublic static T getFirst(Iterator<T> iterator);\npublic static T getLast(Collection<T> collection);\npublic static Class<?> getElementType(Iterable<?> iterable);\npublic static Class<?> getElementType(Iterator<?> iterator);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, K... keys);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, Iterable<K> keys);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, Iterator<K> keys);\npublic static List<T> sortPageAll(int pageNo, int pageSize, Comparator<T> comparator, Collection<T>... colls);\npublic static List<T> page(int pageNo, int pageSize, List<T> list);\npublic static List<T> sort(Collection<T> collection, Comparator<? super T> comparator);\npublic static List<T> sort(List<T> list, Comparator<? super T> c);\npublic static List<T> sortByProperty(Collection<T> collection, String property);\npublic static List<T> sortByProperty(List<T> list, String property);\npublic static List<String> sortByPinyin(Collection<String> collection);\npublic static List<String> sortByPinyin(List<String> list);\npublic static TreeMap<K, V> sort(Map<K, V> map, Comparator<? super K> comparator);\npublic static LinkedHashMap<K, V> sortToMap(Collection<Map.Entry<K, V>> entryCollection, Comparator<Map.Entry<K, V>> comparator);\npublic static LinkedHashMap<K, V> sortByEntry(Map<K, V> map, Comparator<Map.Entry<K, V>> comparator);\npublic static List<Entry<K, V>> sortEntryToList(Collection<Entry<K, V>> collection);\npublic static void forEach(Iterable<T> iterable, Consumer<T> consumer);\npublic static void forEach(Iterator<T> iterator, Consumer<T> consumer);\npublic static void forEach(Enumeration<T> enumeration, Consumer<T> consumer);\npublic static void forEach(Map<K, V> map, KVConsumer<K, V> kvConsumer);\npublic static List<List<T>> group(Collection<T> collection, Hash32<T> hash);\npublic static List<List<T>> groupByField(Collection<T> collection, final String fieldName);\npublic static List<T> reverse(List<T> list);\npublic static List<T> reverseNew(List<T> list);\npublic static List<T> setOrAppend(List<T> list, int index, T element);\npublic static Set<K> keySet(Collection<Map<K, ?>> mapCollection);\npublic static List<V> values(Collection<Map<?, V>> mapCollection);\npublic static T max(Collection<T> coll);\npublic static T min(Collection<T> coll);\npublic static Collection<T> unmodifiable(Collection<? extends T> c);\npublic static T empty(Class<?> collectionClass);\npublic static void clear(Collection<?>... collections);\npublic static void padLeft(List<T> list, int minLen, T padObj);\npublic static void padRight(Collection<T> list, int minLen, T padObj);\npublic static Collection<T> trans(Collection<F> collection, Function<? super F, ? extends T> function);\npublic static void setValueByMap(Iterable<E> iterable, Map<K, V> map, Function<E, K> keyGenerate, BiConsumer<E, V> biConsumer);\npublic static int size(final Object object);\npublic static boolean isEqualList(final Collection<?> list1, final Collection<?> list2);",
        "public_field": "",
        "Method_statement": "split(Collection<T> collection, int size)",
        "Method_name": "split",
        "Class_declaration": "public class CollUtil {\n",
        "constructors": "",
        "all_method_signature": "public static Set<T> emptyIfNull(Set<T> set);\npublic static List<T> emptyIfNull(List<T> list);\npublic static Collection<T> union(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> union(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Set<T> unionDistinct(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static List<T> unionAll(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Collection<T> intersection(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> intersection(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Set<T> intersectionDistinct(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Collection<T> disjunction(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> subtract(Collection<T> coll1, Collection<T> coll2);\npublic static List<T> subtractToList(Collection<T> coll1, Collection<T> coll2);\npublic static boolean contains(Collection<?> collection, Object value);\npublic static boolean safeContains(Collection<?> collection, Object value);\npublic static boolean contains(Collection<T> collection, Predicate<? super T> containFunc);\npublic static boolean containsAny(Collection<?> coll1, Collection<?> coll2);\npublic static boolean containsAll(Collection<?> coll1, Collection<?> coll2);\npublic static Map<T, Integer> countMap(Iterable<T> collection);\npublic static String join(Iterable<T> iterable, CharSequence conjunction, Function<T, ? extends CharSequence> func);\npublic static String join(Iterable<T> iterable, CharSequence conjunction);\npublic static String join(Iterable<T> iterable, CharSequence conjunction, String prefix, String suffix);\npublic static String join(Iterator<T> iterator, CharSequence conjunction);\npublic static List<T> popPart(Stack<T> surplusAlaDatas, int partSize);\npublic static List<T> popPart(Deque<T> surplusAlaDatas, int partSize);\npublic static HashSet<T> newHashSet(T... ts);\npublic static LinkedHashSet<T> newLinkedHashSet(T... ts);\npublic static HashSet<T> set(boolean isSorted, T... ts);\npublic static HashSet<T> newHashSet(Collection<T> collection);\npublic static HashSet<T> newHashSet(boolean isSorted, Collection<T> collection);\npublic static HashSet<T> newHashSet(boolean isSorted, Iterator<T> iter);\npublic static HashSet<T> newHashSet(boolean isSorted, Enumeration<T> enumeration);\npublic static List<T> list(boolean isLinked);\npublic static List<T> list(boolean isLinked, T... values);\npublic static List<T> list(boolean isLinked, Collection<T> collection);\npublic static List<T> list(boolean isLinked, Iterable<T> iterable);\npublic static List<T> list(boolean isLinked, Iterator<T> iter);\npublic static List<T> list(boolean isLinked, Enumeration<T> enumeration);\npublic static ArrayList<T> newArrayList(T... values);\npublic static ArrayList<T> toList(T... values);\npublic static ArrayList<T> newArrayList(Collection<T> collection);\npublic static ArrayList<T> newArrayList(Iterable<T> iterable);\npublic static ArrayList<T> newArrayList(Iterator<T> iterator);\npublic static ArrayList<T> newArrayList(Enumeration<T> enumeration);\npublic static LinkedList<T> newLinkedList(T... values);\npublic static CopyOnWriteArrayList<T> newCopyOnWriteArrayList(Collection<T> collection);\npublic static BlockingQueue<T> newBlockingQueue(int capacity, boolean isLinked);\npublic static Collection<T> create(Class<?> collectionType);\npublic static Collection<T> create(Class<?> collectionType, Class<T> elementType);\npublic static ArrayList<T> distinct(Collection<T> collection);\npublic static List<T> distinct(Collection<T> collection, Function<T, K> uniqueGenerator, boolean override);\npublic static List<T> sub(List<T> list, int start, int end);\npublic static List<T> sub(List<T> list, int start, int end, int step);\npublic static List<T> sub(Collection<T> collection, int start, int end);\npublic static List<T> sub(Collection<T> collection, int start, int end, int step);\npublic static List<List<T>> splitList(List<T> list, int size);\npublic static List<List<T>> split(Collection<T> collection, int size);\npublic static Collection<T> edit(Collection<T> collection, Editor<T> editor);\npublic static Collection<T> filterNew(Collection<T> collection, Filter<T> filter);\npublic static T removeAny(T collection, E... elesRemoved);\npublic static T filter(T collection, final Filter<E> filter);\npublic static T removeNull(T collection);\npublic static T removeEmpty(T collection);\npublic static T removeBlank(T collection);\npublic static T removeWithAddIf(T targetCollection, T resultCollection, Predicate<? super E> predicate);\npublic static List<E> removeWithAddIf(T targetCollection, Predicate<? super E> predicate);\npublic static List<Object> extract(Iterable<?> collection, Editor<Object> editor);\npublic static List<Object> extract(Iterable<?> collection, Editor<Object> editor, boolean ignoreNull);\npublic static List<R> map(Iterable<T> collection, Function<? super T, ? extends R> func, boolean ignoreNull);\npublic static List<Object> getFieldValues(Iterable<?> collection, final String fieldName);\npublic static List<Object> getFieldValues(Iterable<?> collection, final String fieldName, boolean ignoreNull);\npublic static List<T> getFieldValues(Iterable<?> collection, final String fieldName, final Class<T> elementType);\npublic static Map<K, V> fieldValueMap(Iterable<V> iterable, String fieldName);\npublic static Map<K, V> fieldValueAsMap(Iterable<?> iterable, String fieldNameForKey, String fieldNameForValue);\npublic static T findOne(Iterable<T> collection, Filter<T> filter);\npublic static T findOneByField(Iterable<T> collection, final String fieldName, final Object fieldValue);\npublic static int count(Iterable<T> iterable, Matcher<T> matcher);\npublic static int indexOf(Collection<T> collection, Matcher<T> matcher);\npublic static int lastIndexOf(Collection<T> collection, Matcher<T> matcher);\npublic static int[] indexOfAll(Collection<T> collection, Matcher<T> matcher);\npublic static boolean isEmpty(Collection<?> collection);\npublic static T defaultIfEmpty(T collection, T defaultCollection);\npublic static T defaultIfEmpty(T collection, Supplier<? extends T> supplier);\npublic static boolean isEmpty(Iterable<?> iterable);\npublic static boolean isEmpty(Iterator<?> Iterator);\npublic static boolean isEmpty(Enumeration<?> enumeration);\npublic static boolean isEmpty(Map<?, ?> map);\npublic static boolean isNotEmpty(Collection<?> collection);\npublic static boolean isNotEmpty(Iterable<?> iterable);\npublic static boolean isNotEmpty(Iterator<?> Iterator);\npublic static boolean isNotEmpty(Enumeration<?> enumeration);\npublic static boolean hasNull(Iterable<?> iterable);\npublic static boolean isNotEmpty(Map<?, ?> map);\npublic static Map<String, String> zip(String keys, String values, String delimiter, boolean isOrder);\npublic static Map<String, String> zip(String keys, String values, String delimiter);\npublic static Map<K, V> zip(Collection<K> keys, Collection<V> values);\npublic static HashMap<K, V> toMap(Iterable<Entry<K, V>> entryIter);\npublic static HashMap<Object, Object> toMap(Object[] array);\npublic static TreeSet<T> toTreeSet(Collection<T> collection, Comparator<T> comparator);\npublic static Enumeration<E> asEnumeration(Iterator<E> iter);\npublic static Iterator<E> asIterator(Enumeration<E> e);\npublic static Iterable<E> asIterable(final Iterator<E> iter);\npublic static Collection<E> toCollection(Iterable<E> iterable);\npublic static Map<K, List<V>> toListMap(Iterable<? extends Map<K, V>> mapList);\npublic static List<Map<K, V>> toMapList(Map<K, ? extends Iterable<V>> listMap);\npublic static Map<K, V> toMap(Iterable<V> values, Map<K, V> map, Func1<V, K> keyFunc);\npublic static Map<K, V> toMap(Iterable<E> values, Map<K, V> map, Func1<E, K> keyFunc, Func1<E, V> valueFunc);\npublic static boolean addIfAbsent(Collection<T> collection, S object);\npublic static Collection<T> addAll(Collection<T> collection, Object value);\npublic static Collection<T> addAll(Collection<T> collection, Object value, Type elementType);\npublic static Collection<T> addAll(Collection<T> collection, Iterator<T> iterator);\npublic static Collection<T> addAll(Collection<T> collection, Iterable<T> iterable);\npublic static Collection<T> addAll(Collection<T> collection, Enumeration<T> enumeration);\npublic static Collection<T> addAll(Collection<T> collection, T[] values);\npublic static List<T> addAllIfNotContains(List<T> list, List<T> otherList);\npublic static T get(Collection<T> collection, int index);\npublic static List<T> getAny(Collection<T> collection, int... indexes);\npublic static T getFirst(Iterable<T> iterable);\npublic static T getFirst(Iterator<T> iterator);\npublic static T getLast(Collection<T> collection);\npublic static Class<?> getElementType(Iterable<?> iterable);\npublic static Class<?> getElementType(Iterator<?> iterator);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, K... keys);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, Iterable<K> keys);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, Iterator<K> keys);\npublic static List<T> sortPageAll(int pageNo, int pageSize, Comparator<T> comparator, Collection<T>... colls);\npublic static List<T> page(int pageNo, int pageSize, List<T> list);\npublic static List<T> sort(Collection<T> collection, Comparator<? super T> comparator);\npublic static List<T> sort(List<T> list, Comparator<? super T> c);\npublic static List<T> sortByProperty(Collection<T> collection, String property);\npublic static List<T> sortByProperty(List<T> list, String property);\npublic static List<String> sortByPinyin(Collection<String> collection);\npublic static List<String> sortByPinyin(List<String> list);\npublic static TreeMap<K, V> sort(Map<K, V> map, Comparator<? super K> comparator);\npublic static LinkedHashMap<K, V> sortToMap(Collection<Map.Entry<K, V>> entryCollection, Comparator<Map.Entry<K, V>> comparator);\npublic static LinkedHashMap<K, V> sortByEntry(Map<K, V> map, Comparator<Map.Entry<K, V>> comparator);\npublic static List<Entry<K, V>> sortEntryToList(Collection<Entry<K, V>> collection);\npublic static void forEach(Iterable<T> iterable, Consumer<T> consumer);\npublic static void forEach(Iterator<T> iterator, Consumer<T> consumer);\npublic static void forEach(Enumeration<T> enumeration, Consumer<T> consumer);\npublic static void forEach(Map<K, V> map, KVConsumer<K, V> kvConsumer);\npublic static List<List<T>> group(Collection<T> collection, Hash32<T> hash);\npublic static List<List<T>> groupByField(Collection<T> collection, final String fieldName);\npublic static List<T> reverse(List<T> list);\npublic static List<T> reverseNew(List<T> list);\npublic static List<T> setOrAppend(List<T> list, int index, T element);\npublic static Set<K> keySet(Collection<Map<K, ?>> mapCollection);\npublic static List<V> values(Collection<Map<?, V>> mapCollection);\npublic static T max(Collection<T> coll);\npublic static T min(Collection<T> coll);\npublic static Collection<T> unmodifiable(Collection<? extends T> c);\npublic static T empty(Class<?> collectionClass);\npublic static void clear(Collection<?>... collections);\npublic static void padLeft(List<T> list, int minLen, T padObj);\npublic static void padRight(Collection<T> list, int minLen, T padObj);\npublic static Collection<T> trans(Collection<F> collection, Function<? super F, ? extends T> function);\npublic static void setValueByMap(Iterable<E> iterable, Map<K, V> map, Function<E, K> keyGenerate, BiConsumer<E, V> biConsumer);\npublic static int size(final Object object);\npublic static boolean isEqualList(final Collection<?> list1, final Collection<?> list2);",
        "Class_name": "CollUtil",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/collection/CollUtil###split",
        "Parameter_num": "2",
        "all_Import_statements": "import cn.hutool.core.bean.BeanUtil;\n\nimport cn.hutool.core.comparator.CompareUtil;\n\nimport cn.hutool.core.comparator.PinyinComparator;\n\nimport cn.hutool.core.comparator.PropertyComparator;\n\nimport cn.hutool.core.convert.Convert;\n\nimport cn.hutool.core.convert.ConverterRegistry;\n\nimport cn.hutool.core.exceptions.UtilException;\n\nimport cn.hutool.core.lang.Assert;\n\nimport cn.hutool.core.lang.Editor;\n\nimport cn.hutool.core.lang.Filter;\n\nimport cn.hutool.core.lang.Matcher;\n\nimport cn.hutool.core.lang.func.Func1;\n\nimport cn.hutool.core.lang.hash.Hash32;\n\nimport cn.hutool.core.map.MapUtil;\n\nimport cn.hutool.core.util.*;\n\nimport java.io.Serializable;\n\nimport java.lang.reflect.Type;\n\nimport java.util.*;\n\nimport java.util.Map.Entry;\n\nimport java.util.concurrent.ArrayBlockingQueue;\n\nimport java.util.concurrent.BlockingQueue;\n\nimport java.util.concurrent.CopyOnWriteArrayList;\n\nimport java.util.concurrent.LinkedBlockingDeque;\n\nimport java.util.function.BiConsumer;\n\nimport java.util.function.Function;\n\nimport java.util.function.Predicate;\n\nimport java.util.function.Supplier;\n",
        "comment": "\n\t * 对集合按照指定长度分段，每一个段为单独的集合，返回这个集合的列表\n\t *\n\t * @param <T>        集合元素类型\n\t * @param collection 集合\n\t * @param size       每个段的长度\n\t * @return 分段列表\n\t ",
        "packageName": "cn.hutool.core.collection",
        "method_signature": "public static List<List<T>> split(Collection<T> collection, int size);",
        "Junit_version": "5",
        "returnType": "List<List<T>>"
    },
    {
        "Method_body": "public static boolean startWith(CharSequence str, CharSequence prefix, boolean ignoreCase, boolean ignoreEquals) {\n    if (null == str || null == prefix) {\n        if (ignoreEquals) {\n            return false;\n        }\n        return null == str && null == prefix;\n    }\n    boolean isStartWith = str.toString().regionMatches(ignoreCase, 0, prefix.toString(), 0, prefix.length());\n    if (isStartWith) {\n        return (false == ignoreEquals) || (false == equals(str, prefix, ignoreCase));\n    }\n    return false;\n}",
        "all_field_declaration": "public static final int INDEX_NOT_FOUND = Finder.INDEX_NOT_FOUND;\n/**\n * 字符串常量：{@code \"null\"} <br>\n * 注意：{@code \"null\" != null}\n */\npublic static final String NULL = \"null\";\n/**\n * 字符串常量：空字符串 {@code \"\"}\n */\npublic static final String EMPTY = \"\";\n/**\n * 字符串常量：空格符 {@code \" \"}\n */\npublic static final String SPACE = \" \";",
        "sub_project_name": "hutool-core",
        "lineNumbers": "4",
        "Filed": "",
        "Parameter_type": "CharSequence,CharSequence,boolean,boolean",
        "Import_statements": "",
        "public_method_signature": "public static boolean isBlank(CharSequence str);\npublic static boolean isNotBlank(CharSequence str);\npublic static boolean hasBlank(CharSequence... strs);\npublic static boolean isAllBlank(CharSequence... strs);\npublic static boolean isEmpty(CharSequence str);\npublic static boolean isNotEmpty(CharSequence str);\npublic static String emptyIfNull(CharSequence str);\npublic static String nullToEmpty(CharSequence str);\npublic static String nullToDefault(CharSequence str, String defaultStr);\npublic static String emptyToDefault(CharSequence str, String defaultStr);\npublic static String blankToDefault(CharSequence str, String defaultStr);\npublic static String emptyToNull(CharSequence str);\npublic static boolean hasEmpty(CharSequence... strs);\npublic static boolean isAllEmpty(CharSequence... strs);\npublic static boolean isAllNotEmpty(CharSequence... args);\npublic static boolean isAllNotBlank(CharSequence... args);\npublic static boolean isNullOrUndefined(CharSequence str);\npublic static boolean isEmptyOrUndefined(CharSequence str);\npublic static boolean isBlankOrUndefined(CharSequence str);\npublic static String trim(CharSequence str);\npublic static String trimToEmpty(CharSequence str);\npublic static String trimToNull(CharSequence str);\npublic static String trimStart(CharSequence str);\npublic static String trimEnd(CharSequence str);\npublic static String trim(CharSequence str, int mode);\npublic static String trim(CharSequence str, int mode, Predicate<Character> predicate);\npublic static boolean startWith(CharSequence str, char c);\npublic static boolean startWith(CharSequence str, CharSequence prefix, boolean ignoreCase);\npublic static boolean startWith(CharSequence str, CharSequence prefix, boolean ignoreCase, boolean ignoreEquals);\npublic static boolean startWith(CharSequence str, CharSequence prefix);\npublic static boolean startWithIgnoreEquals(CharSequence str, CharSequence prefix);\npublic static boolean startWithIgnoreCase(CharSequence str, CharSequence prefix);\npublic static boolean startWithAny(CharSequence str, CharSequence... prefixes);\npublic static boolean startWithAnyIgnoreCase(final CharSequence str, final CharSequence... suffixes);\npublic static boolean endWith(CharSequence str, char c);\npublic static boolean endWith(CharSequence str, CharSequence suffix, boolean ignoreCase);\npublic static boolean endWith(CharSequence str, CharSequence suffix, boolean ignoreCase, boolean ignoreEquals);\npublic static boolean endWith(CharSequence str, CharSequence suffix);\npublic static boolean endWithIgnoreCase(CharSequence str, CharSequence suffix);\npublic static boolean endWithAny(CharSequence str, CharSequence... suffixes);\npublic static boolean endWithAnyIgnoreCase(CharSequence str, CharSequence... suffixes);\npublic static boolean contains(CharSequence str, char searchChar);\npublic static boolean contains(CharSequence str, CharSequence searchStr);\npublic static boolean containsAny(CharSequence str, CharSequence... testStrs);\npublic static boolean containsAny(CharSequence str, char... testChars);\npublic static boolean containsOnly(CharSequence str, char... testChars);\npublic static boolean containsAll(CharSequence str, CharSequence... testChars);\npublic static boolean containsBlank(CharSequence str);\npublic static String getContainsStr(CharSequence str, CharSequence... testStrs);\npublic static boolean containsIgnoreCase(CharSequence str, CharSequence testStr);\npublic static boolean containsAnyIgnoreCase(CharSequence str, CharSequence... testStrs);\npublic static String getContainsStrIgnoreCase(CharSequence str, CharSequence... testStrs);\npublic static int indexOf(CharSequence str, char searchChar);\npublic static int indexOf(CharSequence str, char searchChar, int start);\npublic static int indexOf(CharSequence text, char searchChar, int start, int end);\npublic static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr);\npublic static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int fromIndex);\npublic static int indexOf(CharSequence text, CharSequence searchStr, int from, boolean ignoreCase);\npublic static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr);\npublic static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr, int fromIndex);\npublic static int lastIndexOf(CharSequence text, CharSequence searchStr, int from, boolean ignoreCase);\npublic static int ordinalIndexOf(CharSequence str, CharSequence searchStr, int ordinal);\npublic static String removeAll(CharSequence str, CharSequence strToRemove);\npublic static String removeAny(CharSequence str, CharSequence... strsToRemove);\npublic static String removeAll(CharSequence str, char... chars);\npublic static String removeAllLineBreaks(CharSequence str);\npublic static String removePreAndLowerFirst(CharSequence str, int preLength);\npublic static String removePreAndLowerFirst(CharSequence str, CharSequence prefix);\npublic static String removePrefix(CharSequence str, CharSequence prefix);\npublic static String removePrefixIgnoreCase(CharSequence str, CharSequence prefix);\npublic static String removeSuffix(CharSequence str, CharSequence suffix);\npublic static String removeSufAndLowerFirst(CharSequence str, CharSequence suffix);\npublic static String removeSuffixIgnoreCase(CharSequence str, CharSequence suffix);\npublic static String cleanBlank(CharSequence str);\npublic static String strip(CharSequence str, CharSequence prefixOrSuffix);\npublic static String strip(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String stripIgnoreCase(CharSequence str, CharSequence prefixOrSuffix);\npublic static String stripIgnoreCase(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String addPrefixIfNot(CharSequence str, CharSequence prefix);\npublic static String addSuffixIfNot(CharSequence str, CharSequence suffix);\npublic static long[] splitToLong(CharSequence str, char separator);\npublic static long[] splitToLong(CharSequence str, CharSequence separator);\npublic static int[] splitToInt(CharSequence str, char separator);\npublic static int[] splitToInt(CharSequence str, CharSequence separator);\npublic static List<String> split(CharSequence str, char separator);\npublic static String[] splitToArray(CharSequence str, CharSequence separator);\npublic static String[] splitToArray(CharSequence str, char separator);\npublic static String[] splitToArray(CharSequence text, char separator, int limit);\npublic static List<String> split(CharSequence str, char separator, int limit);\npublic static List<String> splitTrim(CharSequence str, char separator);\npublic static List<String> splitTrim(CharSequence str, CharSequence separator);\npublic static List<String> splitTrim(CharSequence str, char separator, int limit);\npublic static List<String> splitTrim(CharSequence str, CharSequence separator, int limit);\npublic static List<String> split(CharSequence str, char separator, boolean isTrim, boolean ignoreEmpty);\npublic static List<String> split(CharSequence str, char separator, int limit, boolean isTrim, boolean ignoreEmpty);\npublic static List<R> split(CharSequence str, char separator, int limit, boolean ignoreEmpty, Function<String, R> mapping);\npublic static List<String> split(CharSequence str, CharSequence separator);\npublic static List<String> split(CharSequence str, CharSequence separator, boolean isTrim, boolean ignoreEmpty);\npublic static List<String> split(CharSequence str, CharSequence separator, int limit, boolean isTrim, boolean ignoreEmpty);\npublic static String[] split(CharSequence str, int len);\npublic static String[] cut(CharSequence str, int partLength);\npublic static String sub(CharSequence str, int fromIndexInclude, int toIndexExclude);\npublic static String subByCodePoint(CharSequence str, int fromIndex, int toIndex);\npublic static String subPreGbk(CharSequence str, int len, CharSequence suffix);\npublic static String subPreGbk(CharSequence str, int len, boolean halfUp);\npublic static String subPre(CharSequence string, int toIndexExclude);\npublic static String subSuf(CharSequence string, int fromIndex);\npublic static String subSufByLength(CharSequence string, int length);\npublic static String subWithLength(String input, int fromIndex, int length);\npublic static String subBefore(CharSequence string, CharSequence separator, boolean isLastSeparator);\npublic static String subBefore(CharSequence string, char separator, boolean isLastSeparator);\npublic static String subAfter(CharSequence string, CharSequence separator, boolean isLastSeparator);\npublic static String subAfter(CharSequence string, char separator, boolean isLastSeparator);\npublic static String subBetween(CharSequence str, CharSequence before, CharSequence after);\npublic static String subBetween(CharSequence str, CharSequence beforeAndAfter);\npublic static String[] subBetweenAll(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String[] subBetweenAll(CharSequence str, CharSequence prefixAndSuffix);\npublic static String repeat(char c, int count);\npublic static String repeat(CharSequence str, int count);\npublic static String repeatByLength(CharSequence str, int padLen);\npublic static String repeatAndJoin(CharSequence str, int count, CharSequence delimiter);\npublic static boolean equals(CharSequence str1, CharSequence str2);\npublic static boolean equalsIgnoreCase(CharSequence str1, CharSequence str2);\npublic static boolean equals(CharSequence str1, CharSequence str2, boolean ignoreCase);\npublic static boolean equalsAnyIgnoreCase(CharSequence str1, CharSequence... strs);\npublic static boolean equalsAny(CharSequence str1, CharSequence... strs);\npublic static boolean equalsAny(CharSequence str1, boolean ignoreCase, CharSequence... strs);\npublic static boolean equalsCharAt(CharSequence str, int position, char c);\npublic static boolean isSubEquals(CharSequence str1, int start1, CharSequence str2, boolean ignoreCase);\npublic static boolean isSubEquals(CharSequence str1, int start1, CharSequence str2, int start2, int length, boolean ignoreCase);\npublic static String format(CharSequence template, Object... params);\npublic static String indexedFormat(CharSequence pattern, Object... arguments);\npublic static byte[] utf8Bytes(CharSequence str);\npublic static byte[] bytes(CharSequence str);\npublic static byte[] bytes(CharSequence str, String charset);\npublic static byte[] bytes(CharSequence str, Charset charset);\npublic static ByteBuffer byteBuffer(CharSequence str, String charset);\npublic static String wrap(CharSequence str, CharSequence prefixAndSuffix);\npublic static String wrap(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String[] wrapAllWithPair(CharSequence prefixAndSuffix, CharSequence... strs);\npublic static String[] wrapAll(CharSequence prefix, CharSequence suffix, CharSequence... strs);\npublic static String wrapIfMissing(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String[] wrapAllWithPairIfMissing(CharSequence prefixAndSuffix, CharSequence... strs);\npublic static String[] wrapAllIfMissing(CharSequence prefix, CharSequence suffix, CharSequence... strs);\npublic static String unWrap(CharSequence str, String prefix, String suffix);\npublic static String unWrap(CharSequence str, char prefix, char suffix);\npublic static String unWrap(CharSequence str, char prefixAndSuffix);\npublic static boolean isWrap(CharSequence str, String prefix, String suffix);\npublic static boolean isWrap(CharSequence str, String wrapper);\npublic static boolean isWrap(CharSequence str, char wrapper);\npublic static boolean isWrap(CharSequence str, char prefixChar, char suffixChar);\npublic static String padPre(CharSequence str, int length, CharSequence padStr);\npublic static String padPre(CharSequence str, int length, char padChar);\npublic static String padAfter(CharSequence str, int length, char padChar);\npublic static String padAfter(CharSequence str, int length, CharSequence padStr);\npublic static String center(CharSequence str, final int size);\npublic static String center(CharSequence str, final int size, char padChar);\npublic static String center(CharSequence str, final int size, CharSequence padStr);\npublic static String str(CharSequence cs);\npublic static int count(CharSequence content, CharSequence strForSearch);\npublic static int count(CharSequence content, char charForSearch);\npublic static int compare(final CharSequence str1, final CharSequence str2, final boolean nullIsLess);\npublic static int compareIgnoreCase(CharSequence str1, CharSequence str2, boolean nullIsLess);\npublic static int compareVersion(CharSequence version1, CharSequence version2);\npublic static String appendIfMissing(CharSequence str, CharSequence suffix, CharSequence... suffixes);\npublic static String appendIfMissingIgnoreCase(CharSequence str, CharSequence suffix, CharSequence... suffixes);\npublic static String appendIfMissing(CharSequence str, CharSequence suffix, boolean ignoreCase, CharSequence... testSuffixes);\npublic static String prependIfMissing(CharSequence str, CharSequence prefix, CharSequence... prefixes);\npublic static String prependIfMissingIgnoreCase(CharSequence str, CharSequence prefix, CharSequence... prefixes);\npublic static String prependIfMissing(CharSequence str, CharSequence prefix, boolean ignoreCase, CharSequence... prefixes);\npublic static String replaceIgnoreCase(CharSequence str, CharSequence searchStr, CharSequence replacement);\npublic static String replace(CharSequence str, CharSequence searchStr, CharSequence replacement);\npublic static String replace(CharSequence str, CharSequence searchStr, CharSequence replacement, boolean ignoreCase);\npublic static String replace(CharSequence str, int fromIndex, CharSequence searchStr, CharSequence replacement, boolean ignoreCase);\npublic static String replace(CharSequence str, int startInclude, int endExclude, char replacedChar);\npublic static String replace(CharSequence str, int startInclude, int endExclude, CharSequence replacedStr);\npublic static String replace(CharSequence str, java.util.regex.Pattern pattern, Func1<java.util.regex.Matcher, String> replaceFun);\npublic static String replace(CharSequence str, String regex, Func1<java.util.regex.Matcher, String> replaceFun);\npublic static String replaceLast(CharSequence str, CharSequence searchStr, CharSequence replacedStr);\npublic static String replaceLast(CharSequence str, CharSequence searchStr, CharSequence replacedStr, boolean ignoreCase);\npublic static String replaceFirst(CharSequence str, CharSequence searchStr, CharSequence replacedStr);\npublic static String replaceFirst(CharSequence str, CharSequence searchStr, CharSequence replacedStr, boolean ignoreCase);\npublic static String hide(CharSequence str, int startInclude, int endExclude);\npublic static String desensitized(CharSequence str, DesensitizedUtil.DesensitizedType desensitizedType);\npublic static String replaceChars(CharSequence str, String chars, CharSequence replacedStr);\npublic static String replaceChars(CharSequence str, char[] chars, CharSequence replacedStr);\npublic static int length(CharSequence cs);\npublic static int byteLength(CharSequence cs, Charset charset);\npublic static int totalLength(CharSequence... strs);\npublic static String maxLength(CharSequence string, int length);\npublic static T firstNonNull(T... strs);\npublic static T firstNonEmpty(T... strs);\npublic static T firstNonBlank(T... strs);\npublic static String upperFirstAndAddPre(CharSequence str, String preString);\npublic static String upperFirst(CharSequence str);\npublic static String lowerFirst(CharSequence str);\npublic static String filter(CharSequence str, final Filter<Character> filter);\npublic static boolean isUpperCase(CharSequence str);\npublic static boolean isLowerCase(CharSequence str);\npublic static String swapCase(final String str);\npublic static String toUnderlineCase(CharSequence str);\npublic static String toSymbolCase(CharSequence str, char symbol);\npublic static String toCamelCase(CharSequence name);\npublic static String toCamelCase(CharSequence name, char symbol);\npublic static boolean isSurround(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static boolean isSurround(CharSequence str, char prefix, char suffix);\npublic static StringBuilder builder(CharSequence... strs);\npublic static StrBuilder strBuilder(CharSequence... strs);\npublic static String getGeneralField(CharSequence getOrSetMethodName);\npublic static String genSetter(CharSequence fieldName);\npublic static String genGetter(CharSequence fieldName);\npublic static String concat(boolean isNullToEmpty, CharSequence... strs);\npublic static String brief(CharSequence str, int maxLength);\npublic static String join(CharSequence conjunction, Object... objs);\npublic static String join(CharSequence conjunction, Iterable<T> iterable);\npublic static boolean isAllCharMatch(CharSequence value, Matcher<Character> matcher);\npublic static boolean isNumeric(CharSequence str);\npublic static String move(CharSequence str, int startInclude, int endExclude, int moveLength);\npublic static boolean isCharEquals(CharSequence str);\npublic static String normalize(CharSequence str);\npublic static String fixLength(CharSequence str, char fixedChar, int length);\npublic static boolean hasLetter(CharSequence str);\npublic static CharSequence commonPrefix(CharSequence str1, CharSequence str2);\npublic static CharSequence commonSuffix(CharSequence str1, CharSequence str2);",
        "public_field": "public static final int INDEX_NOT_FOUND = Finder.INDEX_NOT_FOUND;\n/**\n * 字符串常量：{@code \"null\"} <br>\n * 注意：{@code \"null\" != null}\n */\npublic static final String NULL = \"null\";\n/**\n * 字符串常量：空字符串 {@code \"\"}\n */\npublic static final String EMPTY = \"\";\n/**\n * 字符串常量：空格符 {@code \" \"}\n */\npublic static final String SPACE = \" \";",
        "Method_statement": "startWith(CharSequence str, CharSequence prefix, boolean ignoreCase, boolean ignoreEquals)",
        "Method_name": "startWith",
        "Class_declaration": "public class CharSequenceUtil {\n",
        "constructors": "",
        "all_method_signature": "public static boolean isBlank(CharSequence str);\npublic static boolean isNotBlank(CharSequence str);\npublic static boolean hasBlank(CharSequence... strs);\npublic static boolean isAllBlank(CharSequence... strs);\npublic static boolean isEmpty(CharSequence str);\npublic static boolean isNotEmpty(CharSequence str);\npublic static String emptyIfNull(CharSequence str);\npublic static String nullToEmpty(CharSequence str);\npublic static String nullToDefault(CharSequence str, String defaultStr);\npublic static String emptyToDefault(CharSequence str, String defaultStr);\npublic static String blankToDefault(CharSequence str, String defaultStr);\npublic static String emptyToNull(CharSequence str);\npublic static boolean hasEmpty(CharSequence... strs);\npublic static boolean isAllEmpty(CharSequence... strs);\npublic static boolean isAllNotEmpty(CharSequence... args);\npublic static boolean isAllNotBlank(CharSequence... args);\npublic static boolean isNullOrUndefined(CharSequence str);\npublic static boolean isEmptyOrUndefined(CharSequence str);\npublic static boolean isBlankOrUndefined(CharSequence str);\nprivate static boolean isNullOrUndefinedStr(CharSequence str);\npublic static String trim(CharSequence str);\npublic static String trimToEmpty(CharSequence str);\npublic static String trimToNull(CharSequence str);\npublic static String trimStart(CharSequence str);\npublic static String trimEnd(CharSequence str);\npublic static String trim(CharSequence str, int mode);\npublic static String trim(CharSequence str, int mode, Predicate<Character> predicate);\npublic static boolean startWith(CharSequence str, char c);\npublic static boolean startWith(CharSequence str, CharSequence prefix, boolean ignoreCase);\npublic static boolean startWith(CharSequence str, CharSequence prefix, boolean ignoreCase, boolean ignoreEquals);\npublic static boolean startWith(CharSequence str, CharSequence prefix);\npublic static boolean startWithIgnoreEquals(CharSequence str, CharSequence prefix);\npublic static boolean startWithIgnoreCase(CharSequence str, CharSequence prefix);\npublic static boolean startWithAny(CharSequence str, CharSequence... prefixes);\npublic static boolean startWithAnyIgnoreCase(final CharSequence str, final CharSequence... suffixes);\npublic static boolean endWith(CharSequence str, char c);\npublic static boolean endWith(CharSequence str, CharSequence suffix, boolean ignoreCase);\npublic static boolean endWith(CharSequence str, CharSequence suffix, boolean ignoreCase, boolean ignoreEquals);\npublic static boolean endWith(CharSequence str, CharSequence suffix);\npublic static boolean endWithIgnoreCase(CharSequence str, CharSequence suffix);\npublic static boolean endWithAny(CharSequence str, CharSequence... suffixes);\npublic static boolean endWithAnyIgnoreCase(CharSequence str, CharSequence... suffixes);\npublic static boolean contains(CharSequence str, char searchChar);\npublic static boolean contains(CharSequence str, CharSequence searchStr);\npublic static boolean containsAny(CharSequence str, CharSequence... testStrs);\npublic static boolean containsAny(CharSequence str, char... testChars);\npublic static boolean containsOnly(CharSequence str, char... testChars);\npublic static boolean containsAll(CharSequence str, CharSequence... testChars);\npublic static boolean containsBlank(CharSequence str);\npublic static String getContainsStr(CharSequence str, CharSequence... testStrs);\npublic static boolean containsIgnoreCase(CharSequence str, CharSequence testStr);\npublic static boolean containsAnyIgnoreCase(CharSequence str, CharSequence... testStrs);\npublic static String getContainsStrIgnoreCase(CharSequence str, CharSequence... testStrs);\npublic static int indexOf(CharSequence str, char searchChar);\npublic static int indexOf(CharSequence str, char searchChar, int start);\npublic static int indexOf(CharSequence text, char searchChar, int start, int end);\npublic static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr);\npublic static int indexOfIgnoreCase(final CharSequence str, final CharSequence searchStr, int fromIndex);\npublic static int indexOf(CharSequence text, CharSequence searchStr, int from, boolean ignoreCase);\npublic static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr);\npublic static int lastIndexOfIgnoreCase(CharSequence str, CharSequence searchStr, int fromIndex);\npublic static int lastIndexOf(CharSequence text, CharSequence searchStr, int from, boolean ignoreCase);\npublic static int ordinalIndexOf(CharSequence str, CharSequence searchStr, int ordinal);\npublic static String removeAll(CharSequence str, CharSequence strToRemove);\npublic static String removeAny(CharSequence str, CharSequence... strsToRemove);\npublic static String removeAll(CharSequence str, char... chars);\npublic static String removeAllLineBreaks(CharSequence str);\npublic static String removePreAndLowerFirst(CharSequence str, int preLength);\npublic static String removePreAndLowerFirst(CharSequence str, CharSequence prefix);\npublic static String removePrefix(CharSequence str, CharSequence prefix);\npublic static String removePrefixIgnoreCase(CharSequence str, CharSequence prefix);\npublic static String removeSuffix(CharSequence str, CharSequence suffix);\npublic static String removeSufAndLowerFirst(CharSequence str, CharSequence suffix);\npublic static String removeSuffixIgnoreCase(CharSequence str, CharSequence suffix);\npublic static String cleanBlank(CharSequence str);\npublic static String strip(CharSequence str, CharSequence prefixOrSuffix);\npublic static String strip(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String stripIgnoreCase(CharSequence str, CharSequence prefixOrSuffix);\npublic static String stripIgnoreCase(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String addPrefixIfNot(CharSequence str, CharSequence prefix);\npublic static String addSuffixIfNot(CharSequence str, CharSequence suffix);\npublic static long[] splitToLong(CharSequence str, char separator);\npublic static long[] splitToLong(CharSequence str, CharSequence separator);\npublic static int[] splitToInt(CharSequence str, char separator);\npublic static int[] splitToInt(CharSequence str, CharSequence separator);\npublic static List<String> split(CharSequence str, char separator);\npublic static String[] splitToArray(CharSequence str, CharSequence separator);\npublic static String[] splitToArray(CharSequence str, char separator);\npublic static String[] splitToArray(CharSequence text, char separator, int limit);\npublic static List<String> split(CharSequence str, char separator, int limit);\npublic static List<String> splitTrim(CharSequence str, char separator);\npublic static List<String> splitTrim(CharSequence str, CharSequence separator);\npublic static List<String> splitTrim(CharSequence str, char separator, int limit);\npublic static List<String> splitTrim(CharSequence str, CharSequence separator, int limit);\npublic static List<String> split(CharSequence str, char separator, boolean isTrim, boolean ignoreEmpty);\npublic static List<String> split(CharSequence str, char separator, int limit, boolean isTrim, boolean ignoreEmpty);\npublic static List<R> split(CharSequence str, char separator, int limit, boolean ignoreEmpty, Function<String, R> mapping);\npublic static List<String> split(CharSequence str, CharSequence separator);\npublic static List<String> split(CharSequence str, CharSequence separator, boolean isTrim, boolean ignoreEmpty);\npublic static List<String> split(CharSequence str, CharSequence separator, int limit, boolean isTrim, boolean ignoreEmpty);\npublic static String[] split(CharSequence str, int len);\npublic static String[] cut(CharSequence str, int partLength);\npublic static String sub(CharSequence str, int fromIndexInclude, int toIndexExclude);\npublic static String subByCodePoint(CharSequence str, int fromIndex, int toIndex);\npublic static String subPreGbk(CharSequence str, int len, CharSequence suffix);\npublic static String subPreGbk(CharSequence str, int len, boolean halfUp);\npublic static String subPre(CharSequence string, int toIndexExclude);\npublic static String subSuf(CharSequence string, int fromIndex);\npublic static String subSufByLength(CharSequence string, int length);\npublic static String subWithLength(String input, int fromIndex, int length);\npublic static String subBefore(CharSequence string, CharSequence separator, boolean isLastSeparator);\npublic static String subBefore(CharSequence string, char separator, boolean isLastSeparator);\npublic static String subAfter(CharSequence string, CharSequence separator, boolean isLastSeparator);\npublic static String subAfter(CharSequence string, char separator, boolean isLastSeparator);\npublic static String subBetween(CharSequence str, CharSequence before, CharSequence after);\npublic static String subBetween(CharSequence str, CharSequence beforeAndAfter);\npublic static String[] subBetweenAll(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String[] subBetweenAll(CharSequence str, CharSequence prefixAndSuffix);\npublic static String repeat(char c, int count);\npublic static String repeat(CharSequence str, int count);\npublic static String repeatByLength(CharSequence str, int padLen);\npublic static String repeatAndJoin(CharSequence str, int count, CharSequence delimiter);\npublic static boolean equals(CharSequence str1, CharSequence str2);\npublic static boolean equalsIgnoreCase(CharSequence str1, CharSequence str2);\npublic static boolean equals(CharSequence str1, CharSequence str2, boolean ignoreCase);\npublic static boolean equalsAnyIgnoreCase(CharSequence str1, CharSequence... strs);\npublic static boolean equalsAny(CharSequence str1, CharSequence... strs);\npublic static boolean equalsAny(CharSequence str1, boolean ignoreCase, CharSequence... strs);\npublic static boolean equalsCharAt(CharSequence str, int position, char c);\npublic static boolean isSubEquals(CharSequence str1, int start1, CharSequence str2, boolean ignoreCase);\npublic static boolean isSubEquals(CharSequence str1, int start1, CharSequence str2, int start2, int length, boolean ignoreCase);\npublic static String format(CharSequence template, Object... params);\npublic static String indexedFormat(CharSequence pattern, Object... arguments);\npublic static byte[] utf8Bytes(CharSequence str);\npublic static byte[] bytes(CharSequence str);\npublic static byte[] bytes(CharSequence str, String charset);\npublic static byte[] bytes(CharSequence str, Charset charset);\npublic static ByteBuffer byteBuffer(CharSequence str, String charset);\npublic static String wrap(CharSequence str, CharSequence prefixAndSuffix);\npublic static String wrap(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String[] wrapAllWithPair(CharSequence prefixAndSuffix, CharSequence... strs);\npublic static String[] wrapAll(CharSequence prefix, CharSequence suffix, CharSequence... strs);\npublic static String wrapIfMissing(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static String[] wrapAllWithPairIfMissing(CharSequence prefixAndSuffix, CharSequence... strs);\npublic static String[] wrapAllIfMissing(CharSequence prefix, CharSequence suffix, CharSequence... strs);\npublic static String unWrap(CharSequence str, String prefix, String suffix);\npublic static String unWrap(CharSequence str, char prefix, char suffix);\npublic static String unWrap(CharSequence str, char prefixAndSuffix);\npublic static boolean isWrap(CharSequence str, String prefix, String suffix);\npublic static boolean isWrap(CharSequence str, String wrapper);\npublic static boolean isWrap(CharSequence str, char wrapper);\npublic static boolean isWrap(CharSequence str, char prefixChar, char suffixChar);\npublic static String padPre(CharSequence str, int length, CharSequence padStr);\npublic static String padPre(CharSequence str, int length, char padChar);\npublic static String padAfter(CharSequence str, int length, char padChar);\npublic static String padAfter(CharSequence str, int length, CharSequence padStr);\npublic static String center(CharSequence str, final int size);\npublic static String center(CharSequence str, final int size, char padChar);\npublic static String center(CharSequence str, final int size, CharSequence padStr);\npublic static String str(CharSequence cs);\npublic static int count(CharSequence content, CharSequence strForSearch);\npublic static int count(CharSequence content, char charForSearch);\npublic static int compare(final CharSequence str1, final CharSequence str2, final boolean nullIsLess);\npublic static int compareIgnoreCase(CharSequence str1, CharSequence str2, boolean nullIsLess);\npublic static int compareVersion(CharSequence version1, CharSequence version2);\npublic static String appendIfMissing(CharSequence str, CharSequence suffix, CharSequence... suffixes);\npublic static String appendIfMissingIgnoreCase(CharSequence str, CharSequence suffix, CharSequence... suffixes);\npublic static String appendIfMissing(CharSequence str, CharSequence suffix, boolean ignoreCase, CharSequence... testSuffixes);\npublic static String prependIfMissing(CharSequence str, CharSequence prefix, CharSequence... prefixes);\npublic static String prependIfMissingIgnoreCase(CharSequence str, CharSequence prefix, CharSequence... prefixes);\npublic static String prependIfMissing(CharSequence str, CharSequence prefix, boolean ignoreCase, CharSequence... prefixes);\npublic static String replaceIgnoreCase(CharSequence str, CharSequence searchStr, CharSequence replacement);\npublic static String replace(CharSequence str, CharSequence searchStr, CharSequence replacement);\npublic static String replace(CharSequence str, CharSequence searchStr, CharSequence replacement, boolean ignoreCase);\npublic static String replace(CharSequence str, int fromIndex, CharSequence searchStr, CharSequence replacement, boolean ignoreCase);\npublic static String replace(CharSequence str, int startInclude, int endExclude, char replacedChar);\npublic static String replace(CharSequence str, int startInclude, int endExclude, CharSequence replacedStr);\npublic static String replace(CharSequence str, java.util.regex.Pattern pattern, Func1<java.util.regex.Matcher, String> replaceFun);\npublic static String replace(CharSequence str, String regex, Func1<java.util.regex.Matcher, String> replaceFun);\npublic static String replaceLast(CharSequence str, CharSequence searchStr, CharSequence replacedStr);\npublic static String replaceLast(CharSequence str, CharSequence searchStr, CharSequence replacedStr, boolean ignoreCase);\npublic static String replaceFirst(CharSequence str, CharSequence searchStr, CharSequence replacedStr);\npublic static String replaceFirst(CharSequence str, CharSequence searchStr, CharSequence replacedStr, boolean ignoreCase);\npublic static String hide(CharSequence str, int startInclude, int endExclude);\npublic static String desensitized(CharSequence str, DesensitizedUtil.DesensitizedType desensitizedType);\npublic static String replaceChars(CharSequence str, String chars, CharSequence replacedStr);\npublic static String replaceChars(CharSequence str, char[] chars, CharSequence replacedStr);\npublic static int length(CharSequence cs);\npublic static int byteLength(CharSequence cs, Charset charset);\npublic static int totalLength(CharSequence... strs);\npublic static String maxLength(CharSequence string, int length);\npublic static T firstNonNull(T... strs);\npublic static T firstNonEmpty(T... strs);\npublic static T firstNonBlank(T... strs);\npublic static String upperFirstAndAddPre(CharSequence str, String preString);\npublic static String upperFirst(CharSequence str);\npublic static String lowerFirst(CharSequence str);\npublic static String filter(CharSequence str, final Filter<Character> filter);\npublic static boolean isUpperCase(CharSequence str);\npublic static boolean isLowerCase(CharSequence str);\npublic static String swapCase(final String str);\npublic static String toUnderlineCase(CharSequence str);\npublic static String toSymbolCase(CharSequence str, char symbol);\npublic static String toCamelCase(CharSequence name);\npublic static String toCamelCase(CharSequence name, char symbol);\npublic static boolean isSurround(CharSequence str, CharSequence prefix, CharSequence suffix);\npublic static boolean isSurround(CharSequence str, char prefix, char suffix);\npublic static StringBuilder builder(CharSequence... strs);\npublic static StrBuilder strBuilder(CharSequence... strs);\npublic static String getGeneralField(CharSequence getOrSetMethodName);\npublic static String genSetter(CharSequence fieldName);\npublic static String genGetter(CharSequence fieldName);\npublic static String concat(boolean isNullToEmpty, CharSequence... strs);\npublic static String brief(CharSequence str, int maxLength);\npublic static String join(CharSequence conjunction, Object... objs);\npublic static String join(CharSequence conjunction, Iterable<T> iterable);\npublic static boolean isAllCharMatch(CharSequence value, Matcher<Character> matcher);\npublic static boolean isNumeric(CharSequence str);\npublic static String move(CharSequence str, int startInclude, int endExclude, int moveLength);\npublic static boolean isCharEquals(CharSequence str);\npublic static String normalize(CharSequence str);\npublic static String fixLength(CharSequence str, char fixedChar, int length);\npublic static boolean hasLetter(CharSequence str);\npublic static CharSequence commonPrefix(CharSequence str1, CharSequence str2);\npublic static CharSequence commonSuffix(CharSequence str1, CharSequence str2);",
        "Class_name": "CharSequenceUtil",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/text/CharSequenceUtil###startWith",
        "Parameter_num": "4",
        "all_Import_statements": "import cn.hutool.core.collection.CollUtil;\n\nimport cn.hutool.core.comparator.VersionComparator;\n\nimport cn.hutool.core.convert.Convert;\n\nimport cn.hutool.core.lang.Assert;\n\nimport cn.hutool.core.lang.Filter;\n\nimport cn.hutool.core.lang.Matcher;\n\nimport cn.hutool.core.lang.func.Func1;\n\nimport cn.hutool.core.text.finder.CharFinder;\n\nimport cn.hutool.core.text.finder.Finder;\n\nimport cn.hutool.core.text.finder.StrFinder;\n\nimport cn.hutool.core.util.ArrayUtil;\n\nimport cn.hutool.core.util.CharUtil;\n\nimport cn.hutool.core.util.CharsetUtil;\n\nimport cn.hutool.core.util.DesensitizedUtil;\n\nimport cn.hutool.core.util.NumberUtil;\n\nimport cn.hutool.core.util.ReUtil;\n\nimport cn.hutool.core.util.StrUtil;\n\nimport java.nio.ByteBuffer;\n\nimport java.nio.charset.Charset;\n\nimport java.text.MessageFormat;\n\nimport java.text.Normalizer;\n\nimport java.util.HashSet;\n\nimport java.util.LinkedList;\n\nimport java.util.List;\n\nimport java.util.Set;\n\nimport java.util.function.Function;\n\nimport java.util.function.Predicate;\n",
        "comment": "\n\t * 是否以指定字符串开头<br>\n\t * 如果给定的字符串和开头字符串都为null则返回true，否则任意一个值为null返回false<br>\n\t * <pre>\n\t *     CharSequenceUtil.startWith(\"123\", \"123\", false, true);   -- false\n\t *     CharSequenceUtil.startWith(\"ABCDEF\", \"abc\", true, true); -- true\n\t *     CharSequenceUtil.startWith(\"abc\", \"abc\", true, true);    -- false\n\t * </pre>\n\t *\n\t * @param str          被监测字符串\n\t * @param prefix       开头字符串\n\t * @param ignoreCase   是否忽略大小写\n\t * @param ignoreEquals 是否忽略字符串相等的情况\n\t * @return 是否以指定字符串开头\n\t * @since 5.4.3\n\t ",
        "packageName": "cn.hutool.core.text",
        "method_signature": "public static boolean startWith(CharSequence str, CharSequence prefix, boolean ignoreCase, boolean ignoreEquals);",
        "Junit_version": "5",
        "returnType": "boolean"
    },
    {
        "Method_body": "public <T> Converter<T> getConverter(Type type, boolean isCustomFirst) {\n    Converter<T> converter;\n    if (isCustomFirst) {\n        converter = this.getCustomConverter(type);\n        if (null == converter) {\n            converter = this.getDefaultConverter(type);\n        }\n    } else {\n        converter = this.getDefaultConverter(type);\n        if (null == converter) {\n            converter = this.getCustomConverter(type);\n        }\n    }\n    return converter;\n}",
        "all_field_declaration": "private static final long serialVersionUID = 1L;\n/**\n * 默认类型转换器\n */\nprivate Map<Type, Converter<?>> defaultConverterMap;\n/**\n * 用户自定义类型转换器\n */\nprivate volatile Map<Type, Converter<?>> customConverterMap;",
        "sub_project_name": "hutool-core",
        "lineNumbers": "3",
        "Filed": "",
        "Parameter_type": "Type,boolean",
        "Import_statements": "import java.lang.reflect.Type;\n",
        "public_method_signature": "public static ConverterRegistry getInstance();\npublic ConverterRegistry();\npublic ConverterRegistry putCustom(Type type, Class<? extends Converter<?>> converterClass);\npublic ConverterRegistry putCustom(Type type, Converter<?> converter);\npublic Converter<T> getConverter(Type type, boolean isCustomFirst);\npublic Converter<T> getDefaultConverter(Type type);\npublic Converter<T> getCustomConverter(Type type);\npublic T convert(Type type, Object value, T defaultValue, boolean isCustomFirst) throws ConvertException;\npublic T convert(Type type, Object value, T defaultValue) throws ConvertException;\npublic T convert(Type type, Object value) throws ConvertException;",
        "public_field": "",
        "Method_statement": "getConverter(Type type, boolean isCustomFirst)",
        "Method_name": "getConverter",
        "Class_declaration": "public class ConverterRegistry {\n",
        "constructors": "public ConverterRegistry() {\n    defaultConverter();\n    putCustomBySpi();\n}",
        "all_method_signature": "public static ConverterRegistry getInstance();\npublic ConverterRegistry();\nprivate void putCustomBySpi();\npublic ConverterRegistry putCustom(Type type, Class<? extends Converter<?>> converterClass);\npublic ConverterRegistry putCustom(Type type, Converter<?> converter);\npublic Converter<T> getConverter(Type type, boolean isCustomFirst);\npublic Converter<T> getDefaultConverter(Type type);\npublic Converter<T> getCustomConverter(Type type);\npublic T convert(Type type, Object value, T defaultValue, boolean isCustomFirst) throws ConvertException;\npublic T convert(Type type, Object value, T defaultValue) throws ConvertException;\npublic T convert(Type type, Object value) throws ConvertException;\nprivate T convertSpecial(Type type, Class<T> rowType, Object value, T defaultValue);\nprivate ConverterRegistry defaultConverter();",
        "Class_name": "ConverterRegistry",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/convert/ConverterRegistry###getConverter",
        "Parameter_num": "2",
        "all_Import_statements": "import cn.hutool.core.bean.BeanUtil;\n\nimport cn.hutool.core.convert.impl.*;\n\nimport cn.hutool.core.date.DateTime;\n\nimport cn.hutool.core.lang.Opt;\n\nimport cn.hutool.core.lang.Pair;\n\nimport cn.hutool.core.lang.TypeReference;\n\nimport cn.hutool.core.map.SafeConcurrentHashMap;\n\nimport cn.hutool.core.util.*;\n\nimport java.io.Serializable;\n\nimport java.lang.ref.SoftReference;\n\nimport java.lang.ref.WeakReference;\n\nimport java.lang.reflect.Type;\n\nimport java.math.BigDecimal;\n\nimport java.math.BigInteger;\n\nimport java.net.URI;\n\nimport java.net.URL;\n\nimport java.nio.charset.Charset;\n\nimport java.nio.file.Path;\n\nimport java.time.*;\n\nimport java.time.temporal.TemporalAccessor;\n\nimport java.util.*;\n\nimport java.util.concurrent.atomic.*;\n",
        "comment": "\n\t * 获得转换器<br>\n\t *\n\t * @param <T>           转换的目标类型\n\t * @param type          类型\n\t * @param isCustomFirst 是否自定义转换器优先\n\t * @return 转换器\n\t ",
        "packageName": "cn.hutool.core.convert",
        "method_signature": "public Converter<T> getConverter(Type type, boolean isCustomFirst);",
        "Junit_version": "5",
        "returnType": "Converter<T>"
    },
    {
        "Method_body": "public static <K, V> Map<K, V> zip(Collection<K> keys, Collection<V> values) {\n    if (isEmpty(keys) || isEmpty(values)) {\n        return MapUtil.empty();\n    }\n    int entryCount = Math.min(keys.size(), values.size());\n    final Map<K, V> map = MapUtil.newHashMap(entryCount);\n    final Iterator<K> keyIterator = keys.iterator();\n    final Iterator<V> valueIterator = values.iterator();\n    while (entryCount > 0) {\n        map.put(keyIterator.next(), valueIterator.next());\n        entryCount--;\n    }\n    return map;\n}",
        "all_field_declaration": "",
        "sub_project_name": "hutool-core",
        "lineNumbers": "7",
        "Filed": "",
        "Parameter_type": "Collection<K>,Collection<V>",
        "Import_statements": "import cn.hutool.core.map.MapUtil;\n",
        "public_method_signature": "public static Set<T> emptyIfNull(Set<T> set);\npublic static List<T> emptyIfNull(List<T> list);\npublic static Collection<T> union(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> union(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Set<T> unionDistinct(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static List<T> unionAll(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Collection<T> intersection(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> intersection(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Set<T> intersectionDistinct(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Collection<T> disjunction(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> subtract(Collection<T> coll1, Collection<T> coll2);\npublic static List<T> subtractToList(Collection<T> coll1, Collection<T> coll2);\npublic static boolean contains(Collection<?> collection, Object value);\npublic static boolean safeContains(Collection<?> collection, Object value);\npublic static boolean contains(Collection<T> collection, Predicate<? super T> containFunc);\npublic static boolean containsAny(Collection<?> coll1, Collection<?> coll2);\npublic static boolean containsAll(Collection<?> coll1, Collection<?> coll2);\npublic static Map<T, Integer> countMap(Iterable<T> collection);\npublic static String join(Iterable<T> iterable, CharSequence conjunction, Function<T, ? extends CharSequence> func);\npublic static String join(Iterable<T> iterable, CharSequence conjunction);\npublic static String join(Iterable<T> iterable, CharSequence conjunction, String prefix, String suffix);\npublic static String join(Iterator<T> iterator, CharSequence conjunction);\npublic static List<T> popPart(Stack<T> surplusAlaDatas, int partSize);\npublic static List<T> popPart(Deque<T> surplusAlaDatas, int partSize);\npublic static HashSet<T> newHashSet(T... ts);\npublic static LinkedHashSet<T> newLinkedHashSet(T... ts);\npublic static HashSet<T> set(boolean isSorted, T... ts);\npublic static HashSet<T> newHashSet(Collection<T> collection);\npublic static HashSet<T> newHashSet(boolean isSorted, Collection<T> collection);\npublic static HashSet<T> newHashSet(boolean isSorted, Iterator<T> iter);\npublic static HashSet<T> newHashSet(boolean isSorted, Enumeration<T> enumeration);\npublic static List<T> list(boolean isLinked);\npublic static List<T> list(boolean isLinked, T... values);\npublic static List<T> list(boolean isLinked, Collection<T> collection);\npublic static List<T> list(boolean isLinked, Iterable<T> iterable);\npublic static List<T> list(boolean isLinked, Iterator<T> iter);\npublic static List<T> list(boolean isLinked, Enumeration<T> enumeration);\npublic static ArrayList<T> newArrayList(T... values);\npublic static ArrayList<T> toList(T... values);\npublic static ArrayList<T> newArrayList(Collection<T> collection);\npublic static ArrayList<T> newArrayList(Iterable<T> iterable);\npublic static ArrayList<T> newArrayList(Iterator<T> iterator);\npublic static ArrayList<T> newArrayList(Enumeration<T> enumeration);\npublic static LinkedList<T> newLinkedList(T... values);\npublic static CopyOnWriteArrayList<T> newCopyOnWriteArrayList(Collection<T> collection);\npublic static BlockingQueue<T> newBlockingQueue(int capacity, boolean isLinked);\npublic static Collection<T> create(Class<?> collectionType);\npublic static Collection<T> create(Class<?> collectionType, Class<T> elementType);\npublic static ArrayList<T> distinct(Collection<T> collection);\npublic static List<T> distinct(Collection<T> collection, Function<T, K> uniqueGenerator, boolean override);\npublic static List<T> sub(List<T> list, int start, int end);\npublic static List<T> sub(List<T> list, int start, int end, int step);\npublic static List<T> sub(Collection<T> collection, int start, int end);\npublic static List<T> sub(Collection<T> collection, int start, int end, int step);\npublic static List<List<T>> splitList(List<T> list, int size);\npublic static List<List<T>> split(Collection<T> collection, int size);\npublic static Collection<T> edit(Collection<T> collection, Editor<T> editor);\npublic static Collection<T> filterNew(Collection<T> collection, Filter<T> filter);\npublic static T removeAny(T collection, E... elesRemoved);\npublic static T filter(T collection, final Filter<E> filter);\npublic static T removeNull(T collection);\npublic static T removeEmpty(T collection);\npublic static T removeBlank(T collection);\npublic static T removeWithAddIf(T targetCollection, T resultCollection, Predicate<? super E> predicate);\npublic static List<E> removeWithAddIf(T targetCollection, Predicate<? super E> predicate);\npublic static List<Object> extract(Iterable<?> collection, Editor<Object> editor);\npublic static List<Object> extract(Iterable<?> collection, Editor<Object> editor, boolean ignoreNull);\npublic static List<R> map(Iterable<T> collection, Function<? super T, ? extends R> func, boolean ignoreNull);\npublic static List<Object> getFieldValues(Iterable<?> collection, final String fieldName);\npublic static List<Object> getFieldValues(Iterable<?> collection, final String fieldName, boolean ignoreNull);\npublic static List<T> getFieldValues(Iterable<?> collection, final String fieldName, final Class<T> elementType);\npublic static Map<K, V> fieldValueMap(Iterable<V> iterable, String fieldName);\npublic static Map<K, V> fieldValueAsMap(Iterable<?> iterable, String fieldNameForKey, String fieldNameForValue);\npublic static T findOne(Iterable<T> collection, Filter<T> filter);\npublic static T findOneByField(Iterable<T> collection, final String fieldName, final Object fieldValue);\npublic static int count(Iterable<T> iterable, Matcher<T> matcher);\npublic static int indexOf(Collection<T> collection, Matcher<T> matcher);\npublic static int lastIndexOf(Collection<T> collection, Matcher<T> matcher);\npublic static int[] indexOfAll(Collection<T> collection, Matcher<T> matcher);\npublic static boolean isEmpty(Collection<?> collection);\npublic static T defaultIfEmpty(T collection, T defaultCollection);\npublic static T defaultIfEmpty(T collection, Supplier<? extends T> supplier);\npublic static boolean isEmpty(Iterable<?> iterable);\npublic static boolean isEmpty(Iterator<?> Iterator);\npublic static boolean isEmpty(Enumeration<?> enumeration);\npublic static boolean isEmpty(Map<?, ?> map);\npublic static boolean isNotEmpty(Collection<?> collection);\npublic static boolean isNotEmpty(Iterable<?> iterable);\npublic static boolean isNotEmpty(Iterator<?> Iterator);\npublic static boolean isNotEmpty(Enumeration<?> enumeration);\npublic static boolean hasNull(Iterable<?> iterable);\npublic static boolean isNotEmpty(Map<?, ?> map);\npublic static Map<String, String> zip(String keys, String values, String delimiter, boolean isOrder);\npublic static Map<String, String> zip(String keys, String values, String delimiter);\npublic static Map<K, V> zip(Collection<K> keys, Collection<V> values);\npublic static HashMap<K, V> toMap(Iterable<Entry<K, V>> entryIter);\npublic static HashMap<Object, Object> toMap(Object[] array);\npublic static TreeSet<T> toTreeSet(Collection<T> collection, Comparator<T> comparator);\npublic static Enumeration<E> asEnumeration(Iterator<E> iter);\npublic static Iterator<E> asIterator(Enumeration<E> e);\npublic static Iterable<E> asIterable(final Iterator<E> iter);\npublic static Collection<E> toCollection(Iterable<E> iterable);\npublic static Map<K, List<V>> toListMap(Iterable<? extends Map<K, V>> mapList);\npublic static List<Map<K, V>> toMapList(Map<K, ? extends Iterable<V>> listMap);\npublic static Map<K, V> toMap(Iterable<V> values, Map<K, V> map, Func1<V, K> keyFunc);\npublic static Map<K, V> toMap(Iterable<E> values, Map<K, V> map, Func1<E, K> keyFunc, Func1<E, V> valueFunc);\npublic static boolean addIfAbsent(Collection<T> collection, S object);\npublic static Collection<T> addAll(Collection<T> collection, Object value);\npublic static Collection<T> addAll(Collection<T> collection, Object value, Type elementType);\npublic static Collection<T> addAll(Collection<T> collection, Iterator<T> iterator);\npublic static Collection<T> addAll(Collection<T> collection, Iterable<T> iterable);\npublic static Collection<T> addAll(Collection<T> collection, Enumeration<T> enumeration);\npublic static Collection<T> addAll(Collection<T> collection, T[] values);\npublic static List<T> addAllIfNotContains(List<T> list, List<T> otherList);\npublic static T get(Collection<T> collection, int index);\npublic static List<T> getAny(Collection<T> collection, int... indexes);\npublic static T getFirst(Iterable<T> iterable);\npublic static T getFirst(Iterator<T> iterator);\npublic static T getLast(Collection<T> collection);\npublic static Class<?> getElementType(Iterable<?> iterable);\npublic static Class<?> getElementType(Iterator<?> iterator);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, K... keys);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, Iterable<K> keys);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, Iterator<K> keys);\npublic static List<T> sortPageAll(int pageNo, int pageSize, Comparator<T> comparator, Collection<T>... colls);\npublic static List<T> page(int pageNo, int pageSize, List<T> list);\npublic static List<T> sort(Collection<T> collection, Comparator<? super T> comparator);\npublic static List<T> sort(List<T> list, Comparator<? super T> c);\npublic static List<T> sortByProperty(Collection<T> collection, String property);\npublic static List<T> sortByProperty(List<T> list, String property);\npublic static List<String> sortByPinyin(Collection<String> collection);\npublic static List<String> sortByPinyin(List<String> list);\npublic static TreeMap<K, V> sort(Map<K, V> map, Comparator<? super K> comparator);\npublic static LinkedHashMap<K, V> sortToMap(Collection<Map.Entry<K, V>> entryCollection, Comparator<Map.Entry<K, V>> comparator);\npublic static LinkedHashMap<K, V> sortByEntry(Map<K, V> map, Comparator<Map.Entry<K, V>> comparator);\npublic static List<Entry<K, V>> sortEntryToList(Collection<Entry<K, V>> collection);\npublic static void forEach(Iterable<T> iterable, Consumer<T> consumer);\npublic static void forEach(Iterator<T> iterator, Consumer<T> consumer);\npublic static void forEach(Enumeration<T> enumeration, Consumer<T> consumer);\npublic static void forEach(Map<K, V> map, KVConsumer<K, V> kvConsumer);\npublic static List<List<T>> group(Collection<T> collection, Hash32<T> hash);\npublic static List<List<T>> groupByField(Collection<T> collection, final String fieldName);\npublic static List<T> reverse(List<T> list);\npublic static List<T> reverseNew(List<T> list);\npublic static List<T> setOrAppend(List<T> list, int index, T element);\npublic static Set<K> keySet(Collection<Map<K, ?>> mapCollection);\npublic static List<V> values(Collection<Map<?, V>> mapCollection);\npublic static T max(Collection<T> coll);\npublic static T min(Collection<T> coll);\npublic static Collection<T> unmodifiable(Collection<? extends T> c);\npublic static T empty(Class<?> collectionClass);\npublic static void clear(Collection<?>... collections);\npublic static void padLeft(List<T> list, int minLen, T padObj);\npublic static void padRight(Collection<T> list, int minLen, T padObj);\npublic static Collection<T> trans(Collection<F> collection, Function<? super F, ? extends T> function);\npublic static void setValueByMap(Iterable<E> iterable, Map<K, V> map, Function<E, K> keyGenerate, BiConsumer<E, V> biConsumer);\npublic static int size(final Object object);\npublic static boolean isEqualList(final Collection<?> list1, final Collection<?> list2);",
        "public_field": "",
        "Method_statement": "zip(Collection<K> keys, Collection<V> values)",
        "Method_name": "zip",
        "Class_declaration": "public class CollUtil {\n",
        "constructors": "",
        "all_method_signature": "public static Set<T> emptyIfNull(Set<T> set);\npublic static List<T> emptyIfNull(List<T> list);\npublic static Collection<T> union(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> union(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Set<T> unionDistinct(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static List<T> unionAll(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Collection<T> intersection(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> intersection(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Set<T> intersectionDistinct(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Collection<T> disjunction(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> subtract(Collection<T> coll1, Collection<T> coll2);\npublic static List<T> subtractToList(Collection<T> coll1, Collection<T> coll2);\npublic static boolean contains(Collection<?> collection, Object value);\npublic static boolean safeContains(Collection<?> collection, Object value);\npublic static boolean contains(Collection<T> collection, Predicate<? super T> containFunc);\npublic static boolean containsAny(Collection<?> coll1, Collection<?> coll2);\npublic static boolean containsAll(Collection<?> coll1, Collection<?> coll2);\npublic static Map<T, Integer> countMap(Iterable<T> collection);\npublic static String join(Iterable<T> iterable, CharSequence conjunction, Function<T, ? extends CharSequence> func);\npublic static String join(Iterable<T> iterable, CharSequence conjunction);\npublic static String join(Iterable<T> iterable, CharSequence conjunction, String prefix, String suffix);\npublic static String join(Iterator<T> iterator, CharSequence conjunction);\npublic static List<T> popPart(Stack<T> surplusAlaDatas, int partSize);\npublic static List<T> popPart(Deque<T> surplusAlaDatas, int partSize);\npublic static HashSet<T> newHashSet(T... ts);\npublic static LinkedHashSet<T> newLinkedHashSet(T... ts);\npublic static HashSet<T> set(boolean isSorted, T... ts);\npublic static HashSet<T> newHashSet(Collection<T> collection);\npublic static HashSet<T> newHashSet(boolean isSorted, Collection<T> collection);\npublic static HashSet<T> newHashSet(boolean isSorted, Iterator<T> iter);\npublic static HashSet<T> newHashSet(boolean isSorted, Enumeration<T> enumeration);\npublic static List<T> list(boolean isLinked);\npublic static List<T> list(boolean isLinked, T... values);\npublic static List<T> list(boolean isLinked, Collection<T> collection);\npublic static List<T> list(boolean isLinked, Iterable<T> iterable);\npublic static List<T> list(boolean isLinked, Iterator<T> iter);\npublic static List<T> list(boolean isLinked, Enumeration<T> enumeration);\npublic static ArrayList<T> newArrayList(T... values);\npublic static ArrayList<T> toList(T... values);\npublic static ArrayList<T> newArrayList(Collection<T> collection);\npublic static ArrayList<T> newArrayList(Iterable<T> iterable);\npublic static ArrayList<T> newArrayList(Iterator<T> iterator);\npublic static ArrayList<T> newArrayList(Enumeration<T> enumeration);\npublic static LinkedList<T> newLinkedList(T... values);\npublic static CopyOnWriteArrayList<T> newCopyOnWriteArrayList(Collection<T> collection);\npublic static BlockingQueue<T> newBlockingQueue(int capacity, boolean isLinked);\npublic static Collection<T> create(Class<?> collectionType);\npublic static Collection<T> create(Class<?> collectionType, Class<T> elementType);\npublic static ArrayList<T> distinct(Collection<T> collection);\npublic static List<T> distinct(Collection<T> collection, Function<T, K> uniqueGenerator, boolean override);\npublic static List<T> sub(List<T> list, int start, int end);\npublic static List<T> sub(List<T> list, int start, int end, int step);\npublic static List<T> sub(Collection<T> collection, int start, int end);\npublic static List<T> sub(Collection<T> collection, int start, int end, int step);\npublic static List<List<T>> splitList(List<T> list, int size);\npublic static List<List<T>> split(Collection<T> collection, int size);\npublic static Collection<T> edit(Collection<T> collection, Editor<T> editor);\npublic static Collection<T> filterNew(Collection<T> collection, Filter<T> filter);\npublic static T removeAny(T collection, E... elesRemoved);\npublic static T filter(T collection, final Filter<E> filter);\npublic static T removeNull(T collection);\npublic static T removeEmpty(T collection);\npublic static T removeBlank(T collection);\npublic static T removeWithAddIf(T targetCollection, T resultCollection, Predicate<? super E> predicate);\npublic static List<E> removeWithAddIf(T targetCollection, Predicate<? super E> predicate);\npublic static List<Object> extract(Iterable<?> collection, Editor<Object> editor);\npublic static List<Object> extract(Iterable<?> collection, Editor<Object> editor, boolean ignoreNull);\npublic static List<R> map(Iterable<T> collection, Function<? super T, ? extends R> func, boolean ignoreNull);\npublic static List<Object> getFieldValues(Iterable<?> collection, final String fieldName);\npublic static List<Object> getFieldValues(Iterable<?> collection, final String fieldName, boolean ignoreNull);\npublic static List<T> getFieldValues(Iterable<?> collection, final String fieldName, final Class<T> elementType);\npublic static Map<K, V> fieldValueMap(Iterable<V> iterable, String fieldName);\npublic static Map<K, V> fieldValueAsMap(Iterable<?> iterable, String fieldNameForKey, String fieldNameForValue);\npublic static T findOne(Iterable<T> collection, Filter<T> filter);\npublic static T findOneByField(Iterable<T> collection, final String fieldName, final Object fieldValue);\npublic static int count(Iterable<T> iterable, Matcher<T> matcher);\npublic static int indexOf(Collection<T> collection, Matcher<T> matcher);\npublic static int lastIndexOf(Collection<T> collection, Matcher<T> matcher);\npublic static int[] indexOfAll(Collection<T> collection, Matcher<T> matcher);\npublic static boolean isEmpty(Collection<?> collection);\npublic static T defaultIfEmpty(T collection, T defaultCollection);\npublic static T defaultIfEmpty(T collection, Supplier<? extends T> supplier);\npublic static boolean isEmpty(Iterable<?> iterable);\npublic static boolean isEmpty(Iterator<?> Iterator);\npublic static boolean isEmpty(Enumeration<?> enumeration);\npublic static boolean isEmpty(Map<?, ?> map);\npublic static boolean isNotEmpty(Collection<?> collection);\npublic static boolean isNotEmpty(Iterable<?> iterable);\npublic static boolean isNotEmpty(Iterator<?> Iterator);\npublic static boolean isNotEmpty(Enumeration<?> enumeration);\npublic static boolean hasNull(Iterable<?> iterable);\npublic static boolean isNotEmpty(Map<?, ?> map);\npublic static Map<String, String> zip(String keys, String values, String delimiter, boolean isOrder);\npublic static Map<String, String> zip(String keys, String values, String delimiter);\npublic static Map<K, V> zip(Collection<K> keys, Collection<V> values);\npublic static HashMap<K, V> toMap(Iterable<Entry<K, V>> entryIter);\npublic static HashMap<Object, Object> toMap(Object[] array);\npublic static TreeSet<T> toTreeSet(Collection<T> collection, Comparator<T> comparator);\npublic static Enumeration<E> asEnumeration(Iterator<E> iter);\npublic static Iterator<E> asIterator(Enumeration<E> e);\npublic static Iterable<E> asIterable(final Iterator<E> iter);\npublic static Collection<E> toCollection(Iterable<E> iterable);\npublic static Map<K, List<V>> toListMap(Iterable<? extends Map<K, V>> mapList);\npublic static List<Map<K, V>> toMapList(Map<K, ? extends Iterable<V>> listMap);\npublic static Map<K, V> toMap(Iterable<V> values, Map<K, V> map, Func1<V, K> keyFunc);\npublic static Map<K, V> toMap(Iterable<E> values, Map<K, V> map, Func1<E, K> keyFunc, Func1<E, V> valueFunc);\npublic static boolean addIfAbsent(Collection<T> collection, S object);\npublic static Collection<T> addAll(Collection<T> collection, Object value);\npublic static Collection<T> addAll(Collection<T> collection, Object value, Type elementType);\npublic static Collection<T> addAll(Collection<T> collection, Iterator<T> iterator);\npublic static Collection<T> addAll(Collection<T> collection, Iterable<T> iterable);\npublic static Collection<T> addAll(Collection<T> collection, Enumeration<T> enumeration);\npublic static Collection<T> addAll(Collection<T> collection, T[] values);\npublic static List<T> addAllIfNotContains(List<T> list, List<T> otherList);\npublic static T get(Collection<T> collection, int index);\npublic static List<T> getAny(Collection<T> collection, int... indexes);\npublic static T getFirst(Iterable<T> iterable);\npublic static T getFirst(Iterator<T> iterator);\npublic static T getLast(Collection<T> collection);\npublic static Class<?> getElementType(Iterable<?> iterable);\npublic static Class<?> getElementType(Iterator<?> iterator);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, K... keys);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, Iterable<K> keys);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, Iterator<K> keys);\npublic static List<T> sortPageAll(int pageNo, int pageSize, Comparator<T> comparator, Collection<T>... colls);\npublic static List<T> page(int pageNo, int pageSize, List<T> list);\npublic static List<T> sort(Collection<T> collection, Comparator<? super T> comparator);\npublic static List<T> sort(List<T> list, Comparator<? super T> c);\npublic static List<T> sortByProperty(Collection<T> collection, String property);\npublic static List<T> sortByProperty(List<T> list, String property);\npublic static List<String> sortByPinyin(Collection<String> collection);\npublic static List<String> sortByPinyin(List<String> list);\npublic static TreeMap<K, V> sort(Map<K, V> map, Comparator<? super K> comparator);\npublic static LinkedHashMap<K, V> sortToMap(Collection<Map.Entry<K, V>> entryCollection, Comparator<Map.Entry<K, V>> comparator);\npublic static LinkedHashMap<K, V> sortByEntry(Map<K, V> map, Comparator<Map.Entry<K, V>> comparator);\npublic static List<Entry<K, V>> sortEntryToList(Collection<Entry<K, V>> collection);\npublic static void forEach(Iterable<T> iterable, Consumer<T> consumer);\npublic static void forEach(Iterator<T> iterator, Consumer<T> consumer);\npublic static void forEach(Enumeration<T> enumeration, Consumer<T> consumer);\npublic static void forEach(Map<K, V> map, KVConsumer<K, V> kvConsumer);\npublic static List<List<T>> group(Collection<T> collection, Hash32<T> hash);\npublic static List<List<T>> groupByField(Collection<T> collection, final String fieldName);\npublic static List<T> reverse(List<T> list);\npublic static List<T> reverseNew(List<T> list);\npublic static List<T> setOrAppend(List<T> list, int index, T element);\npublic static Set<K> keySet(Collection<Map<K, ?>> mapCollection);\npublic static List<V> values(Collection<Map<?, V>> mapCollection);\npublic static T max(Collection<T> coll);\npublic static T min(Collection<T> coll);\npublic static Collection<T> unmodifiable(Collection<? extends T> c);\npublic static T empty(Class<?> collectionClass);\npublic static void clear(Collection<?>... collections);\npublic static void padLeft(List<T> list, int minLen, T padObj);\npublic static void padRight(Collection<T> list, int minLen, T padObj);\npublic static Collection<T> trans(Collection<F> collection, Function<? super F, ? extends T> function);\npublic static void setValueByMap(Iterable<E> iterable, Map<K, V> map, Function<E, K> keyGenerate, BiConsumer<E, V> biConsumer);\npublic static int size(final Object object);\npublic static boolean isEqualList(final Collection<?> list1, final Collection<?> list2);",
        "Class_name": "CollUtil",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/collection/CollUtil###zip",
        "Parameter_num": "2",
        "all_Import_statements": "import cn.hutool.core.bean.BeanUtil;\n\nimport cn.hutool.core.comparator.CompareUtil;\n\nimport cn.hutool.core.comparator.PinyinComparator;\n\nimport cn.hutool.core.comparator.PropertyComparator;\n\nimport cn.hutool.core.convert.Convert;\n\nimport cn.hutool.core.convert.ConverterRegistry;\n\nimport cn.hutool.core.exceptions.UtilException;\n\nimport cn.hutool.core.lang.Assert;\n\nimport cn.hutool.core.lang.Editor;\n\nimport cn.hutool.core.lang.Filter;\n\nimport cn.hutool.core.lang.Matcher;\n\nimport cn.hutool.core.lang.func.Func1;\n\nimport cn.hutool.core.lang.hash.Hash32;\n\nimport cn.hutool.core.map.MapUtil;\n\nimport cn.hutool.core.util.*;\n\nimport java.io.Serializable;\n\nimport java.lang.reflect.Type;\n\nimport java.util.*;\n\nimport java.util.Map.Entry;\n\nimport java.util.concurrent.ArrayBlockingQueue;\n\nimport java.util.concurrent.BlockingQueue;\n\nimport java.util.concurrent.CopyOnWriteArrayList;\n\nimport java.util.concurrent.LinkedBlockingDeque;\n\nimport java.util.function.BiConsumer;\n\nimport java.util.function.Function;\n\nimport java.util.function.Predicate;\n\nimport java.util.function.Supplier;\n",
        "comment": "\n\t * 映射键值（参考Python的zip()函数）<br>\n\t * 例如：<br>\n\t * keys = [a,b,c,d]<br>\n\t * values = [1,2,3,4]<br>\n\t * 则得到的Map是 {a=1, b=2, c=3, d=4}<br>\n\t * 如果两个数组长度不同，则只对应最短部分\n\t *\n\t * @param <K>    键类型\n\t * @param <V>    值类型\n\t * @param keys   键列表\n\t * @param values 值列表\n\t * @return Map\n\t ",
        "packageName": "cn.hutool.core.collection",
        "method_signature": "public static Map<K, V> zip(Collection<K> keys, Collection<V> values);",
        "Junit_version": "5",
        "returnType": "Map<K,V>"
    },
    {
        "Method_body": "public static <T> T get(Collection<T> collection, int index) {\n    if (null == collection) {\n        return null;\n    }\n    final int size = collection.size();\n    if (0 == size) {\n        return null;\n    }\n    if (index < 0) {\n        index += size;\n    }\n    if (index >= size || index < 0) {\n        return null;\n    }\n    if (collection instanceof List) {\n        final List<T> list = ((List<T>) collection);\n        return list.get(index);\n    } else {\n        return IterUtil.get(collection.iterator(), index);\n    }\n}",
        "all_field_declaration": "",
        "sub_project_name": "hutool-core",
        "lineNumbers": "6",
        "Filed": "",
        "Parameter_type": "Collection<T>,int",
        "Import_statements": "",
        "public_method_signature": "public static Set<T> emptyIfNull(Set<T> set);\npublic static List<T> emptyIfNull(List<T> list);\npublic static Collection<T> union(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> union(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Set<T> unionDistinct(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static List<T> unionAll(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Collection<T> intersection(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> intersection(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Set<T> intersectionDistinct(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Collection<T> disjunction(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> subtract(Collection<T> coll1, Collection<T> coll2);\npublic static List<T> subtractToList(Collection<T> coll1, Collection<T> coll2);\npublic static boolean contains(Collection<?> collection, Object value);\npublic static boolean safeContains(Collection<?> collection, Object value);\npublic static boolean contains(Collection<T> collection, Predicate<? super T> containFunc);\npublic static boolean containsAny(Collection<?> coll1, Collection<?> coll2);\npublic static boolean containsAll(Collection<?> coll1, Collection<?> coll2);\npublic static Map<T, Integer> countMap(Iterable<T> collection);\npublic static String join(Iterable<T> iterable, CharSequence conjunction, Function<T, ? extends CharSequence> func);\npublic static String join(Iterable<T> iterable, CharSequence conjunction);\npublic static String join(Iterable<T> iterable, CharSequence conjunction, String prefix, String suffix);\npublic static String join(Iterator<T> iterator, CharSequence conjunction);\npublic static List<T> popPart(Stack<T> surplusAlaDatas, int partSize);\npublic static List<T> popPart(Deque<T> surplusAlaDatas, int partSize);\npublic static HashSet<T> newHashSet(T... ts);\npublic static LinkedHashSet<T> newLinkedHashSet(T... ts);\npublic static HashSet<T> set(boolean isSorted, T... ts);\npublic static HashSet<T> newHashSet(Collection<T> collection);\npublic static HashSet<T> newHashSet(boolean isSorted, Collection<T> collection);\npublic static HashSet<T> newHashSet(boolean isSorted, Iterator<T> iter);\npublic static HashSet<T> newHashSet(boolean isSorted, Enumeration<T> enumeration);\npublic static List<T> list(boolean isLinked);\npublic static List<T> list(boolean isLinked, T... values);\npublic static List<T> list(boolean isLinked, Collection<T> collection);\npublic static List<T> list(boolean isLinked, Iterable<T> iterable);\npublic static List<T> list(boolean isLinked, Iterator<T> iter);\npublic static List<T> list(boolean isLinked, Enumeration<T> enumeration);\npublic static ArrayList<T> newArrayList(T... values);\npublic static ArrayList<T> toList(T... values);\npublic static ArrayList<T> newArrayList(Collection<T> collection);\npublic static ArrayList<T> newArrayList(Iterable<T> iterable);\npublic static ArrayList<T> newArrayList(Iterator<T> iterator);\npublic static ArrayList<T> newArrayList(Enumeration<T> enumeration);\npublic static LinkedList<T> newLinkedList(T... values);\npublic static CopyOnWriteArrayList<T> newCopyOnWriteArrayList(Collection<T> collection);\npublic static BlockingQueue<T> newBlockingQueue(int capacity, boolean isLinked);\npublic static Collection<T> create(Class<?> collectionType);\npublic static Collection<T> create(Class<?> collectionType, Class<T> elementType);\npublic static ArrayList<T> distinct(Collection<T> collection);\npublic static List<T> distinct(Collection<T> collection, Function<T, K> uniqueGenerator, boolean override);\npublic static List<T> sub(List<T> list, int start, int end);\npublic static List<T> sub(List<T> list, int start, int end, int step);\npublic static List<T> sub(Collection<T> collection, int start, int end);\npublic static List<T> sub(Collection<T> collection, int start, int end, int step);\npublic static List<List<T>> splitList(List<T> list, int size);\npublic static List<List<T>> split(Collection<T> collection, int size);\npublic static Collection<T> edit(Collection<T> collection, Editor<T> editor);\npublic static Collection<T> filterNew(Collection<T> collection, Filter<T> filter);\npublic static T removeAny(T collection, E... elesRemoved);\npublic static T filter(T collection, final Filter<E> filter);\npublic static T removeNull(T collection);\npublic static T removeEmpty(T collection);\npublic static T removeBlank(T collection);\npublic static T removeWithAddIf(T targetCollection, T resultCollection, Predicate<? super E> predicate);\npublic static List<E> removeWithAddIf(T targetCollection, Predicate<? super E> predicate);\npublic static List<Object> extract(Iterable<?> collection, Editor<Object> editor);\npublic static List<Object> extract(Iterable<?> collection, Editor<Object> editor, boolean ignoreNull);\npublic static List<R> map(Iterable<T> collection, Function<? super T, ? extends R> func, boolean ignoreNull);\npublic static List<Object> getFieldValues(Iterable<?> collection, final String fieldName);\npublic static List<Object> getFieldValues(Iterable<?> collection, final String fieldName, boolean ignoreNull);\npublic static List<T> getFieldValues(Iterable<?> collection, final String fieldName, final Class<T> elementType);\npublic static Map<K, V> fieldValueMap(Iterable<V> iterable, String fieldName);\npublic static Map<K, V> fieldValueAsMap(Iterable<?> iterable, String fieldNameForKey, String fieldNameForValue);\npublic static T findOne(Iterable<T> collection, Filter<T> filter);\npublic static T findOneByField(Iterable<T> collection, final String fieldName, final Object fieldValue);\npublic static int count(Iterable<T> iterable, Matcher<T> matcher);\npublic static int indexOf(Collection<T> collection, Matcher<T> matcher);\npublic static int lastIndexOf(Collection<T> collection, Matcher<T> matcher);\npublic static int[] indexOfAll(Collection<T> collection, Matcher<T> matcher);\npublic static boolean isEmpty(Collection<?> collection);\npublic static T defaultIfEmpty(T collection, T defaultCollection);\npublic static T defaultIfEmpty(T collection, Supplier<? extends T> supplier);\npublic static boolean isEmpty(Iterable<?> iterable);\npublic static boolean isEmpty(Iterator<?> Iterator);\npublic static boolean isEmpty(Enumeration<?> enumeration);\npublic static boolean isEmpty(Map<?, ?> map);\npublic static boolean isNotEmpty(Collection<?> collection);\npublic static boolean isNotEmpty(Iterable<?> iterable);\npublic static boolean isNotEmpty(Iterator<?> Iterator);\npublic static boolean isNotEmpty(Enumeration<?> enumeration);\npublic static boolean hasNull(Iterable<?> iterable);\npublic static boolean isNotEmpty(Map<?, ?> map);\npublic static Map<String, String> zip(String keys, String values, String delimiter, boolean isOrder);\npublic static Map<String, String> zip(String keys, String values, String delimiter);\npublic static Map<K, V> zip(Collection<K> keys, Collection<V> values);\npublic static HashMap<K, V> toMap(Iterable<Entry<K, V>> entryIter);\npublic static HashMap<Object, Object> toMap(Object[] array);\npublic static TreeSet<T> toTreeSet(Collection<T> collection, Comparator<T> comparator);\npublic static Enumeration<E> asEnumeration(Iterator<E> iter);\npublic static Iterator<E> asIterator(Enumeration<E> e);\npublic static Iterable<E> asIterable(final Iterator<E> iter);\npublic static Collection<E> toCollection(Iterable<E> iterable);\npublic static Map<K, List<V>> toListMap(Iterable<? extends Map<K, V>> mapList);\npublic static List<Map<K, V>> toMapList(Map<K, ? extends Iterable<V>> listMap);\npublic static Map<K, V> toMap(Iterable<V> values, Map<K, V> map, Func1<V, K> keyFunc);\npublic static Map<K, V> toMap(Iterable<E> values, Map<K, V> map, Func1<E, K> keyFunc, Func1<E, V> valueFunc);\npublic static boolean addIfAbsent(Collection<T> collection, S object);\npublic static Collection<T> addAll(Collection<T> collection, Object value);\npublic static Collection<T> addAll(Collection<T> collection, Object value, Type elementType);\npublic static Collection<T> addAll(Collection<T> collection, Iterator<T> iterator);\npublic static Collection<T> addAll(Collection<T> collection, Iterable<T> iterable);\npublic static Collection<T> addAll(Collection<T> collection, Enumeration<T> enumeration);\npublic static Collection<T> addAll(Collection<T> collection, T[] values);\npublic static List<T> addAllIfNotContains(List<T> list, List<T> otherList);\npublic static T get(Collection<T> collection, int index);\npublic static List<T> getAny(Collection<T> collection, int... indexes);\npublic static T getFirst(Iterable<T> iterable);\npublic static T getFirst(Iterator<T> iterator);\npublic static T getLast(Collection<T> collection);\npublic static Class<?> getElementType(Iterable<?> iterable);\npublic static Class<?> getElementType(Iterator<?> iterator);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, K... keys);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, Iterable<K> keys);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, Iterator<K> keys);\npublic static List<T> sortPageAll(int pageNo, int pageSize, Comparator<T> comparator, Collection<T>... colls);\npublic static List<T> page(int pageNo, int pageSize, List<T> list);\npublic static List<T> sort(Collection<T> collection, Comparator<? super T> comparator);\npublic static List<T> sort(List<T> list, Comparator<? super T> c);\npublic static List<T> sortByProperty(Collection<T> collection, String property);\npublic static List<T> sortByProperty(List<T> list, String property);\npublic static List<String> sortByPinyin(Collection<String> collection);\npublic static List<String> sortByPinyin(List<String> list);\npublic static TreeMap<K, V> sort(Map<K, V> map, Comparator<? super K> comparator);\npublic static LinkedHashMap<K, V> sortToMap(Collection<Map.Entry<K, V>> entryCollection, Comparator<Map.Entry<K, V>> comparator);\npublic static LinkedHashMap<K, V> sortByEntry(Map<K, V> map, Comparator<Map.Entry<K, V>> comparator);\npublic static List<Entry<K, V>> sortEntryToList(Collection<Entry<K, V>> collection);\npublic static void forEach(Iterable<T> iterable, Consumer<T> consumer);\npublic static void forEach(Iterator<T> iterator, Consumer<T> consumer);\npublic static void forEach(Enumeration<T> enumeration, Consumer<T> consumer);\npublic static void forEach(Map<K, V> map, KVConsumer<K, V> kvConsumer);\npublic static List<List<T>> group(Collection<T> collection, Hash32<T> hash);\npublic static List<List<T>> groupByField(Collection<T> collection, final String fieldName);\npublic static List<T> reverse(List<T> list);\npublic static List<T> reverseNew(List<T> list);\npublic static List<T> setOrAppend(List<T> list, int index, T element);\npublic static Set<K> keySet(Collection<Map<K, ?>> mapCollection);\npublic static List<V> values(Collection<Map<?, V>> mapCollection);\npublic static T max(Collection<T> coll);\npublic static T min(Collection<T> coll);\npublic static Collection<T> unmodifiable(Collection<? extends T> c);\npublic static T empty(Class<?> collectionClass);\npublic static void clear(Collection<?>... collections);\npublic static void padLeft(List<T> list, int minLen, T padObj);\npublic static void padRight(Collection<T> list, int minLen, T padObj);\npublic static Collection<T> trans(Collection<F> collection, Function<? super F, ? extends T> function);\npublic static void setValueByMap(Iterable<E> iterable, Map<K, V> map, Function<E, K> keyGenerate, BiConsumer<E, V> biConsumer);\npublic static int size(final Object object);\npublic static boolean isEqualList(final Collection<?> list1, final Collection<?> list2);",
        "public_field": "",
        "Method_statement": "get(Collection<T> collection, int index)",
        "Method_name": "get",
        "Class_declaration": "public class CollUtil {\n",
        "constructors": "",
        "all_method_signature": "public static Set<T> emptyIfNull(Set<T> set);\npublic static List<T> emptyIfNull(List<T> list);\npublic static Collection<T> union(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> union(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Set<T> unionDistinct(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static List<T> unionAll(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Collection<T> intersection(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> intersection(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Set<T> intersectionDistinct(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Collection<T> disjunction(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> subtract(Collection<T> coll1, Collection<T> coll2);\npublic static List<T> subtractToList(Collection<T> coll1, Collection<T> coll2);\npublic static boolean contains(Collection<?> collection, Object value);\npublic static boolean safeContains(Collection<?> collection, Object value);\npublic static boolean contains(Collection<T> collection, Predicate<? super T> containFunc);\npublic static boolean containsAny(Collection<?> coll1, Collection<?> coll2);\npublic static boolean containsAll(Collection<?> coll1, Collection<?> coll2);\npublic static Map<T, Integer> countMap(Iterable<T> collection);\npublic static String join(Iterable<T> iterable, CharSequence conjunction, Function<T, ? extends CharSequence> func);\npublic static String join(Iterable<T> iterable, CharSequence conjunction);\npublic static String join(Iterable<T> iterable, CharSequence conjunction, String prefix, String suffix);\npublic static String join(Iterator<T> iterator, CharSequence conjunction);\npublic static List<T> popPart(Stack<T> surplusAlaDatas, int partSize);\npublic static List<T> popPart(Deque<T> surplusAlaDatas, int partSize);\npublic static HashSet<T> newHashSet(T... ts);\npublic static LinkedHashSet<T> newLinkedHashSet(T... ts);\npublic static HashSet<T> set(boolean isSorted, T... ts);\npublic static HashSet<T> newHashSet(Collection<T> collection);\npublic static HashSet<T> newHashSet(boolean isSorted, Collection<T> collection);\npublic static HashSet<T> newHashSet(boolean isSorted, Iterator<T> iter);\npublic static HashSet<T> newHashSet(boolean isSorted, Enumeration<T> enumeration);\npublic static List<T> list(boolean isLinked);\npublic static List<T> list(boolean isLinked, T... values);\npublic static List<T> list(boolean isLinked, Collection<T> collection);\npublic static List<T> list(boolean isLinked, Iterable<T> iterable);\npublic static List<T> list(boolean isLinked, Iterator<T> iter);\npublic static List<T> list(boolean isLinked, Enumeration<T> enumeration);\npublic static ArrayList<T> newArrayList(T... values);\npublic static ArrayList<T> toList(T... values);\npublic static ArrayList<T> newArrayList(Collection<T> collection);\npublic static ArrayList<T> newArrayList(Iterable<T> iterable);\npublic static ArrayList<T> newArrayList(Iterator<T> iterator);\npublic static ArrayList<T> newArrayList(Enumeration<T> enumeration);\npublic static LinkedList<T> newLinkedList(T... values);\npublic static CopyOnWriteArrayList<T> newCopyOnWriteArrayList(Collection<T> collection);\npublic static BlockingQueue<T> newBlockingQueue(int capacity, boolean isLinked);\npublic static Collection<T> create(Class<?> collectionType);\npublic static Collection<T> create(Class<?> collectionType, Class<T> elementType);\npublic static ArrayList<T> distinct(Collection<T> collection);\npublic static List<T> distinct(Collection<T> collection, Function<T, K> uniqueGenerator, boolean override);\npublic static List<T> sub(List<T> list, int start, int end);\npublic static List<T> sub(List<T> list, int start, int end, int step);\npublic static List<T> sub(Collection<T> collection, int start, int end);\npublic static List<T> sub(Collection<T> collection, int start, int end, int step);\npublic static List<List<T>> splitList(List<T> list, int size);\npublic static List<List<T>> split(Collection<T> collection, int size);\npublic static Collection<T> edit(Collection<T> collection, Editor<T> editor);\npublic static Collection<T> filterNew(Collection<T> collection, Filter<T> filter);\npublic static T removeAny(T collection, E... elesRemoved);\npublic static T filter(T collection, final Filter<E> filter);\npublic static T removeNull(T collection);\npublic static T removeEmpty(T collection);\npublic static T removeBlank(T collection);\npublic static T removeWithAddIf(T targetCollection, T resultCollection, Predicate<? super E> predicate);\npublic static List<E> removeWithAddIf(T targetCollection, Predicate<? super E> predicate);\npublic static List<Object> extract(Iterable<?> collection, Editor<Object> editor);\npublic static List<Object> extract(Iterable<?> collection, Editor<Object> editor, boolean ignoreNull);\npublic static List<R> map(Iterable<T> collection, Function<? super T, ? extends R> func, boolean ignoreNull);\npublic static List<Object> getFieldValues(Iterable<?> collection, final String fieldName);\npublic static List<Object> getFieldValues(Iterable<?> collection, final String fieldName, boolean ignoreNull);\npublic static List<T> getFieldValues(Iterable<?> collection, final String fieldName, final Class<T> elementType);\npublic static Map<K, V> fieldValueMap(Iterable<V> iterable, String fieldName);\npublic static Map<K, V> fieldValueAsMap(Iterable<?> iterable, String fieldNameForKey, String fieldNameForValue);\npublic static T findOne(Iterable<T> collection, Filter<T> filter);\npublic static T findOneByField(Iterable<T> collection, final String fieldName, final Object fieldValue);\npublic static int count(Iterable<T> iterable, Matcher<T> matcher);\npublic static int indexOf(Collection<T> collection, Matcher<T> matcher);\npublic static int lastIndexOf(Collection<T> collection, Matcher<T> matcher);\npublic static int[] indexOfAll(Collection<T> collection, Matcher<T> matcher);\npublic static boolean isEmpty(Collection<?> collection);\npublic static T defaultIfEmpty(T collection, T defaultCollection);\npublic static T defaultIfEmpty(T collection, Supplier<? extends T> supplier);\npublic static boolean isEmpty(Iterable<?> iterable);\npublic static boolean isEmpty(Iterator<?> Iterator);\npublic static boolean isEmpty(Enumeration<?> enumeration);\npublic static boolean isEmpty(Map<?, ?> map);\npublic static boolean isNotEmpty(Collection<?> collection);\npublic static boolean isNotEmpty(Iterable<?> iterable);\npublic static boolean isNotEmpty(Iterator<?> Iterator);\npublic static boolean isNotEmpty(Enumeration<?> enumeration);\npublic static boolean hasNull(Iterable<?> iterable);\npublic static boolean isNotEmpty(Map<?, ?> map);\npublic static Map<String, String> zip(String keys, String values, String delimiter, boolean isOrder);\npublic static Map<String, String> zip(String keys, String values, String delimiter);\npublic static Map<K, V> zip(Collection<K> keys, Collection<V> values);\npublic static HashMap<K, V> toMap(Iterable<Entry<K, V>> entryIter);\npublic static HashMap<Object, Object> toMap(Object[] array);\npublic static TreeSet<T> toTreeSet(Collection<T> collection, Comparator<T> comparator);\npublic static Enumeration<E> asEnumeration(Iterator<E> iter);\npublic static Iterator<E> asIterator(Enumeration<E> e);\npublic static Iterable<E> asIterable(final Iterator<E> iter);\npublic static Collection<E> toCollection(Iterable<E> iterable);\npublic static Map<K, List<V>> toListMap(Iterable<? extends Map<K, V>> mapList);\npublic static List<Map<K, V>> toMapList(Map<K, ? extends Iterable<V>> listMap);\npublic static Map<K, V> toMap(Iterable<V> values, Map<K, V> map, Func1<V, K> keyFunc);\npublic static Map<K, V> toMap(Iterable<E> values, Map<K, V> map, Func1<E, K> keyFunc, Func1<E, V> valueFunc);\npublic static boolean addIfAbsent(Collection<T> collection, S object);\npublic static Collection<T> addAll(Collection<T> collection, Object value);\npublic static Collection<T> addAll(Collection<T> collection, Object value, Type elementType);\npublic static Collection<T> addAll(Collection<T> collection, Iterator<T> iterator);\npublic static Collection<T> addAll(Collection<T> collection, Iterable<T> iterable);\npublic static Collection<T> addAll(Collection<T> collection, Enumeration<T> enumeration);\npublic static Collection<T> addAll(Collection<T> collection, T[] values);\npublic static List<T> addAllIfNotContains(List<T> list, List<T> otherList);\npublic static T get(Collection<T> collection, int index);\npublic static List<T> getAny(Collection<T> collection, int... indexes);\npublic static T getFirst(Iterable<T> iterable);\npublic static T getFirst(Iterator<T> iterator);\npublic static T getLast(Collection<T> collection);\npublic static Class<?> getElementType(Iterable<?> iterable);\npublic static Class<?> getElementType(Iterator<?> iterator);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, K... keys);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, Iterable<K> keys);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, Iterator<K> keys);\npublic static List<T> sortPageAll(int pageNo, int pageSize, Comparator<T> comparator, Collection<T>... colls);\npublic static List<T> page(int pageNo, int pageSize, List<T> list);\npublic static List<T> sort(Collection<T> collection, Comparator<? super T> comparator);\npublic static List<T> sort(List<T> list, Comparator<? super T> c);\npublic static List<T> sortByProperty(Collection<T> collection, String property);\npublic static List<T> sortByProperty(List<T> list, String property);\npublic static List<String> sortByPinyin(Collection<String> collection);\npublic static List<String> sortByPinyin(List<String> list);\npublic static TreeMap<K, V> sort(Map<K, V> map, Comparator<? super K> comparator);\npublic static LinkedHashMap<K, V> sortToMap(Collection<Map.Entry<K, V>> entryCollection, Comparator<Map.Entry<K, V>> comparator);\npublic static LinkedHashMap<K, V> sortByEntry(Map<K, V> map, Comparator<Map.Entry<K, V>> comparator);\npublic static List<Entry<K, V>> sortEntryToList(Collection<Entry<K, V>> collection);\npublic static void forEach(Iterable<T> iterable, Consumer<T> consumer);\npublic static void forEach(Iterator<T> iterator, Consumer<T> consumer);\npublic static void forEach(Enumeration<T> enumeration, Consumer<T> consumer);\npublic static void forEach(Map<K, V> map, KVConsumer<K, V> kvConsumer);\npublic static List<List<T>> group(Collection<T> collection, Hash32<T> hash);\npublic static List<List<T>> groupByField(Collection<T> collection, final String fieldName);\npublic static List<T> reverse(List<T> list);\npublic static List<T> reverseNew(List<T> list);\npublic static List<T> setOrAppend(List<T> list, int index, T element);\npublic static Set<K> keySet(Collection<Map<K, ?>> mapCollection);\npublic static List<V> values(Collection<Map<?, V>> mapCollection);\npublic static T max(Collection<T> coll);\npublic static T min(Collection<T> coll);\npublic static Collection<T> unmodifiable(Collection<? extends T> c);\npublic static T empty(Class<?> collectionClass);\npublic static void clear(Collection<?>... collections);\npublic static void padLeft(List<T> list, int minLen, T padObj);\npublic static void padRight(Collection<T> list, int minLen, T padObj);\npublic static Collection<T> trans(Collection<F> collection, Function<? super F, ? extends T> function);\npublic static void setValueByMap(Iterable<E> iterable, Map<K, V> map, Function<E, K> keyGenerate, BiConsumer<E, V> biConsumer);\npublic static int size(final Object object);\npublic static boolean isEqualList(final Collection<?> list1, final Collection<?> list2);",
        "Class_name": "CollUtil",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/collection/CollUtil###get",
        "Parameter_num": "2",
        "all_Import_statements": "import cn.hutool.core.bean.BeanUtil;\n\nimport cn.hutool.core.comparator.CompareUtil;\n\nimport cn.hutool.core.comparator.PinyinComparator;\n\nimport cn.hutool.core.comparator.PropertyComparator;\n\nimport cn.hutool.core.convert.Convert;\n\nimport cn.hutool.core.convert.ConverterRegistry;\n\nimport cn.hutool.core.exceptions.UtilException;\n\nimport cn.hutool.core.lang.Assert;\n\nimport cn.hutool.core.lang.Editor;\n\nimport cn.hutool.core.lang.Filter;\n\nimport cn.hutool.core.lang.Matcher;\n\nimport cn.hutool.core.lang.func.Func1;\n\nimport cn.hutool.core.lang.hash.Hash32;\n\nimport cn.hutool.core.map.MapUtil;\n\nimport cn.hutool.core.util.*;\n\nimport java.io.Serializable;\n\nimport java.lang.reflect.Type;\n\nimport java.util.*;\n\nimport java.util.Map.Entry;\n\nimport java.util.concurrent.ArrayBlockingQueue;\n\nimport java.util.concurrent.BlockingQueue;\n\nimport java.util.concurrent.CopyOnWriteArrayList;\n\nimport java.util.concurrent.LinkedBlockingDeque;\n\nimport java.util.function.BiConsumer;\n\nimport java.util.function.Function;\n\nimport java.util.function.Predicate;\n\nimport java.util.function.Supplier;\n",
        "comment": "\n\t * 获取集合中指定下标的元素值，下标可以为负数，例如-1表示最后一个元素<br>\n\t * 如果元素越界，返回null\n\t *\n\t * @param <T>        元素类型\n\t * @param collection 集合\n\t * @param index      下标，支持负数\n\t * @return 元素值\n\t * @since 4.0.6\n\t ",
        "packageName": "cn.hutool.core.collection",
        "method_signature": "public static T get(Collection<T> collection, int index);",
        "Junit_version": "5",
        "returnType": "T"
    },
    {
        "Method_body": "public static <T> int lastIndexOf(Collection<T> collection, Matcher<T> matcher) {\n    if (collection instanceof List) {\n        return ListUtil.lastIndexOf((List<T>) collection, matcher);\n    }\n    int matchIndex = -1;\n    if (isNotEmpty(collection)) {\n        int index = 0;\n        for (T t : collection) {\n            if (null == matcher || matcher.match(t)) {\n                matchIndex = index;\n            }\n            index++;\n        }\n    }\n    return matchIndex;\n}",
        "all_field_declaration": "",
        "sub_project_name": "hutool-core",
        "lineNumbers": "4",
        "Filed": "",
        "Parameter_type": "Collection<T>,Matcher<T>",
        "Import_statements": "import cn.hutool.core.lang.Matcher;\n",
        "public_method_signature": "public static Set<T> emptyIfNull(Set<T> set);\npublic static List<T> emptyIfNull(List<T> list);\npublic static Collection<T> union(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> union(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Set<T> unionDistinct(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static List<T> unionAll(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Collection<T> intersection(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> intersection(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Set<T> intersectionDistinct(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Collection<T> disjunction(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> subtract(Collection<T> coll1, Collection<T> coll2);\npublic static List<T> subtractToList(Collection<T> coll1, Collection<T> coll2);\npublic static boolean contains(Collection<?> collection, Object value);\npublic static boolean safeContains(Collection<?> collection, Object value);\npublic static boolean contains(Collection<T> collection, Predicate<? super T> containFunc);\npublic static boolean containsAny(Collection<?> coll1, Collection<?> coll2);\npublic static boolean containsAll(Collection<?> coll1, Collection<?> coll2);\npublic static Map<T, Integer> countMap(Iterable<T> collection);\npublic static String join(Iterable<T> iterable, CharSequence conjunction, Function<T, ? extends CharSequence> func);\npublic static String join(Iterable<T> iterable, CharSequence conjunction);\npublic static String join(Iterable<T> iterable, CharSequence conjunction, String prefix, String suffix);\npublic static String join(Iterator<T> iterator, CharSequence conjunction);\npublic static List<T> popPart(Stack<T> surplusAlaDatas, int partSize);\npublic static List<T> popPart(Deque<T> surplusAlaDatas, int partSize);\npublic static HashSet<T> newHashSet(T... ts);\npublic static LinkedHashSet<T> newLinkedHashSet(T... ts);\npublic static HashSet<T> set(boolean isSorted, T... ts);\npublic static HashSet<T> newHashSet(Collection<T> collection);\npublic static HashSet<T> newHashSet(boolean isSorted, Collection<T> collection);\npublic static HashSet<T> newHashSet(boolean isSorted, Iterator<T> iter);\npublic static HashSet<T> newHashSet(boolean isSorted, Enumeration<T> enumeration);\npublic static List<T> list(boolean isLinked);\npublic static List<T> list(boolean isLinked, T... values);\npublic static List<T> list(boolean isLinked, Collection<T> collection);\npublic static List<T> list(boolean isLinked, Iterable<T> iterable);\npublic static List<T> list(boolean isLinked, Iterator<T> iter);\npublic static List<T> list(boolean isLinked, Enumeration<T> enumeration);\npublic static ArrayList<T> newArrayList(T... values);\npublic static ArrayList<T> toList(T... values);\npublic static ArrayList<T> newArrayList(Collection<T> collection);\npublic static ArrayList<T> newArrayList(Iterable<T> iterable);\npublic static ArrayList<T> newArrayList(Iterator<T> iterator);\npublic static ArrayList<T> newArrayList(Enumeration<T> enumeration);\npublic static LinkedList<T> newLinkedList(T... values);\npublic static CopyOnWriteArrayList<T> newCopyOnWriteArrayList(Collection<T> collection);\npublic static BlockingQueue<T> newBlockingQueue(int capacity, boolean isLinked);\npublic static Collection<T> create(Class<?> collectionType);\npublic static Collection<T> create(Class<?> collectionType, Class<T> elementType);\npublic static ArrayList<T> distinct(Collection<T> collection);\npublic static List<T> distinct(Collection<T> collection, Function<T, K> uniqueGenerator, boolean override);\npublic static List<T> sub(List<T> list, int start, int end);\npublic static List<T> sub(List<T> list, int start, int end, int step);\npublic static List<T> sub(Collection<T> collection, int start, int end);\npublic static List<T> sub(Collection<T> collection, int start, int end, int step);\npublic static List<List<T>> splitList(List<T> list, int size);\npublic static List<List<T>> split(Collection<T> collection, int size);\npublic static Collection<T> edit(Collection<T> collection, Editor<T> editor);\npublic static Collection<T> filterNew(Collection<T> collection, Filter<T> filter);\npublic static T removeAny(T collection, E... elesRemoved);\npublic static T filter(T collection, final Filter<E> filter);\npublic static T removeNull(T collection);\npublic static T removeEmpty(T collection);\npublic static T removeBlank(T collection);\npublic static T removeWithAddIf(T targetCollection, T resultCollection, Predicate<? super E> predicate);\npublic static List<E> removeWithAddIf(T targetCollection, Predicate<? super E> predicate);\npublic static List<Object> extract(Iterable<?> collection, Editor<Object> editor);\npublic static List<Object> extract(Iterable<?> collection, Editor<Object> editor, boolean ignoreNull);\npublic static List<R> map(Iterable<T> collection, Function<? super T, ? extends R> func, boolean ignoreNull);\npublic static List<Object> getFieldValues(Iterable<?> collection, final String fieldName);\npublic static List<Object> getFieldValues(Iterable<?> collection, final String fieldName, boolean ignoreNull);\npublic static List<T> getFieldValues(Iterable<?> collection, final String fieldName, final Class<T> elementType);\npublic static Map<K, V> fieldValueMap(Iterable<V> iterable, String fieldName);\npublic static Map<K, V> fieldValueAsMap(Iterable<?> iterable, String fieldNameForKey, String fieldNameForValue);\npublic static T findOne(Iterable<T> collection, Filter<T> filter);\npublic static T findOneByField(Iterable<T> collection, final String fieldName, final Object fieldValue);\npublic static int count(Iterable<T> iterable, Matcher<T> matcher);\npublic static int indexOf(Collection<T> collection, Matcher<T> matcher);\npublic static int lastIndexOf(Collection<T> collection, Matcher<T> matcher);\npublic static int[] indexOfAll(Collection<T> collection, Matcher<T> matcher);\npublic static boolean isEmpty(Collection<?> collection);\npublic static T defaultIfEmpty(T collection, T defaultCollection);\npublic static T defaultIfEmpty(T collection, Supplier<? extends T> supplier);\npublic static boolean isEmpty(Iterable<?> iterable);\npublic static boolean isEmpty(Iterator<?> Iterator);\npublic static boolean isEmpty(Enumeration<?> enumeration);\npublic static boolean isEmpty(Map<?, ?> map);\npublic static boolean isNotEmpty(Collection<?> collection);\npublic static boolean isNotEmpty(Iterable<?> iterable);\npublic static boolean isNotEmpty(Iterator<?> Iterator);\npublic static boolean isNotEmpty(Enumeration<?> enumeration);\npublic static boolean hasNull(Iterable<?> iterable);\npublic static boolean isNotEmpty(Map<?, ?> map);\npublic static Map<String, String> zip(String keys, String values, String delimiter, boolean isOrder);\npublic static Map<String, String> zip(String keys, String values, String delimiter);\npublic static Map<K, V> zip(Collection<K> keys, Collection<V> values);\npublic static HashMap<K, V> toMap(Iterable<Entry<K, V>> entryIter);\npublic static HashMap<Object, Object> toMap(Object[] array);\npublic static TreeSet<T> toTreeSet(Collection<T> collection, Comparator<T> comparator);\npublic static Enumeration<E> asEnumeration(Iterator<E> iter);\npublic static Iterator<E> asIterator(Enumeration<E> e);\npublic static Iterable<E> asIterable(final Iterator<E> iter);\npublic static Collection<E> toCollection(Iterable<E> iterable);\npublic static Map<K, List<V>> toListMap(Iterable<? extends Map<K, V>> mapList);\npublic static List<Map<K, V>> toMapList(Map<K, ? extends Iterable<V>> listMap);\npublic static Map<K, V> toMap(Iterable<V> values, Map<K, V> map, Func1<V, K> keyFunc);\npublic static Map<K, V> toMap(Iterable<E> values, Map<K, V> map, Func1<E, K> keyFunc, Func1<E, V> valueFunc);\npublic static boolean addIfAbsent(Collection<T> collection, S object);\npublic static Collection<T> addAll(Collection<T> collection, Object value);\npublic static Collection<T> addAll(Collection<T> collection, Object value, Type elementType);\npublic static Collection<T> addAll(Collection<T> collection, Iterator<T> iterator);\npublic static Collection<T> addAll(Collection<T> collection, Iterable<T> iterable);\npublic static Collection<T> addAll(Collection<T> collection, Enumeration<T> enumeration);\npublic static Collection<T> addAll(Collection<T> collection, T[] values);\npublic static List<T> addAllIfNotContains(List<T> list, List<T> otherList);\npublic static T get(Collection<T> collection, int index);\npublic static List<T> getAny(Collection<T> collection, int... indexes);\npublic static T getFirst(Iterable<T> iterable);\npublic static T getFirst(Iterator<T> iterator);\npublic static T getLast(Collection<T> collection);\npublic static Class<?> getElementType(Iterable<?> iterable);\npublic static Class<?> getElementType(Iterator<?> iterator);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, K... keys);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, Iterable<K> keys);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, Iterator<K> keys);\npublic static List<T> sortPageAll(int pageNo, int pageSize, Comparator<T> comparator, Collection<T>... colls);\npublic static List<T> page(int pageNo, int pageSize, List<T> list);\npublic static List<T> sort(Collection<T> collection, Comparator<? super T> comparator);\npublic static List<T> sort(List<T> list, Comparator<? super T> c);\npublic static List<T> sortByProperty(Collection<T> collection, String property);\npublic static List<T> sortByProperty(List<T> list, String property);\npublic static List<String> sortByPinyin(Collection<String> collection);\npublic static List<String> sortByPinyin(List<String> list);\npublic static TreeMap<K, V> sort(Map<K, V> map, Comparator<? super K> comparator);\npublic static LinkedHashMap<K, V> sortToMap(Collection<Map.Entry<K, V>> entryCollection, Comparator<Map.Entry<K, V>> comparator);\npublic static LinkedHashMap<K, V> sortByEntry(Map<K, V> map, Comparator<Map.Entry<K, V>> comparator);\npublic static List<Entry<K, V>> sortEntryToList(Collection<Entry<K, V>> collection);\npublic static void forEach(Iterable<T> iterable, Consumer<T> consumer);\npublic static void forEach(Iterator<T> iterator, Consumer<T> consumer);\npublic static void forEach(Enumeration<T> enumeration, Consumer<T> consumer);\npublic static void forEach(Map<K, V> map, KVConsumer<K, V> kvConsumer);\npublic static List<List<T>> group(Collection<T> collection, Hash32<T> hash);\npublic static List<List<T>> groupByField(Collection<T> collection, final String fieldName);\npublic static List<T> reverse(List<T> list);\npublic static List<T> reverseNew(List<T> list);\npublic static List<T> setOrAppend(List<T> list, int index, T element);\npublic static Set<K> keySet(Collection<Map<K, ?>> mapCollection);\npublic static List<V> values(Collection<Map<?, V>> mapCollection);\npublic static T max(Collection<T> coll);\npublic static T min(Collection<T> coll);\npublic static Collection<T> unmodifiable(Collection<? extends T> c);\npublic static T empty(Class<?> collectionClass);\npublic static void clear(Collection<?>... collections);\npublic static void padLeft(List<T> list, int minLen, T padObj);\npublic static void padRight(Collection<T> list, int minLen, T padObj);\npublic static Collection<T> trans(Collection<F> collection, Function<? super F, ? extends T> function);\npublic static void setValueByMap(Iterable<E> iterable, Map<K, V> map, Function<E, K> keyGenerate, BiConsumer<E, V> biConsumer);\npublic static int size(final Object object);\npublic static boolean isEqualList(final Collection<?> list1, final Collection<?> list2);",
        "public_field": "",
        "Method_statement": "lastIndexOf(Collection<T> collection, Matcher<T> matcher)",
        "Method_name": "lastIndexOf",
        "Class_declaration": "public class CollUtil {\n",
        "constructors": "",
        "all_method_signature": "public static Set<T> emptyIfNull(Set<T> set);\npublic static List<T> emptyIfNull(List<T> list);\npublic static Collection<T> union(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> union(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Set<T> unionDistinct(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static List<T> unionAll(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Collection<T> intersection(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> intersection(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Set<T> intersectionDistinct(Collection<T> coll1, Collection<T> coll2, Collection<T>... otherColls);\npublic static Collection<T> disjunction(Collection<T> coll1, Collection<T> coll2);\npublic static Collection<T> subtract(Collection<T> coll1, Collection<T> coll2);\npublic static List<T> subtractToList(Collection<T> coll1, Collection<T> coll2);\npublic static boolean contains(Collection<?> collection, Object value);\npublic static boolean safeContains(Collection<?> collection, Object value);\npublic static boolean contains(Collection<T> collection, Predicate<? super T> containFunc);\npublic static boolean containsAny(Collection<?> coll1, Collection<?> coll2);\npublic static boolean containsAll(Collection<?> coll1, Collection<?> coll2);\npublic static Map<T, Integer> countMap(Iterable<T> collection);\npublic static String join(Iterable<T> iterable, CharSequence conjunction, Function<T, ? extends CharSequence> func);\npublic static String join(Iterable<T> iterable, CharSequence conjunction);\npublic static String join(Iterable<T> iterable, CharSequence conjunction, String prefix, String suffix);\npublic static String join(Iterator<T> iterator, CharSequence conjunction);\npublic static List<T> popPart(Stack<T> surplusAlaDatas, int partSize);\npublic static List<T> popPart(Deque<T> surplusAlaDatas, int partSize);\npublic static HashSet<T> newHashSet(T... ts);\npublic static LinkedHashSet<T> newLinkedHashSet(T... ts);\npublic static HashSet<T> set(boolean isSorted, T... ts);\npublic static HashSet<T> newHashSet(Collection<T> collection);\npublic static HashSet<T> newHashSet(boolean isSorted, Collection<T> collection);\npublic static HashSet<T> newHashSet(boolean isSorted, Iterator<T> iter);\npublic static HashSet<T> newHashSet(boolean isSorted, Enumeration<T> enumeration);\npublic static List<T> list(boolean isLinked);\npublic static List<T> list(boolean isLinked, T... values);\npublic static List<T> list(boolean isLinked, Collection<T> collection);\npublic static List<T> list(boolean isLinked, Iterable<T> iterable);\npublic static List<T> list(boolean isLinked, Iterator<T> iter);\npublic static List<T> list(boolean isLinked, Enumeration<T> enumeration);\npublic static ArrayList<T> newArrayList(T... values);\npublic static ArrayList<T> toList(T... values);\npublic static ArrayList<T> newArrayList(Collection<T> collection);\npublic static ArrayList<T> newArrayList(Iterable<T> iterable);\npublic static ArrayList<T> newArrayList(Iterator<T> iterator);\npublic static ArrayList<T> newArrayList(Enumeration<T> enumeration);\npublic static LinkedList<T> newLinkedList(T... values);\npublic static CopyOnWriteArrayList<T> newCopyOnWriteArrayList(Collection<T> collection);\npublic static BlockingQueue<T> newBlockingQueue(int capacity, boolean isLinked);\npublic static Collection<T> create(Class<?> collectionType);\npublic static Collection<T> create(Class<?> collectionType, Class<T> elementType);\npublic static ArrayList<T> distinct(Collection<T> collection);\npublic static List<T> distinct(Collection<T> collection, Function<T, K> uniqueGenerator, boolean override);\npublic static List<T> sub(List<T> list, int start, int end);\npublic static List<T> sub(List<T> list, int start, int end, int step);\npublic static List<T> sub(Collection<T> collection, int start, int end);\npublic static List<T> sub(Collection<T> collection, int start, int end, int step);\npublic static List<List<T>> splitList(List<T> list, int size);\npublic static List<List<T>> split(Collection<T> collection, int size);\npublic static Collection<T> edit(Collection<T> collection, Editor<T> editor);\npublic static Collection<T> filterNew(Collection<T> collection, Filter<T> filter);\npublic static T removeAny(T collection, E... elesRemoved);\npublic static T filter(T collection, final Filter<E> filter);\npublic static T removeNull(T collection);\npublic static T removeEmpty(T collection);\npublic static T removeBlank(T collection);\npublic static T removeWithAddIf(T targetCollection, T resultCollection, Predicate<? super E> predicate);\npublic static List<E> removeWithAddIf(T targetCollection, Predicate<? super E> predicate);\npublic static List<Object> extract(Iterable<?> collection, Editor<Object> editor);\npublic static List<Object> extract(Iterable<?> collection, Editor<Object> editor, boolean ignoreNull);\npublic static List<R> map(Iterable<T> collection, Function<? super T, ? extends R> func, boolean ignoreNull);\npublic static List<Object> getFieldValues(Iterable<?> collection, final String fieldName);\npublic static List<Object> getFieldValues(Iterable<?> collection, final String fieldName, boolean ignoreNull);\npublic static List<T> getFieldValues(Iterable<?> collection, final String fieldName, final Class<T> elementType);\npublic static Map<K, V> fieldValueMap(Iterable<V> iterable, String fieldName);\npublic static Map<K, V> fieldValueAsMap(Iterable<?> iterable, String fieldNameForKey, String fieldNameForValue);\npublic static T findOne(Iterable<T> collection, Filter<T> filter);\npublic static T findOneByField(Iterable<T> collection, final String fieldName, final Object fieldValue);\npublic static int count(Iterable<T> iterable, Matcher<T> matcher);\npublic static int indexOf(Collection<T> collection, Matcher<T> matcher);\npublic static int lastIndexOf(Collection<T> collection, Matcher<T> matcher);\npublic static int[] indexOfAll(Collection<T> collection, Matcher<T> matcher);\npublic static boolean isEmpty(Collection<?> collection);\npublic static T defaultIfEmpty(T collection, T defaultCollection);\npublic static T defaultIfEmpty(T collection, Supplier<? extends T> supplier);\npublic static boolean isEmpty(Iterable<?> iterable);\npublic static boolean isEmpty(Iterator<?> Iterator);\npublic static boolean isEmpty(Enumeration<?> enumeration);\npublic static boolean isEmpty(Map<?, ?> map);\npublic static boolean isNotEmpty(Collection<?> collection);\npublic static boolean isNotEmpty(Iterable<?> iterable);\npublic static boolean isNotEmpty(Iterator<?> Iterator);\npublic static boolean isNotEmpty(Enumeration<?> enumeration);\npublic static boolean hasNull(Iterable<?> iterable);\npublic static boolean isNotEmpty(Map<?, ?> map);\npublic static Map<String, String> zip(String keys, String values, String delimiter, boolean isOrder);\npublic static Map<String, String> zip(String keys, String values, String delimiter);\npublic static Map<K, V> zip(Collection<K> keys, Collection<V> values);\npublic static HashMap<K, V> toMap(Iterable<Entry<K, V>> entryIter);\npublic static HashMap<Object, Object> toMap(Object[] array);\npublic static TreeSet<T> toTreeSet(Collection<T> collection, Comparator<T> comparator);\npublic static Enumeration<E> asEnumeration(Iterator<E> iter);\npublic static Iterator<E> asIterator(Enumeration<E> e);\npublic static Iterable<E> asIterable(final Iterator<E> iter);\npublic static Collection<E> toCollection(Iterable<E> iterable);\npublic static Map<K, List<V>> toListMap(Iterable<? extends Map<K, V>> mapList);\npublic static List<Map<K, V>> toMapList(Map<K, ? extends Iterable<V>> listMap);\npublic static Map<K, V> toMap(Iterable<V> values, Map<K, V> map, Func1<V, K> keyFunc);\npublic static Map<K, V> toMap(Iterable<E> values, Map<K, V> map, Func1<E, K> keyFunc, Func1<E, V> valueFunc);\npublic static boolean addIfAbsent(Collection<T> collection, S object);\npublic static Collection<T> addAll(Collection<T> collection, Object value);\npublic static Collection<T> addAll(Collection<T> collection, Object value, Type elementType);\npublic static Collection<T> addAll(Collection<T> collection, Iterator<T> iterator);\npublic static Collection<T> addAll(Collection<T> collection, Iterable<T> iterable);\npublic static Collection<T> addAll(Collection<T> collection, Enumeration<T> enumeration);\npublic static Collection<T> addAll(Collection<T> collection, T[] values);\npublic static List<T> addAllIfNotContains(List<T> list, List<T> otherList);\npublic static T get(Collection<T> collection, int index);\npublic static List<T> getAny(Collection<T> collection, int... indexes);\npublic static T getFirst(Iterable<T> iterable);\npublic static T getFirst(Iterator<T> iterator);\npublic static T getLast(Collection<T> collection);\npublic static Class<?> getElementType(Iterable<?> iterable);\npublic static Class<?> getElementType(Iterator<?> iterator);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, K... keys);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, Iterable<K> keys);\npublic static ArrayList<V> valuesOfKeys(Map<K, V> map, Iterator<K> keys);\npublic static List<T> sortPageAll(int pageNo, int pageSize, Comparator<T> comparator, Collection<T>... colls);\npublic static List<T> page(int pageNo, int pageSize, List<T> list);\npublic static List<T> sort(Collection<T> collection, Comparator<? super T> comparator);\npublic static List<T> sort(List<T> list, Comparator<? super T> c);\npublic static List<T> sortByProperty(Collection<T> collection, String property);\npublic static List<T> sortByProperty(List<T> list, String property);\npublic static List<String> sortByPinyin(Collection<String> collection);\npublic static List<String> sortByPinyin(List<String> list);\npublic static TreeMap<K, V> sort(Map<K, V> map, Comparator<? super K> comparator);\npublic static LinkedHashMap<K, V> sortToMap(Collection<Map.Entry<K, V>> entryCollection, Comparator<Map.Entry<K, V>> comparator);\npublic static LinkedHashMap<K, V> sortByEntry(Map<K, V> map, Comparator<Map.Entry<K, V>> comparator);\npublic static List<Entry<K, V>> sortEntryToList(Collection<Entry<K, V>> collection);\npublic static void forEach(Iterable<T> iterable, Consumer<T> consumer);\npublic static void forEach(Iterator<T> iterator, Consumer<T> consumer);\npublic static void forEach(Enumeration<T> enumeration, Consumer<T> consumer);\npublic static void forEach(Map<K, V> map, KVConsumer<K, V> kvConsumer);\npublic static List<List<T>> group(Collection<T> collection, Hash32<T> hash);\npublic static List<List<T>> groupByField(Collection<T> collection, final String fieldName);\npublic static List<T> reverse(List<T> list);\npublic static List<T> reverseNew(List<T> list);\npublic static List<T> setOrAppend(List<T> list, int index, T element);\npublic static Set<K> keySet(Collection<Map<K, ?>> mapCollection);\npublic static List<V> values(Collection<Map<?, V>> mapCollection);\npublic static T max(Collection<T> coll);\npublic static T min(Collection<T> coll);\npublic static Collection<T> unmodifiable(Collection<? extends T> c);\npublic static T empty(Class<?> collectionClass);\npublic static void clear(Collection<?>... collections);\npublic static void padLeft(List<T> list, int minLen, T padObj);\npublic static void padRight(Collection<T> list, int minLen, T padObj);\npublic static Collection<T> trans(Collection<F> collection, Function<? super F, ? extends T> function);\npublic static void setValueByMap(Iterable<E> iterable, Map<K, V> map, Function<E, K> keyGenerate, BiConsumer<E, V> biConsumer);\npublic static int size(final Object object);\npublic static boolean isEqualList(final Collection<?> list1, final Collection<?> list2);",
        "Class_name": "CollUtil",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/collection/CollUtil###lastIndexOf",
        "Parameter_num": "2",
        "all_Import_statements": "import cn.hutool.core.bean.BeanUtil;\n\nimport cn.hutool.core.comparator.CompareUtil;\n\nimport cn.hutool.core.comparator.PinyinComparator;\n\nimport cn.hutool.core.comparator.PropertyComparator;\n\nimport cn.hutool.core.convert.Convert;\n\nimport cn.hutool.core.convert.ConverterRegistry;\n\nimport cn.hutool.core.exceptions.UtilException;\n\nimport cn.hutool.core.lang.Assert;\n\nimport cn.hutool.core.lang.Editor;\n\nimport cn.hutool.core.lang.Filter;\n\nimport cn.hutool.core.lang.Matcher;\n\nimport cn.hutool.core.lang.func.Func1;\n\nimport cn.hutool.core.lang.hash.Hash32;\n\nimport cn.hutool.core.map.MapUtil;\n\nimport cn.hutool.core.util.*;\n\nimport java.io.Serializable;\n\nimport java.lang.reflect.Type;\n\nimport java.util.*;\n\nimport java.util.Map.Entry;\n\nimport java.util.concurrent.ArrayBlockingQueue;\n\nimport java.util.concurrent.BlockingQueue;\n\nimport java.util.concurrent.CopyOnWriteArrayList;\n\nimport java.util.concurrent.LinkedBlockingDeque;\n\nimport java.util.function.BiConsumer;\n\nimport java.util.function.Function;\n\nimport java.util.function.Predicate;\n\nimport java.util.function.Supplier;\n",
        "comment": "\n\t * 获取匹配规则定义中匹配到元素的最后位置<br>\n\t * 此方法对于某些无序集合的位置信息，以转换为数组后的位置为准。\n\t *\n\t * @param <T>        元素类型\n\t * @param collection 集合\n\t * @param matcher    匹配器，为空则全部匹配\n\t * @return 最后一个位置\n\t * @since 5.6.6\n\t ",
        "packageName": "cn.hutool.core.collection",
        "method_signature": "public static int lastIndexOf(Collection<T> collection, Matcher<T> matcher);",
        "Junit_version": "5",
        "returnType": "int"
    },
    {
        "Method_body": "public static long hash64(byte[] data) {\n    int len = data.length;\n    if (len <= 32) {\n        if (len <= 16) {\n            return hashLen0to16(data);\n        } else {\n            return hashLen17to32(data);\n        }\n    } else if (len <= 64) {\n        return hashLen33to64(data);\n    }\n    long x = fetch64(data, len - 40);\n    long y = fetch64(data, len - 16) + fetch64(data, len - 56);\n    long z = hashLen16(fetch64(data, len - 48) + len, fetch64(data, len - 24));\n    Number128 v = weakHashLen32WithSeeds(data, len - 64, len, z);\n    Number128 w = weakHashLen32WithSeeds(data, len - 32, y + k1, x);\n    x = x * k1 + fetch64(data, 0);\n    len = (len - 1) & ~63;\n    int pos = 0;\n    do {\n        x = rotate64(x + y + v.getLowValue() + fetch64(data, pos + 8), 37) * k1;\n        y = rotate64(y + v.getHighValue() + fetch64(data, pos + 48), 42) * k1;\n        x ^= w.getHighValue();\n        y += v.getLowValue() + fetch64(data, pos + 40);\n        z = rotate64(z + w.getLowValue(), 33) * k1;\n        v = weakHashLen32WithSeeds(data, pos, v.getHighValue() * k1, x + w.getLowValue());\n        w = weakHashLen32WithSeeds(data, pos + 32, z + w.getHighValue(), y + fetch64(data, pos + 16));\n        long swapValue = x;\n        x = z;\n        z = swapValue;\n        pos += 64;\n        len -= 64;\n    } while (len != 0);\n    return hashLen16(hashLen16(v.getLowValue(), w.getLowValue()) + shiftMix(y) * k1 + z, hashLen16(v.getHighValue(), w.getHighValue()) + x);\n}",
        "all_field_declaration": "// Some primes between 2^63 and 2^64 for various uses.\nprivate static final long k0 = 0xc3a5c85c97cb3127L;\nprivate static final long k1 = 0xb492b66fbe98f273L;\nprivate static final long k2 = 0x9ae16a3b2f90404fL;\nprivate static final long kMul = 0x9ddfea08eb382d69L;\n// Magic numbers for 32-bit hashing.  Copied from Murmur3.\nprivate static final int c1 = 0xcc9e2d51;\nprivate static final int c2 = 0x1b873593;",
        "sub_project_name": "hutool-core",
        "lineNumbers": "12",
        "Filed": "private static final long k1 = 0xb492b66fbe98f273L;",
        "Parameter_type": "byte[]",
        "Import_statements": "",
        "public_method_signature": "public static int hash32(byte[] data);\npublic static long hash64(byte[] data);\npublic static long hash64(byte[] data, long seed0, long seed1);\npublic static long hash64(byte[] data, long seed);\npublic static Number128 hash128(byte[] data);\npublic static Number128 hash128(byte[] data, Number128 seed);",
        "public_field": "",
        "Method_statement": "hash64(byte() data)",
        "Method_name": "hash64",
        "Class_declaration": "public class CityHash {\n",
        "constructors": "",
        "all_method_signature": "public static int hash32(byte[] data);\npublic static long hash64(byte[] data);\npublic static long hash64(byte[] data, long seed0, long seed1);\npublic static long hash64(byte[] data, long seed);\npublic static Number128 hash128(byte[] data);\npublic static Number128 hash128(byte[] data, Number128 seed);\nprivate static Number128 hash128(final byte[] byteArray, int start, final Number128 seed);\nprivate static int hash32Len0to4(final byte[] byteArray);\nprivate static int hash32Len5to12(final byte[] byteArray);\nprivate static int hash32Len13to24(byte[] byteArray);\nprivate static long hashLen0to16(byte[] byteArray);\nprivate static long hashLen17to32(byte[] byteArray);\nprivate static long hashLen33to64(byte[] byteArray);\nprivate static long fetch64(byte[] byteArray, int start);\nprivate static int fetch32(byte[] byteArray, final int start);\nprivate static long rotate64(long val, int shift);\nprivate static int rotate32(int val, int shift);\nprivate static long hashLen16(long u, long v, long mul);\nprivate static long hashLen16(long u, long v);\nprivate static long hash128to64(final Number128 number128);\nprivate static long shiftMix(long val);\nprivate static int fmix(int h);\nprivate static int mur(int a, int h);\nprivate static Number128 weakHashLen32WithSeeds(long w, long x, long y, long z, long a, long b);\nprivate static Number128 weakHashLen32WithSeeds(byte[] byteArray, int start, long a, long b);\nprivate static Number128 cityMurmur(final byte[] byteArray, Number128 seed);",
        "Class_name": "CityHash",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/lang/hash/CityHash###hash64",
        "Parameter_num": "1",
        "all_Import_statements": "import cn.hutool.core.util.ByteUtil;\n\nimport java.util.Arrays;\n",
        "comment": "\n\t * 计算64位City Hash值\n\t *\n\t * @param data 数据\n\t * @return hash值\n\t ",
        "packageName": "cn.hutool.core.lang.hash",
        "method_signature": "public static long hash64(byte[] data);",
        "Junit_version": "5",
        "returnType": "long"
    },
    {
        "Method_body": "@SuppressWarnings(\"unchecked\")\npublic static <T> T get(Object array, int index) {\n    if (null == array) {\n        return null;\n    }\n    if (index < 0) {\n        index += Array.getLength(array);\n    }\n    try {\n        return (T) Array.get(array, index);\n    } catch (ArrayIndexOutOfBoundsException e) {\n        return null;\n    }\n}",
        "all_field_declaration": "",
        "sub_project_name": "hutool-core",
        "lineNumbers": "3",
        "Filed": "",
        "Parameter_type": "Object,int",
        "Import_statements": "import java.lang.reflect.Array;\n",
        "public_method_signature": "public static boolean isEmpty(T[] array);\npublic static T[] defaultIfEmpty(T[] array, T[] defaultArray);\npublic static boolean isEmpty(Object array);\npublic static boolean isNotEmpty(T[] array);\npublic static boolean isNotEmpty(Object array);\npublic static boolean hasNull(T... array);\npublic static boolean isAllNull(T... array);\npublic static T firstNonNull(T... array);\npublic static T firstMatch(Matcher<T> matcher, T... array);\npublic static int matchIndex(Matcher<T> matcher, T... array);\npublic static int matchIndex(Matcher<T> matcher, int beginIndexInclude, T... array);\npublic static T[] newArray(Class<?> componentType, int newSize);\npublic static Object[] newArray(int newSize);\npublic static Class<?> getComponentType(Object array);\npublic static Class<?> getComponentType(Class<?> arrayClass);\npublic static Class<?> getArrayType(Class<?> componentType);\npublic static Object[] cast(Class<?> type, Object arrayObj) throws NullPointerException, IllegalArgumentException;\npublic static T[] append(T[] buffer, T... newElements);\npublic static Object append(Object array, T... newElements);\npublic static T[] setOrAppend(T[] buffer, int index, T value);\npublic static Object setOrAppend(Object array, int index, Object value);\npublic static T[] replace(T[] buffer, int index, T... values);\npublic static T[] insert(T[] buffer, int index, T... newElements);\npublic static Object insert(Object array, int index, T... newElements);\npublic static T[] resize(T[] data, int newSize, Class<?> componentType);\npublic static Object resize(Object array, int newSize);\npublic static T[] resize(T[] buffer, int newSize);\npublic static T[] addAll(T[]... arrays);\npublic static Object copy(Object src, int srcPos, Object dest, int destPos, int length);\npublic static Object copy(Object src, Object dest, int length);\npublic static T[] clone(T[] array);\npublic static T clone(final T obj);\npublic static T[] edit(T[] array, Editor<T> editor);\npublic static T[] filter(T[] array, Filter<T> filter);\npublic static T[] removeNull(T[] array);\npublic static T[] removeEmpty(T[] array);\npublic static T[] removeBlank(T[] array);\npublic static String[] nullToEmpty(String[] array);\npublic static Map<K, V> zip(K[] keys, V[] values, boolean isOrder);\npublic static Map<K, V> zip(K[] keys, V[] values);\npublic static int indexOf(T[] array, Object value, int beginIndexInclude);\npublic static int indexOf(T[] array, Object value);\npublic static int indexOfIgnoreCase(CharSequence[] array, CharSequence value);\npublic static int lastIndexOf(T[] array, Object value);\npublic static int lastIndexOf(T[] array, Object value, int endInclude);\npublic static boolean contains(T[] array, T value);\npublic static boolean containsAny(T[] array, T... values);\npublic static boolean containsAll(T[] array, T... values);\npublic static boolean containsIgnoreCase(CharSequence[] array, CharSequence value);\npublic static Object[] wrap(Object obj);\npublic static boolean isArray(Object obj);\npublic static T get(Object array, int index);\npublic static T[] getAny(Object array, int... indexes);\npublic static T[] sub(T[] array, int start, int end);\npublic static Object[] sub(Object array, int start, int end);\npublic static Object[] sub(Object array, int start, int end, int step);\npublic static String toString(Object obj);\npublic static int length(Object array) throws IllegalArgumentException;\npublic static String join(T[] array, CharSequence conjunction);\npublic static String join(T[] array, CharSequence delimiter, String prefix, String suffix);\npublic static String join(T[] array, CharSequence conjunction, Editor<T> editor);\npublic static String join(Object array, CharSequence conjunction);\npublic static byte[] toArray(ByteBuffer bytebuffer);\npublic static T[] toArray(Iterator<T> iterator, Class<T> componentType);\npublic static T[] toArray(Iterable<T> iterable, Class<T> componentType);\npublic static T[] toArray(Collection<T> collection, Class<T> componentType);\npublic static T[] remove(T[] array, int index) throws IllegalArgumentException;\npublic static T[] removeEle(T[] array, T element) throws IllegalArgumentException;\npublic static T[] reverse(T[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static T[] reverse(T[] array);\npublic static T min(T[] numberArray);\npublic static T min(T[] numberArray, Comparator<T> comparator);\npublic static T max(T[] numberArray);\npublic static T max(T[] numberArray, Comparator<T> comparator);\npublic static T[] shuffle(T[] array);\npublic static T[] shuffle(T[] array, Random random);\npublic static T[] swap(T[] array, int index1, int index2);\npublic static Object swap(Object array, int index1, int index2);\npublic static int emptyCount(Object... args);\npublic static boolean hasEmpty(Object... args);\npublic static boolean isAllEmpty(Object... args);\npublic static boolean isAllNotEmpty(Object... args);\npublic static boolean isAllNotNull(T... array);\npublic static T[] distinct(T[] array);\npublic static T[] distinct(T[] array, Function<T, K> uniqueGenerator, boolean override);\npublic static R[] map(T[] array, Class<R> targetComponentType, Function<? super T, ? extends R> func);\npublic static R[] map(Object array, Class<R> targetComponentType, Function<? super T, ? extends R> func);\npublic static List<R> map(T[] array, Function<? super T, ? extends R> func);\npublic static Set<R> mapToSet(T[] array, Function<? super T, ? extends R> func);\npublic static boolean equals(Object array1, Object array2);\npublic static boolean isSub(T[] array, T[] subArray);\npublic static int indexOfSub(T[] array, T[] subArray);\npublic static int indexOfSub(T[] array, int beginInclude, T[] subArray);\npublic static int lastIndexOfSub(T[] array, T[] subArray);\npublic static int lastIndexOfSub(T[] array, int endInclude, T[] subArray);\npublic static boolean isSorted(T[] array, Comparator<? super T> comparator);\npublic static boolean isSorted(T[] array);\npublic static boolean isSortedASC(T[] array);\npublic static boolean isSortedDESC(T[] array);",
        "public_field": "",
        "Method_statement": "get(Object array, int index)",
        "Method_name": "get",
        "Class_declaration": "public class ArrayUtil {\n",
        "constructors": "",
        "all_method_signature": "public static boolean isEmpty(T[] array);\npublic static T[] defaultIfEmpty(T[] array, T[] defaultArray);\npublic static boolean isEmpty(Object array);\npublic static boolean isNotEmpty(T[] array);\npublic static boolean isNotEmpty(Object array);\npublic static boolean hasNull(T... array);\npublic static boolean isAllNull(T... array);\npublic static T firstNonNull(T... array);\npublic static T firstMatch(Matcher<T> matcher, T... array);\npublic static int matchIndex(Matcher<T> matcher, T... array);\npublic static int matchIndex(Matcher<T> matcher, int beginIndexInclude, T... array);\npublic static T[] newArray(Class<?> componentType, int newSize);\npublic static Object[] newArray(int newSize);\npublic static Class<?> getComponentType(Object array);\npublic static Class<?> getComponentType(Class<?> arrayClass);\npublic static Class<?> getArrayType(Class<?> componentType);\npublic static Object[] cast(Class<?> type, Object arrayObj) throws NullPointerException, IllegalArgumentException;\npublic static T[] append(T[] buffer, T... newElements);\npublic static Object append(Object array, T... newElements);\npublic static T[] setOrAppend(T[] buffer, int index, T value);\npublic static Object setOrAppend(Object array, int index, Object value);\npublic static T[] replace(T[] buffer, int index, T... values);\npublic static T[] insert(T[] buffer, int index, T... newElements);\npublic static Object insert(Object array, int index, T... newElements);\npublic static T[] resize(T[] data, int newSize, Class<?> componentType);\npublic static Object resize(Object array, int newSize);\npublic static T[] resize(T[] buffer, int newSize);\npublic static T[] addAll(T[]... arrays);\npublic static Object copy(Object src, int srcPos, Object dest, int destPos, int length);\npublic static Object copy(Object src, Object dest, int length);\npublic static T[] clone(T[] array);\npublic static T clone(final T obj);\npublic static T[] edit(T[] array, Editor<T> editor);\npublic static T[] filter(T[] array, Filter<T> filter);\npublic static T[] removeNull(T[] array);\npublic static T[] removeEmpty(T[] array);\npublic static T[] removeBlank(T[] array);\npublic static String[] nullToEmpty(String[] array);\npublic static Map<K, V> zip(K[] keys, V[] values, boolean isOrder);\npublic static Map<K, V> zip(K[] keys, V[] values);\npublic static int indexOf(T[] array, Object value, int beginIndexInclude);\npublic static int indexOf(T[] array, Object value);\npublic static int indexOfIgnoreCase(CharSequence[] array, CharSequence value);\npublic static int lastIndexOf(T[] array, Object value);\npublic static int lastIndexOf(T[] array, Object value, int endInclude);\npublic static boolean contains(T[] array, T value);\npublic static boolean containsAny(T[] array, T... values);\npublic static boolean containsAll(T[] array, T... values);\npublic static boolean containsIgnoreCase(CharSequence[] array, CharSequence value);\npublic static Object[] wrap(Object obj);\npublic static boolean isArray(Object obj);\npublic static T get(Object array, int index);\npublic static T[] getAny(Object array, int... indexes);\npublic static T[] sub(T[] array, int start, int end);\npublic static Object[] sub(Object array, int start, int end);\npublic static Object[] sub(Object array, int start, int end, int step);\npublic static String toString(Object obj);\npublic static int length(Object array) throws IllegalArgumentException;\npublic static String join(T[] array, CharSequence conjunction);\npublic static String join(T[] array, CharSequence delimiter, String prefix, String suffix);\npublic static String join(T[] array, CharSequence conjunction, Editor<T> editor);\npublic static String join(Object array, CharSequence conjunction);\npublic static byte[] toArray(ByteBuffer bytebuffer);\npublic static T[] toArray(Iterator<T> iterator, Class<T> componentType);\npublic static T[] toArray(Iterable<T> iterable, Class<T> componentType);\npublic static T[] toArray(Collection<T> collection, Class<T> componentType);\npublic static T[] remove(T[] array, int index) throws IllegalArgumentException;\npublic static T[] removeEle(T[] array, T element) throws IllegalArgumentException;\npublic static T[] reverse(T[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static T[] reverse(T[] array);\npublic static T min(T[] numberArray);\npublic static T min(T[] numberArray, Comparator<T> comparator);\npublic static T max(T[] numberArray);\npublic static T max(T[] numberArray, Comparator<T> comparator);\npublic static T[] shuffle(T[] array);\npublic static T[] shuffle(T[] array, Random random);\npublic static T[] swap(T[] array, int index1, int index2);\npublic static Object swap(Object array, int index1, int index2);\npublic static int emptyCount(Object... args);\npublic static boolean hasEmpty(Object... args);\npublic static boolean isAllEmpty(Object... args);\npublic static boolean isAllNotEmpty(Object... args);\npublic static boolean isAllNotNull(T... array);\npublic static T[] distinct(T[] array);\npublic static T[] distinct(T[] array, Function<T, K> uniqueGenerator, boolean override);\npublic static R[] map(T[] array, Class<R> targetComponentType, Function<? super T, ? extends R> func);\npublic static R[] map(Object array, Class<R> targetComponentType, Function<? super T, ? extends R> func);\npublic static List<R> map(T[] array, Function<? super T, ? extends R> func);\npublic static Set<R> mapToSet(T[] array, Function<? super T, ? extends R> func);\npublic static boolean equals(Object array1, Object array2);\npublic static boolean isSub(T[] array, T[] subArray);\npublic static int indexOfSub(T[] array, T[] subArray);\npublic static int indexOfSub(T[] array, int beginInclude, T[] subArray);\npublic static int lastIndexOfSub(T[] array, T[] subArray);\npublic static int lastIndexOfSub(T[] array, int endInclude, T[] subArray);\npublic static boolean isSorted(T[] array, Comparator<? super T> comparator);\npublic static boolean isSorted(T[] array);\npublic static boolean isSortedASC(T[] array);\npublic static boolean isSortedDESC(T[] array);",
        "Class_name": "ArrayUtil",
        "project_path": "dromara_hutool###dromara_hutool/hutool-core/src/main/java/cn/hutool/core/util/ArrayUtil###get",
        "Parameter_num": "2",
        "all_Import_statements": "import cn.hutool.core.collection.CollUtil;\n\nimport cn.hutool.core.collection.CollectionUtil;\n\nimport cn.hutool.core.collection.UniqueKeySet;\n\nimport cn.hutool.core.comparator.CompareUtil;\n\nimport cn.hutool.core.convert.Convert;\n\nimport cn.hutool.core.exceptions.UtilException;\n\nimport cn.hutool.core.lang.Assert;\n\nimport cn.hutool.core.lang.Editor;\n\nimport cn.hutool.core.lang.Filter;\n\nimport cn.hutool.core.lang.Matcher;\n\nimport cn.hutool.core.map.MapUtil;\n\nimport cn.hutool.core.text.StrJoiner;\n\nimport java.lang.reflect.Array;\n\nimport java.nio.ByteBuffer;\n\nimport java.util.ArrayList;\n\nimport java.util.Arrays;\n\nimport java.util.Collection;\n\nimport java.util.Collections;\n\nimport java.util.Comparator;\n\nimport java.util.Iterator;\n\nimport java.util.LinkedHashSet;\n\nimport java.util.List;\n\nimport java.util.Map;\n\nimport java.util.Random;\n\nimport java.util.Set;\n\nimport java.util.function.Function;\n\nimport java.util.stream.Collectors;\n",
        "comment": "\n\t * 获取数组对象中指定index的值，支持负数，例如-1表示倒数第一个值<br>\n\t * 如果数组下标越界，返回null\n\t *\n\t * @param <T>   数组元素类型\n\t * @param array 数组对象\n\t * @param index 下标，支持负数\n\t * @return 值\n\t * @since 4.0.6\n\t ",
        "packageName": "cn.hutool.core.util",
        "method_signature": "public static T get(Object array, int index);",
        "Junit_version": "5",
        "returnType": "T"
    },
    {
        "Method_body": "@Override\npublic boolean objectsEqual(T data1, T data2) throws SQLException {\n    checkForInitialized();\n    for (FieldType fieldType : tableInfo.getFieldTypes()) {\n        Object fieldObj1 = fieldType.extractJavaFieldValue(data1);\n        Object fieldObj2 = fieldType.extractJavaFieldValue(data2);\n        if (!fieldType.getDataPersister().dataIsEqual(fieldObj1, fieldObj2)) {\n            return false;\n        }\n    }\n    return true;\n}",
        "all_field_declaration": "private static final ThreadLocal<List<BaseDaoImpl<?, ?>>> daoConfigLevelLocal = new ThreadLocal<List<BaseDaoImpl<?, ?>>>() {\n\n    @Override\n    protected List<BaseDaoImpl<?, ?>> initialValue() {\n        return new ArrayList<BaseDaoImpl<?, ?>>(10);\n    }\n};\nprivate static ReferenceObjectCache defaultObjectCache;\nprivate static final Object constantObject = new Object();\nprotected StatementExecutor<T, ID> statementExecutor;\nprotected DatabaseType databaseType;\nprotected final Class<T> dataClass;\nprotected Constructor<T> constructor;\nprotected DatabaseTableConfig<T> tableConfig;\nprotected TableInfo<T, ID> tableInfo;\nprotected ConnectionSource connectionSource;\nprotected CloseableIterator<T> lastIterator;\nprotected ObjectFactory<T> objectFactory;\nprivate boolean initialized;\n// NOTE: package perms to removed synthetic accessor\nObjectCache objectCache;\nprivate ConcurrentMap<DaoObserver, Object> daoObserverMap;",
        "sub_project_name": "j256_ormlite-core",
        "lineNumbers": "3",
        "Filed": "protected TableInfo<T, ID> tableInfo;",
        "Parameter_type": "T,T",
        "Import_statements": "import java.sql.SQLException;\nimport com.j256.ormlite.field.FieldType;\n",
        "public_method_signature": "public void initialize() throws SQLException;\npublic T queryForId(ID id) throws SQLException;\npublic T queryForFirst(PreparedQuery<T> preparedQuery) throws SQLException;\npublic List<T> queryForAll() throws SQLException;\npublic T queryForFirst() throws SQLException;\npublic List<T> queryForEq(String fieldName, Object value) throws SQLException;\npublic QueryBuilder<T, ID> queryBuilder();\npublic UpdateBuilder<T, ID> updateBuilder();\npublic DeleteBuilder<T, ID> deleteBuilder();\npublic List<T> query(PreparedQuery<T> preparedQuery) throws SQLException;\npublic List<T> queryForMatching(T matchObj) throws SQLException;\npublic List<T> queryForMatchingArgs(T matchObj) throws SQLException;\npublic List<T> queryForFieldValues(Map<String, Object> fieldValues) throws SQLException;\npublic List<T> queryForFieldValuesArgs(Map<String, Object> fieldValues) throws SQLException;\npublic T queryForSameId(T data) throws SQLException;\npublic int create(T data) throws SQLException;\npublic int create(final Collection<T> datas) throws SQLException;\npublic synchronized T createIfNotExists(T data) throws SQLException;\npublic synchronized T createIfNotExists(ID key, final Supplier<T> entitySupplier) throws SQLException;\npublic synchronized CreateOrUpdateStatus createOrUpdate(T data) throws SQLException;\npublic int update(T data) throws SQLException;\npublic int updateId(T data, ID newId) throws SQLException;\npublic int update(PreparedUpdate<T> preparedUpdate) throws SQLException;\npublic int refresh(T data) throws SQLException;\npublic int delete(T data) throws SQLException;\npublic int deleteById(ID id) throws SQLException;\npublic int delete(Collection<T> datas) throws SQLException;\npublic int deleteIds(Collection<ID> ids) throws SQLException;\npublic int delete(PreparedDelete<T> preparedDelete) throws SQLException;\npublic CloseableIterator<T> iterator();\npublic CloseableIterator<T> closeableIterator();\npublic CloseableIterator<T> iterator(int resultFlags);\npublic CloseableWrappedIterable<T> getWrappedIterable();\npublic CloseableWrappedIterable<T> getWrappedIterable(final PreparedQuery<T> preparedQuery);\npublic void closeLastIterator() throws Exception;\npublic CloseableIterator<T> iterator(PreparedQuery<T> preparedQuery) throws SQLException;\npublic CloseableIterator<T> iterator(PreparedQuery<T> preparedQuery, int resultFlags) throws SQLException;\npublic GenericRawResults<String[]> queryRaw(String query) throws SQLException;\npublic GenericRawResults<String[]> queryRaw(String query, ArgumentHolder... arguments) throws SQLException;\npublic GenericRawResults<String[]> queryRaw(String query, String... arguments) throws SQLException;\npublic GenericRawResults<GR> queryRaw(String query, RawRowMapper<GR> mapper) throws SQLException;\npublic GenericRawResults<GR> queryRaw(String query, RawRowMapper<GR> mapper, ArgumentHolder... arguments) throws SQLException;\npublic GenericRawResults<GR> queryRaw(String query, RawRowMapper<GR> mapper, String... arguments) throws SQLException;\npublic GenericRawResults<UO> queryRaw(String query, DataType[] columnTypes, RawRowObjectMapper<UO> mapper) throws SQLException;\npublic GenericRawResults<UO> queryRaw(String query, DataType[] columnTypes, RawRowObjectMapper<UO> mapper, ArgumentHolder... arguments) throws SQLException;\npublic GenericRawResults<UO> queryRaw(String query, DataType[] columnTypes, RawRowObjectMapper<UO> mapper, String... arguments) throws SQLException;\npublic GenericRawResults<Object[]> queryRaw(String query, DataType[] columnTypes) throws SQLException;\npublic GenericRawResults<Object[]> queryRaw(String query, DataType[] columnTypes, ArgumentHolder... arguments) throws SQLException;\npublic GenericRawResults<Object[]> queryRaw(String query, DataType[] columnTypes, String... arguments) throws SQLException;\npublic GenericRawResults<UO> queryRaw(String query, DatabaseResultsMapper<UO> mapper) throws SQLException;\npublic GenericRawResults<UO> queryRaw(String query, DatabaseResultsMapper<UO> mapper, ArgumentHolder... arguments) throws SQLException;\npublic GenericRawResults<UO> queryRaw(String query, DatabaseResultsMapper<UO> mapper, String... arguments) throws SQLException;\npublic long queryRawValue(String query) throws SQLException;\npublic long queryRawValue(String query, ArgumentHolder... arguments) throws SQLException;\npublic long queryRawValue(String query, String... arguments) throws SQLException;\npublic int executeRaw(String statement) throws SQLException;\npublic int executeRaw(String statement, ArgumentHolder... arguments) throws SQLException;\npublic int executeRaw(String statement, String... arguments) throws SQLException;\npublic int executeRawNoArgs(String statement) throws SQLException;\npublic int updateRaw(String statement) throws SQLException;\npublic int updateRaw(String statement, ArgumentHolder... arguments) throws SQLException;\npublic int updateRaw(String statement, String... arguments) throws SQLException;\npublic CT callBatchTasks(Callable<CT> callable) throws SQLException;\npublic String objectToString(T data);\npublic boolean objectsEqual(T data1, T data2) throws SQLException;\npublic ID extractId(T data) throws SQLException;\npublic Class<T> getDataClass();\npublic FieldType findForeignFieldType(Class<?> clazz);\npublic boolean isUpdatable();\npublic boolean isTableExists() throws SQLException;\npublic long countOf() throws SQLException;\npublic long countOf(PreparedQuery<T> preparedQuery) throws SQLException;\npublic void assignEmptyForeignCollection(T parent, String fieldName) throws SQLException;\npublic ForeignCollection<FT> getEmptyForeignCollection(String fieldName) throws SQLException;\npublic void setObjectCache(boolean enabled) throws SQLException;\npublic void setObjectCache(ObjectCache objectCache) throws SQLException;\npublic ObjectCache getObjectCache();\npublic void clearObjectCache();\npublic static synchronized void clearAllInternalObjectCaches();\npublic T mapSelectStarRow(DatabaseResults results) throws SQLException;\npublic void notifyChanges();\npublic void registerObserver(DaoObserver observer);\npublic void unregisterObserver(DaoObserver observer);\npublic GenericRowMapper<T> getSelectStarRowMapper() throws SQLException;\npublic RawRowMapper<T> getRawRowMapper();\npublic boolean idExists(ID id) throws SQLException;\npublic DatabaseConnection startThreadConnection() throws SQLException;\npublic void endThreadConnection(DatabaseConnection connection) throws SQLException;\npublic void setAutoCommit(DatabaseConnection connection, boolean autoCommit) throws SQLException;\npublic boolean isAutoCommit(DatabaseConnection connection) throws SQLException;\npublic void commit(DatabaseConnection connection) throws SQLException;\npublic void rollBack(DatabaseConnection connection) throws SQLException;\npublic T createObjectInstance() throws SQLException;\npublic void setObjectFactory(ObjectFactory<T> objectFactory);\npublic DatabaseTableConfig<T> getTableConfig();\npublic TableInfo<T, ID> getTableInfo();\npublic ConnectionSource getConnectionSource();\npublic void setConnectionSource(ConnectionSource connectionSource);\npublic void setTableConfig(DatabaseTableConfig<T> tableConfig);\npublic String getTableName();",
        "public_field": "",
        "Method_statement": "objectsEqual(T data1, T data2)",
        "Method_name": "objectsEqual",
        "Class_declaration": "public  abstract class BaseDaoImpl {\n",
        "constructors": "protected BaseDaoImpl(Class<T> dataClass) throws SQLException {\n    this(null, dataClass, null);\n}protected BaseDaoImpl(ConnectionSource connectionSource, Class<T> dataClass) throws SQLException {\n    this(connectionSource, dataClass, null);\n}protected BaseDaoImpl(ConnectionSource connectionSource, DatabaseTableConfig<T> tableConfig) throws SQLException {\n    this(connectionSource, tableConfig.getDataClass(), tableConfig);\n}private BaseDaoImpl(ConnectionSource connectionSource, Class<T> dataClass, DatabaseTableConfig<T> tableConfig) throws SQLException {\n    this.dataClass = dataClass;\n    this.tableConfig = tableConfig;\n    this.constructor = findNoArgConstructor(dataClass);\n    if (connectionSource != null) {\n        this.connectionSource = connectionSource;\n        initialize();\n    }\n}",
        "all_method_signature": "protected BaseDaoImpl(Class<T> dataClass) throws SQLException;\nprotected BaseDaoImpl(ConnectionSource connectionSource, Class<T> dataClass) throws SQLException;\nprotected BaseDaoImpl(ConnectionSource connectionSource, DatabaseTableConfig<T> tableConfig) throws SQLException;\nprivate BaseDaoImpl(ConnectionSource connectionSource, Class<T> dataClass, DatabaseTableConfig<T> tableConfig) throws SQLException;\npublic void initialize() throws SQLException;\npublic T queryForId(ID id) throws SQLException;\npublic T queryForFirst(PreparedQuery<T> preparedQuery) throws SQLException;\npublic List<T> queryForAll() throws SQLException;\npublic T queryForFirst() throws SQLException;\npublic List<T> queryForEq(String fieldName, Object value) throws SQLException;\npublic QueryBuilder<T, ID> queryBuilder();\npublic UpdateBuilder<T, ID> updateBuilder();\npublic DeleteBuilder<T, ID> deleteBuilder();\npublic List<T> query(PreparedQuery<T> preparedQuery) throws SQLException;\npublic List<T> queryForMatching(T matchObj) throws SQLException;\npublic List<T> queryForMatchingArgs(T matchObj) throws SQLException;\npublic List<T> queryForFieldValues(Map<String, Object> fieldValues) throws SQLException;\npublic List<T> queryForFieldValuesArgs(Map<String, Object> fieldValues) throws SQLException;\npublic T queryForSameId(T data) throws SQLException;\npublic int create(T data) throws SQLException;\npublic int create(final Collection<T> datas) throws SQLException;\npublic synchronized T createIfNotExists(T data) throws SQLException;\npublic synchronized T createIfNotExists(ID key, final Supplier<T> entitySupplier) throws SQLException;\npublic synchronized CreateOrUpdateStatus createOrUpdate(T data) throws SQLException;\npublic int update(T data) throws SQLException;\npublic int updateId(T data, ID newId) throws SQLException;\npublic int update(PreparedUpdate<T> preparedUpdate) throws SQLException;\npublic int refresh(T data) throws SQLException;\npublic int delete(T data) throws SQLException;\npublic int deleteById(ID id) throws SQLException;\npublic int delete(Collection<T> datas) throws SQLException;\npublic int deleteIds(Collection<ID> ids) throws SQLException;\npublic int delete(PreparedDelete<T> preparedDelete) throws SQLException;\npublic CloseableIterator<T> iterator();\npublic CloseableIterator<T> closeableIterator();\npublic CloseableIterator<T> iterator(int resultFlags);\npublic CloseableWrappedIterable<T> getWrappedIterable();\npublic CloseableWrappedIterable<T> getWrappedIterable(final PreparedQuery<T> preparedQuery);\npublic void closeLastIterator() throws Exception;\npublic CloseableIterator<T> iterator(PreparedQuery<T> preparedQuery) throws SQLException;\npublic CloseableIterator<T> iterator(PreparedQuery<T> preparedQuery, int resultFlags) throws SQLException;\npublic GenericRawResults<String[]> queryRaw(String query) throws SQLException;\npublic GenericRawResults<String[]> queryRaw(String query, ArgumentHolder... arguments) throws SQLException;\npublic GenericRawResults<String[]> queryRaw(String query, String... arguments) throws SQLException;\npublic GenericRawResults<GR> queryRaw(String query, RawRowMapper<GR> mapper) throws SQLException;\npublic GenericRawResults<GR> queryRaw(String query, RawRowMapper<GR> mapper, ArgumentHolder... arguments) throws SQLException;\npublic GenericRawResults<GR> queryRaw(String query, RawRowMapper<GR> mapper, String... arguments) throws SQLException;\npublic GenericRawResults<UO> queryRaw(String query, DataType[] columnTypes, RawRowObjectMapper<UO> mapper) throws SQLException;\npublic GenericRawResults<UO> queryRaw(String query, DataType[] columnTypes, RawRowObjectMapper<UO> mapper, ArgumentHolder... arguments) throws SQLException;\npublic GenericRawResults<UO> queryRaw(String query, DataType[] columnTypes, RawRowObjectMapper<UO> mapper, String... arguments) throws SQLException;\npublic GenericRawResults<Object[]> queryRaw(String query, DataType[] columnTypes) throws SQLException;\npublic GenericRawResults<Object[]> queryRaw(String query, DataType[] columnTypes, ArgumentHolder... arguments) throws SQLException;\npublic GenericRawResults<Object[]> queryRaw(String query, DataType[] columnTypes, String... arguments) throws SQLException;\npublic GenericRawResults<UO> queryRaw(String query, DatabaseResultsMapper<UO> mapper) throws SQLException;\npublic GenericRawResults<UO> queryRaw(String query, DatabaseResultsMapper<UO> mapper, ArgumentHolder... arguments) throws SQLException;\npublic GenericRawResults<UO> queryRaw(String query, DatabaseResultsMapper<UO> mapper, String... arguments) throws SQLException;\npublic long queryRawValue(String query) throws SQLException;\npublic long queryRawValue(String query, ArgumentHolder... arguments) throws SQLException;\npublic long queryRawValue(String query, String... arguments) throws SQLException;\npublic int executeRaw(String statement) throws SQLException;\npublic int executeRaw(String statement, ArgumentHolder... arguments) throws SQLException;\npublic int executeRaw(String statement, String... arguments) throws SQLException;\npublic int executeRawNoArgs(String statement) throws SQLException;\npublic int updateRaw(String statement) throws SQLException;\npublic int updateRaw(String statement, ArgumentHolder... arguments) throws SQLException;\npublic int updateRaw(String statement, String... arguments) throws SQLException;\npublic CT callBatchTasks(Callable<CT> callable) throws SQLException;\npublic String objectToString(T data);\npublic boolean objectsEqual(T data1, T data2) throws SQLException;\npublic ID extractId(T data) throws SQLException;\npublic Class<T> getDataClass();\npublic FieldType findForeignFieldType(Class<?> clazz);\npublic boolean isUpdatable();\npublic boolean isTableExists() throws SQLException;\npublic long countOf() throws SQLException;\npublic long countOf(PreparedQuery<T> preparedQuery) throws SQLException;\npublic void assignEmptyForeignCollection(T parent, String fieldName) throws SQLException;\npublic ForeignCollection<FT> getEmptyForeignCollection(String fieldName) throws SQLException;\npublic void setObjectCache(boolean enabled) throws SQLException;\npublic void setObjectCache(ObjectCache objectCache) throws SQLException;\npublic ObjectCache getObjectCache();\npublic void clearObjectCache();\npublic static synchronized void clearAllInternalObjectCaches();\npublic T mapSelectStarRow(DatabaseResults results) throws SQLException;\npublic void notifyChanges();\npublic void registerObserver(DaoObserver observer);\npublic void unregisterObserver(DaoObserver observer);\npublic GenericRowMapper<T> getSelectStarRowMapper() throws SQLException;\npublic RawRowMapper<T> getRawRowMapper();\npublic boolean idExists(ID id) throws SQLException;\npublic DatabaseConnection startThreadConnection() throws SQLException;\npublic void endThreadConnection(DatabaseConnection connection) throws SQLException;\npublic void setAutoCommit(DatabaseConnection connection, boolean autoCommit) throws SQLException;\npublic boolean isAutoCommit(DatabaseConnection connection) throws SQLException;\npublic void commit(DatabaseConnection connection) throws SQLException;\npublic void rollBack(DatabaseConnection connection) throws SQLException;\npublic T createObjectInstance() throws SQLException;\npublic void setObjectFactory(ObjectFactory<T> objectFactory);\npublic DatabaseTableConfig<T> getTableConfig();\npublic TableInfo<T, ID> getTableInfo();\npublic ConnectionSource getConnectionSource();\npublic void setConnectionSource(ConnectionSource connectionSource);\npublic void setTableConfig(DatabaseTableConfig<T> tableConfig);\npublic String getTableName();\n static Dao<T, ID> createDao(ConnectionSource connectionSource, Class<T> clazz) throws SQLException;\n static Dao<T, ID> createDao(ConnectionSource connectionSource, DatabaseTableConfig<T> tableConfig) throws SQLException;\nprotected void checkForInitialized();\nprivate ForeignCollection<FT> makeEmptyForeignCollection(T parent, String fieldName) throws SQLException;\n CloseableIterator<T> createIterator(int resultFlags);\n CloseableIterator<T> createIterator(PreparedQuery<T> preparedQuery, int resultFlags) throws SQLException;\nprivate List<T> queryForMatching(T matchObj, boolean useArgs) throws SQLException;\nprivate List<T> queryForFieldValues(Map<String, Object> fieldValues, boolean useArgs) throws SQLException;\nprivate Constructor<T> findNoArgConstructor(Class<T> dataClass);\nprivate void wireNewInstance(T instance);",
        "Class_name": "BaseDaoImpl",
        "project_path": "j256_ormlite-core###j256_ormlite-core/src/main/java/com/j256/ormlite/dao/BaseDaoImpl###objectsEqual",
        "Parameter_num": "2",
        "all_Import_statements": "import java.lang.reflect.Constructor;\n\nimport java.sql.SQLException;\n\nimport java.util.ArrayList;\n\nimport java.util.Collection;\n\nimport java.util.Collections;\n\nimport java.util.Iterator;\n\nimport java.util.List;\n\nimport java.util.Map;\n\nimport java.util.concurrent.Callable;\n\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport java.util.concurrent.ConcurrentMap;\n\nimport com.j256.ormlite.db.DatabaseType;\n\nimport com.j256.ormlite.field.DataType;\n\nimport com.j256.ormlite.field.DatabaseField;\n\nimport com.j256.ormlite.field.FieldType;\n\nimport com.j256.ormlite.misc.BaseDaoEnabled;\n\nimport com.j256.ormlite.misc.Supplier;\n\nimport com.j256.ormlite.stmt.ArgumentHolder;\n\nimport com.j256.ormlite.stmt.DeleteBuilder;\n\nimport com.j256.ormlite.stmt.GenericRowMapper;\n\nimport com.j256.ormlite.stmt.PreparedDelete;\n\nimport com.j256.ormlite.stmt.PreparedQuery;\n\nimport com.j256.ormlite.stmt.PreparedUpdate;\n\nimport com.j256.ormlite.stmt.QueryBuilder;\n\nimport com.j256.ormlite.stmt.SelectArg;\n\nimport com.j256.ormlite.stmt.SelectIterator;\n\nimport com.j256.ormlite.stmt.StatementBuilder.StatementType;\n\nimport com.j256.ormlite.stmt.StatementExecutor;\n\nimport com.j256.ormlite.stmt.UpdateBuilder;\n\nimport com.j256.ormlite.stmt.Where;\n\nimport com.j256.ormlite.support.ConnectionSource;\n\nimport com.j256.ormlite.support.DatabaseConnection;\n\nimport com.j256.ormlite.support.DatabaseResults;\n\nimport com.j256.ormlite.table.DatabaseTableConfig;\n\nimport com.j256.ormlite.table.ObjectFactory;\n\nimport com.j256.ormlite.table.TableInfo;\n",
        "comment": "",
        "packageName": "com.j256.ormlite.dao",
        "method_signature": "public boolean objectsEqual(T data1, T data2) throws SQLException;",
        "Junit_version": "4",
        "returnType": "boolean"
    },
    {
        "Method_body": "@GwtIncompatible(\"incompatible method\")\npublic static boolean isValidAnnotationMemberType(Class<?> type) {\n    if (type == null) {\n        return false;\n    }\n    if (type.isArray()) {\n        type = type.getComponentType();\n    }\n    return type.isPrimitive() || type.isEnum() || type.isAnnotation() || String.class.equals(type) || Class.class.equals(type);\n}",
        "all_field_declaration": "/**\n * A style that prints annotations as recommended.\n */\nprivate static final ToStringStyle TO_STRING_STYLE = new ToStringStyle() {\n\n    /**\n     * Serialization version\n     */\n    private static final long serialVersionUID = 1L;\n\n    {\n        setDefaultFullDetail(true);\n        setArrayContentDetail(true);\n        setUseClassName(true);\n        setUseShortClassName(true);\n        setUseIdentityHashCode(false);\n        setContentStart(\"(\");\n        setContentEnd(\")\");\n        setFieldSeparator(\", \");\n        setArrayStart(\"[\");\n        setArrayEnd(\"]\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    @GwtIncompatible(\"incompatible method\")\n    protected String getShortClassName(final java.lang.Class<?> cls) {\n        Class<? extends Annotation> annotationType = null;\n        for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {\n            if (Annotation.class.isAssignableFrom(iface)) {\n                // OK because we just checked the assignability\n                @SuppressWarnings(\"unchecked\")\n                final Class<? extends Annotation> found = (Class<? extends Annotation>) iface;\n                annotationType = found;\n                break;\n            }\n        }\n        return new StringBuilder(annotationType == null ? StringUtils.EMPTY : annotationType.getName()).insert(0, '@').toString();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    @GwtIncompatible(\"incompatible method\")\n    protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) {\n        if (value instanceof Annotation) {\n            value = AnnotationUtils.toString((Annotation) value);\n        }\n        super.appendDetail(buffer, fieldName, value);\n    }\n};",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "3",
        "Filed": "",
        "Parameter_type": "Class<?>",
        "Import_statements": "import java.lang.annotation.Annotation;\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
        "public_method_signature": "public AnnotationUtils();\npublic static boolean equals(final Annotation a1, final Annotation a2);\npublic static int hashCode(final Annotation a);\npublic static String toString(final Annotation a);\npublic static boolean isValidAnnotationMemberType(Class<?> type);",
        "public_field": "",
        "Method_statement": "isValidAnnotationMemberType(Class<?> type)",
        "Method_name": "isValidAnnotationMemberType",
        "Class_declaration": "public class AnnotationUtils {\n",
        "constructors": "public AnnotationUtils() {\n}",
        "all_method_signature": "public AnnotationUtils();\npublic static boolean equals(final Annotation a1, final Annotation a2);\npublic static int hashCode(final Annotation a);\npublic static String toString(final Annotation a);\npublic static boolean isValidAnnotationMemberType(Class<?> type);\nprivate static int hashMember(final String name, final Object value);\nprivate static boolean memberEquals(final Class<?> type, final Object o1, final Object o2);\nprivate static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2);\nprivate static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2);\nprivate static int arrayMemberHash(final Class<?> componentType, final Object o);",
        "Class_name": "AnnotationUtils",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/AnnotationUtils###isValidAnnotationMemberType",
        "Parameter_num": "1",
        "all_Import_statements": "import java.lang.annotation.Annotation;\n\nimport java.lang.reflect.InvocationTargetException;\n\nimport java.lang.reflect.Method;\n\nimport java.util.Arrays;\n\nimport org.apache.commons.lang3.builder.ToStringBuilder;\n\nimport org.apache.commons.lang3.builder.ToStringStyle;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
        "comment": "\n     * <p>Checks if the specified type is permitted as an annotation member.</p>\n     *\n     * <p>The Java language specification only permits certain types to be used\n     * in annotations. These include {@link String}, {@link Class}, primitive\n     * types, {@link Annotation}, {@link Enum}, and single-dimensional arrays of\n     * these types.</p>\n     *\n     * @param type the type to check, {@code null}\n     * @return {@code true} if the type is a valid type to use in an annotation\n     ",
        "packageName": "org.apache.commons.lang3",
        "method_signature": "public static boolean isValidAnnotationMemberType(Class<?> type);",
        "Junit_version": "4",
        "returnType": "boolean"
    },
    {
        "Method_body": "@GwtIncompatible(\"incompatible method\")\npublic static String toString(final Annotation a) {\n    final ToStringBuilder builder = new ToStringBuilder(a, TO_STRING_STYLE);\n    for (final Method m : a.annotationType().getDeclaredMethods()) {\n        if (m.getParameterTypes().length > 0) {\n            continue;\n        }\n        try {\n            builder.append(m.getName(), m.invoke(a));\n        } catch (final RuntimeException ex) {\n            throw ex;\n        } catch (final Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n    return builder.build();\n}",
        "all_field_declaration": "/**\n * A style that prints annotations as recommended.\n */\nprivate static final ToStringStyle TO_STRING_STYLE = new ToStringStyle() {\n\n    /**\n     * Serialization version\n     */\n    private static final long serialVersionUID = 1L;\n\n    {\n        setDefaultFullDetail(true);\n        setArrayContentDetail(true);\n        setUseClassName(true);\n        setUseShortClassName(true);\n        setUseIdentityHashCode(false);\n        setContentStart(\"(\");\n        setContentEnd(\")\");\n        setFieldSeparator(\", \");\n        setArrayStart(\"[\");\n        setArrayEnd(\"]\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    @GwtIncompatible(\"incompatible method\")\n    protected String getShortClassName(final java.lang.Class<?> cls) {\n        Class<? extends Annotation> annotationType = null;\n        for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {\n            if (Annotation.class.isAssignableFrom(iface)) {\n                // OK because we just checked the assignability\n                @SuppressWarnings(\"unchecked\")\n                final Class<? extends Annotation> found = (Class<? extends Annotation>) iface;\n                annotationType = found;\n                break;\n            }\n        }\n        return new StringBuilder(annotationType == null ? StringUtils.EMPTY : annotationType.getName()).insert(0, '@').toString();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    @GwtIncompatible(\"incompatible method\")\n    protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) {\n        if (value instanceof Annotation) {\n            value = AnnotationUtils.toString((Annotation) value);\n        }\n        super.appendDetail(buffer, fieldName, value);\n    }\n};",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "3",
        "Filed": "private static final ToStringStyle TO_STRING_STYLE = new ToStringStyle() {\n\n    private static final long serialVersionUID = 1L;\n\n    {\n        setDefaultFullDetail(true);\n        setArrayContentDetail(true);\n        setUseClassName(true);\n        setUseShortClassName(true);\n        setUseIdentityHashCode(false);\n        setContentStart(\"(\");\n        setContentEnd(\")\");\n        setFieldSeparator(\", \");\n        setArrayStart(\"[\");\n        setArrayEnd(\"]\");\n    }\n\n    @Override\n    @GwtIncompatible(\"incompatible method\")\n    protected String getShortClassName(final java.lang.Class<?> cls) {\n        Class<? extends Annotation> annotationType = null;\n        for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {\n            if (Annotation.class.isAssignableFrom(iface)) {\n                @SuppressWarnings(\"unchecked\")\n                final Class<? extends Annotation> found = (Class<? extends Annotation>) iface;\n                annotationType = found;\n                break;\n            }\n        }\n        return new StringBuilder(annotationType == null ? StringUtils.EMPTY : annotationType.getName()).insert(0, '@').toString();\n    }\n\n    @Override\n    @GwtIncompatible(\"incompatible method\")\n    protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) {\n        if (value instanceof Annotation) {\n            value = AnnotationUtils.toString((Annotation) value);\n        }\n        super.appendDetail(buffer, fieldName, value);\n    }\n};",
        "Parameter_type": "Annotation",
        "Import_statements": "import java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport org.apache.commons.lang3.builder.ToStringBuilder;\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
        "public_method_signature": "public AnnotationUtils();\npublic static boolean equals(final Annotation a1, final Annotation a2);\npublic static int hashCode(final Annotation a);\npublic static String toString(final Annotation a);\npublic static boolean isValidAnnotationMemberType(Class<?> type);",
        "public_field": "",
        "Method_statement": "toString(final Annotation a)",
        "Method_name": "toString",
        "Class_declaration": "public class AnnotationUtils {\n",
        "constructors": "public AnnotationUtils() {\n}",
        "all_method_signature": "public AnnotationUtils();\npublic static boolean equals(final Annotation a1, final Annotation a2);\npublic static int hashCode(final Annotation a);\npublic static String toString(final Annotation a);\npublic static boolean isValidAnnotationMemberType(Class<?> type);\nprivate static int hashMember(final String name, final Object value);\nprivate static boolean memberEquals(final Class<?> type, final Object o1, final Object o2);\nprivate static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2);\nprivate static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2);\nprivate static int arrayMemberHash(final Class<?> componentType, final Object o);",
        "Class_name": "AnnotationUtils",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/AnnotationUtils###toString",
        "Parameter_num": "1",
        "all_Import_statements": "import java.lang.annotation.Annotation;\n\nimport java.lang.reflect.InvocationTargetException;\n\nimport java.lang.reflect.Method;\n\nimport java.util.Arrays;\n\nimport org.apache.commons.lang3.builder.ToStringBuilder;\n\nimport org.apache.commons.lang3.builder.ToStringStyle;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
        "comment": "\n     * <p>Generate a string representation of an Annotation, as suggested by\n     * {@link Annotation#toString()}.</p>\n     *\n     * @param a the annotation of which a string representation is desired\n     * @return the standard string representation of an annotation, not\n     * {@code null}\n     ",
        "packageName": "org.apache.commons.lang3",
        "method_signature": "public static String toString(final Annotation a);",
        "Junit_version": "4",
        "returnType": "String"
    },
    {
        "Method_body": "public static boolean[] clone(final boolean[] array) {\n    if (array == null) {\n        return null;\n    }\n    final boolean[] arrayClone = new boolean[array.length];\n    System.arraycopy(array, 0, arrayClone, 0, array.length);\n    return arrayClone;\n}",
        "all_field_declaration": "/**\n * An empty immutable {@code Object} array.\n */\npublic static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];\n/**\n * An empty immutable {@code Class} array.\n */\npublic static final Class<?>[] EMPTY_CLASS_ARRAY = new Class[0];\n/**\n * An empty immutable {@code String} array.\n */\npublic static final String[] EMPTY_STRING_ARRAY = new String[0];\n/**\n * An empty immutable {@code long} array.\n */\npublic static final long[] EMPTY_LONG_ARRAY = new long[0];\n/**\n * An empty immutable {@code Long} array.\n */\npublic static final Long[] EMPTY_LONG_OBJECT_ARRAY = new Long[0];\n/**\n * An empty immutable {@code int} array.\n */\npublic static final int[] EMPTY_INT_ARRAY = new int[0];\n/**\n * An empty immutable {@code Integer} array.\n */\npublic static final Integer[] EMPTY_INTEGER_OBJECT_ARRAY = new Integer[0];\n/**\n * An empty immutable {@code short} array.\n */\npublic static final short[] EMPTY_SHORT_ARRAY = new short[0];\n/**\n * An empty immutable {@code Short} array.\n */\npublic static final Short[] EMPTY_SHORT_OBJECT_ARRAY = new Short[0];\n/**\n * An empty immutable {@code byte} array.\n */\npublic static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\n/**\n * An empty immutable {@code Byte} array.\n */\npublic static final Byte[] EMPTY_BYTE_OBJECT_ARRAY = new Byte[0];\n/**\n * An empty immutable {@code double} array.\n */\npublic static final double[] EMPTY_DOUBLE_ARRAY = new double[0];\n/**\n * An empty immutable {@code Double} array.\n */\npublic static final Double[] EMPTY_DOUBLE_OBJECT_ARRAY = new Double[0];\n/**\n * An empty immutable {@code float} array.\n */\npublic static final float[] EMPTY_FLOAT_ARRAY = new float[0];\n/**\n * An empty immutable {@code Float} array.\n */\npublic static final Float[] EMPTY_FLOAT_OBJECT_ARRAY = new Float[0];\n/**\n * An empty immutable {@code boolean} array.\n */\npublic static final boolean[] EMPTY_BOOLEAN_ARRAY = new boolean[0];\n/**\n * An empty immutable {@code Boolean} array.\n */\npublic static final Boolean[] EMPTY_BOOLEAN_OBJECT_ARRAY = new Boolean[0];\n/**\n * An empty immutable {@code char} array.\n */\npublic static final char[] EMPTY_CHAR_ARRAY = new char[0];\n/**\n * An empty immutable {@code Character} array.\n */\npublic static final Character[] EMPTY_CHARACTER_OBJECT_ARRAY = new Character[0];\n/**\n * The index value when an element is not found in a list or array: {@code -1}.\n * This value is returned by methods in this class and can also be used in comparisons with values returned by\n * various method from {@link java.util.List}.\n */\npublic static final int INDEX_NOT_FOUND = -1;",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "4",
        "Filed": "",
        "Parameter_type": "boolean[]",
        "Import_statements": "",
        "public_method_signature": "public ArrayUtils();\npublic static String toString(final Object array);\npublic static String toString(final Object array, final String stringIfNull);\npublic static int hashCode(final Object array);\npublic static boolean isEquals(final Object array1, final Object array2);\npublic static Map<Object, Object> toMap(final Object[] array);\npublic static T[] toArray(final T... items);\npublic static T[] clone(final T[] array);\npublic static long[] clone(final long[] array);\npublic static int[] clone(final int[] array);\npublic static short[] clone(final short[] array);\npublic static char[] clone(final char[] array);\npublic static byte[] clone(final byte[] array);\npublic static double[] clone(final double[] array);\npublic static float[] clone(final float[] array);\npublic static boolean[] clone(final boolean[] array);\npublic static T[] nullToEmpty(final T[] array, final Class<T[]> type);\npublic static Object[] nullToEmpty(final Object[] array);\npublic static Class<?>[] nullToEmpty(final Class<?>[] array);\npublic static String[] nullToEmpty(final String[] array);\npublic static long[] nullToEmpty(final long[] array);\npublic static int[] nullToEmpty(final int[] array);\npublic static short[] nullToEmpty(final short[] array);\npublic static char[] nullToEmpty(final char[] array);\npublic static byte[] nullToEmpty(final byte[] array);\npublic static double[] nullToEmpty(final double[] array);\npublic static float[] nullToEmpty(final float[] array);\npublic static boolean[] nullToEmpty(final boolean[] array);\npublic static Long[] nullToEmpty(final Long[] array);\npublic static Integer[] nullToEmpty(final Integer[] array);\npublic static Short[] nullToEmpty(final Short[] array);\npublic static Character[] nullToEmpty(final Character[] array);\npublic static Byte[] nullToEmpty(final Byte[] array);\npublic static Double[] nullToEmpty(final Double[] array);\npublic static Float[] nullToEmpty(final Float[] array);\npublic static Boolean[] nullToEmpty(final Boolean[] array);\npublic static T[] subarray(final T[] array, int startIndexInclusive, int endIndexExclusive);\npublic static long[] subarray(final long[] array, int startIndexInclusive, int endIndexExclusive);\npublic static int[] subarray(final int[] array, int startIndexInclusive, int endIndexExclusive);\npublic static short[] subarray(final short[] array, int startIndexInclusive, int endIndexExclusive);\npublic static char[] subarray(final char[] array, int startIndexInclusive, int endIndexExclusive);\npublic static byte[] subarray(final byte[] array, int startIndexInclusive, int endIndexExclusive);\npublic static double[] subarray(final double[] array, int startIndexInclusive, int endIndexExclusive);\npublic static float[] subarray(final float[] array, int startIndexInclusive, int endIndexExclusive);\npublic static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive);\npublic static boolean isSameLength(final Object[] array1, final Object[] array2);\npublic static boolean isSameLength(final long[] array1, final long[] array2);\npublic static boolean isSameLength(final int[] array1, final int[] array2);\npublic static boolean isSameLength(final short[] array1, final short[] array2);\npublic static boolean isSameLength(final char[] array1, final char[] array2);\npublic static boolean isSameLength(final byte[] array1, final byte[] array2);\npublic static boolean isSameLength(final double[] array1, final double[] array2);\npublic static boolean isSameLength(final float[] array1, final float[] array2);\npublic static boolean isSameLength(final boolean[] array1, final boolean[] array2);\npublic static int getLength(final Object array);\npublic static boolean isSameType(final Object array1, final Object array2);\npublic static void reverse(final Object[] array);\npublic static void reverse(final long[] array);\npublic static void reverse(final int[] array);\npublic static void reverse(final short[] array);\npublic static void reverse(final char[] array);\npublic static void reverse(final byte[] array);\npublic static void reverse(final double[] array);\npublic static void reverse(final float[] array);\npublic static void reverse(final boolean[] array);\npublic static void reverse(final boolean[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final byte[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final char[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final double[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final float[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final int[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final long[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final Object[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final short[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void swap(final Object[] array, final int offset1, final int offset2);\npublic static void swap(final long[] array, final int offset1, final int offset2);\npublic static void swap(final int[] array, final int offset1, final int offset2);\npublic static void swap(final short[] array, final int offset1, final int offset2);\npublic static void swap(final char[] array, final int offset1, final int offset2);\npublic static void swap(final byte[] array, final int offset1, final int offset2);\npublic static void swap(final double[] array, final int offset1, final int offset2);\npublic static void swap(final float[] array, final int offset1, final int offset2);\npublic static void swap(final boolean[] array, final int offset1, final int offset2);\npublic static void swap(final boolean[] array, int offset1, int offset2, int len);\npublic static void swap(final byte[] array, int offset1, int offset2, int len);\npublic static void swap(final char[] array, int offset1, int offset2, int len);\npublic static void swap(final double[] array, int offset1, int offset2, int len);\npublic static void swap(final float[] array, int offset1, int offset2, int len);\npublic static void swap(final int[] array, int offset1, int offset2, int len);\npublic static void swap(final long[] array, int offset1, int offset2, int len);\npublic static void swap(final Object[] array, int offset1, int offset2, int len);\npublic static void swap(final short[] array, int offset1, int offset2, int len);\npublic static void shift(final Object[] array, final int offset);\npublic static void shift(final long[] array, final int offset);\npublic static void shift(final int[] array, final int offset);\npublic static void shift(final short[] array, final int offset);\npublic static void shift(final char[] array, final int offset);\npublic static void shift(final byte[] array, final int offset);\npublic static void shift(final double[] array, final int offset);\npublic static void shift(final float[] array, final int offset);\npublic static void shift(final boolean[] array, final int offset);\npublic static void shift(final boolean[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final byte[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final char[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final double[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final float[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final int[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final long[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final Object[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final short[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static int indexOf(final Object[] array, final Object objectToFind);\npublic static int indexOf(final Object[] array, final Object objectToFind, int startIndex);\npublic static int lastIndexOf(final Object[] array, final Object objectToFind);\npublic static int lastIndexOf(final Object[] array, final Object objectToFind, int startIndex);\npublic static boolean contains(final Object[] array, final Object objectToFind);\npublic static int indexOf(final long[] array, final long valueToFind);\npublic static int indexOf(final long[] array, final long valueToFind, int startIndex);\npublic static int lastIndexOf(final long[] array, final long valueToFind);\npublic static int lastIndexOf(final long[] array, final long valueToFind, int startIndex);\npublic static boolean contains(final long[] array, final long valueToFind);\npublic static int indexOf(final int[] array, final int valueToFind);\npublic static int indexOf(final int[] array, final int valueToFind, int startIndex);\npublic static int lastIndexOf(final int[] array, final int valueToFind);\npublic static int lastIndexOf(final int[] array, final int valueToFind, int startIndex);\npublic static boolean contains(final int[] array, final int valueToFind);\npublic static int indexOf(final short[] array, final short valueToFind);\npublic static int indexOf(final short[] array, final short valueToFind, int startIndex);\npublic static int lastIndexOf(final short[] array, final short valueToFind);\npublic static int lastIndexOf(final short[] array, final short valueToFind, int startIndex);\npublic static boolean contains(final short[] array, final short valueToFind);\npublic static int indexOf(final char[] array, final char valueToFind);\npublic static int indexOf(final char[] array, final char valueToFind, int startIndex);\npublic static int lastIndexOf(final char[] array, final char valueToFind);\npublic static int lastIndexOf(final char[] array, final char valueToFind, int startIndex);\npublic static boolean contains(final char[] array, final char valueToFind);\npublic static int indexOf(final byte[] array, final byte valueToFind);\npublic static int indexOf(final byte[] array, final byte valueToFind, int startIndex);\npublic static int lastIndexOf(final byte[] array, final byte valueToFind);\npublic static int lastIndexOf(final byte[] array, final byte valueToFind, int startIndex);\npublic static boolean contains(final byte[] array, final byte valueToFind);\npublic static int indexOf(final double[] array, final double valueToFind);\npublic static int indexOf(final double[] array, final double valueToFind, final double tolerance);\npublic static int indexOf(final double[] array, final double valueToFind, int startIndex);\npublic static int indexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance);\npublic static int lastIndexOf(final double[] array, final double valueToFind);\npublic static int lastIndexOf(final double[] array, final double valueToFind, final double tolerance);\npublic static int lastIndexOf(final double[] array, final double valueToFind, int startIndex);\npublic static int lastIndexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance);\npublic static boolean contains(final double[] array, final double valueToFind);\npublic static boolean contains(final double[] array, final double valueToFind, final double tolerance);\npublic static int indexOf(final float[] array, final float valueToFind);\npublic static int indexOf(final float[] array, final float valueToFind, int startIndex);\npublic static int lastIndexOf(final float[] array, final float valueToFind);\npublic static int lastIndexOf(final float[] array, final float valueToFind, int startIndex);\npublic static boolean contains(final float[] array, final float valueToFind);\npublic static int indexOf(final boolean[] array, final boolean valueToFind);\npublic static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex);\npublic static int lastIndexOf(final boolean[] array, final boolean valueToFind);\npublic static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex);\npublic static boolean contains(final boolean[] array, final boolean valueToFind);\npublic static char[] toPrimitive(final Character[] array);\npublic static char[] toPrimitive(final Character[] array, final char valueForNull);\npublic static Character[] toObject(final char[] array);\npublic static long[] toPrimitive(final Long[] array);\npublic static long[] toPrimitive(final Long[] array, final long valueForNull);\npublic static Long[] toObject(final long[] array);\npublic static int[] toPrimitive(final Integer[] array);\npublic static int[] toPrimitive(final Integer[] array, final int valueForNull);\npublic static Integer[] toObject(final int[] array);\npublic static short[] toPrimitive(final Short[] array);\npublic static short[] toPrimitive(final Short[] array, final short valueForNull);\npublic static Short[] toObject(final short[] array);\npublic static byte[] toPrimitive(final Byte[] array);\npublic static byte[] toPrimitive(final Byte[] array, final byte valueForNull);\npublic static Byte[] toObject(final byte[] array);\npublic static double[] toPrimitive(final Double[] array);\npublic static double[] toPrimitive(final Double[] array, final double valueForNull);\npublic static Double[] toObject(final double[] array);\npublic static float[] toPrimitive(final Float[] array);\npublic static float[] toPrimitive(final Float[] array, final float valueForNull);\npublic static Float[] toObject(final float[] array);\npublic static Object toPrimitive(final Object array);\npublic static boolean[] toPrimitive(final Boolean[] array);\npublic static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull);\npublic static Boolean[] toObject(final boolean[] array);\npublic static boolean isEmpty(final Object[] array);\npublic static boolean isEmpty(final long[] array);\npublic static boolean isEmpty(final int[] array);\npublic static boolean isEmpty(final short[] array);\npublic static boolean isEmpty(final char[] array);\npublic static boolean isEmpty(final byte[] array);\npublic static boolean isEmpty(final double[] array);\npublic static boolean isEmpty(final float[] array);\npublic static boolean isEmpty(final boolean[] array);\npublic static boolean isNotEmpty(final T[] array);\npublic static boolean isNotEmpty(final long[] array);\npublic static boolean isNotEmpty(final int[] array);\npublic static boolean isNotEmpty(final short[] array);\npublic static boolean isNotEmpty(final char[] array);\npublic static boolean isNotEmpty(final byte[] array);\npublic static boolean isNotEmpty(final double[] array);\npublic static boolean isNotEmpty(final float[] array);\npublic static boolean isNotEmpty(final boolean[] array);\npublic static T[] addAll(final T[] array1, final T... array2);\npublic static boolean[] addAll(final boolean[] array1, final boolean... array2);\npublic static char[] addAll(final char[] array1, final char... array2);\npublic static byte[] addAll(final byte[] array1, final byte... array2);\npublic static short[] addAll(final short[] array1, final short... array2);\npublic static int[] addAll(final int[] array1, final int... array2);\npublic static long[] addAll(final long[] array1, final long... array2);\npublic static float[] addAll(final float[] array1, final float... array2);\npublic static double[] addAll(final double[] array1, final double... array2);\npublic static T[] add(final T[] array, final T element);\npublic static boolean[] add(final boolean[] array, final boolean element);\npublic static byte[] add(final byte[] array, final byte element);\npublic static char[] add(final char[] array, final char element);\npublic static double[] add(final double[] array, final double element);\npublic static float[] add(final float[] array, final float element);\npublic static int[] add(final int[] array, final int element);\npublic static long[] add(final long[] array, final long element);\npublic static short[] add(final short[] array, final short element);\npublic static T[] add(final T[] array, final int index, final T element);\npublic static boolean[] add(final boolean[] array, final int index, final boolean element);\npublic static char[] add(final char[] array, final int index, final char element);\npublic static byte[] add(final byte[] array, final int index, final byte element);\npublic static short[] add(final short[] array, final int index, final short element);\npublic static int[] add(final int[] array, final int index, final int element);\npublic static long[] add(final long[] array, final int index, final long element);\npublic static float[] add(final float[] array, final int index, final float element);\npublic static double[] add(final double[] array, final int index, final double element);\npublic static T[] remove(final T[] array, final int index);\npublic static T[] removeElement(final T[] array, final Object element);\npublic static boolean[] remove(final boolean[] array, final int index);\npublic static boolean[] removeElement(final boolean[] array, final boolean element);\npublic static byte[] remove(final byte[] array, final int index);\npublic static byte[] removeElement(final byte[] array, final byte element);\npublic static char[] remove(final char[] array, final int index);\npublic static char[] removeElement(final char[] array, final char element);\npublic static double[] remove(final double[] array, final int index);\npublic static double[] removeElement(final double[] array, final double element);\npublic static float[] remove(final float[] array, final int index);\npublic static float[] removeElement(final float[] array, final float element);\npublic static int[] remove(final int[] array, final int index);\npublic static int[] removeElement(final int[] array, final int element);\npublic static long[] remove(final long[] array, final int index);\npublic static long[] removeElement(final long[] array, final long element);\npublic static short[] remove(final short[] array, final int index);\npublic static short[] removeElement(final short[] array, final short element);\npublic static T[] removeAll(final T[] array, final int... indices);\npublic static T[] removeElements(final T[] array, final T... values);\npublic static byte[] removeAll(final byte[] array, final int... indices);\npublic static byte[] removeElements(final byte[] array, final byte... values);\npublic static short[] removeAll(final short[] array, final int... indices);\npublic static short[] removeElements(final short[] array, final short... values);\npublic static int[] removeAll(final int[] array, final int... indices);\npublic static int[] removeElements(final int[] array, final int... values);\npublic static char[] removeAll(final char[] array, final int... indices);\npublic static char[] removeElements(final char[] array, final char... values);\npublic static long[] removeAll(final long[] array, final int... indices);\npublic static long[] removeElements(final long[] array, final long... values);\npublic static float[] removeAll(final float[] array, final int... indices);\npublic static float[] removeElements(final float[] array, final float... values);\npublic static double[] removeAll(final double[] array, final int... indices);\npublic static double[] removeElements(final double[] array, final double... values);\npublic static boolean[] removeAll(final boolean[] array, final int... indices);\npublic static boolean[] removeElements(final boolean[] array, final boolean... values);\npublic static boolean isSorted(final T[] array);\npublic static boolean isSorted(final T[] array, final Comparator<T> comparator);\npublic static boolean isSorted(final int[] array);\npublic static boolean isSorted(final long[] array);\npublic static boolean isSorted(final short[] array);\npublic static boolean isSorted(final double[] array);\npublic static boolean isSorted(final float[] array);\npublic static boolean isSorted(final byte[] array);\npublic static boolean isSorted(final char[] array);\npublic static boolean isSorted(final boolean[] array);\npublic static boolean[] removeAllOccurences(final boolean[] array, final boolean element);\npublic static char[] removeAllOccurences(final char[] array, final char element);\npublic static byte[] removeAllOccurences(final byte[] array, final byte element);\npublic static short[] removeAllOccurences(final short[] array, final short element);\npublic static int[] removeAllOccurences(final int[] array, final int element);\npublic static long[] removeAllOccurences(final long[] array, final long element);\npublic static float[] removeAllOccurences(final float[] array, final float element);\npublic static double[] removeAllOccurences(final double[] array, final double element);\npublic static T[] removeAllOccurences(final T[] array, final T element);\npublic static String[] toStringArray(final Object[] array);\npublic static String[] toStringArray(final Object[] array, final String valueForNullElements);\npublic static boolean[] insert(final int index, final boolean[] array, final boolean... values);\npublic static byte[] insert(final int index, final byte[] array, final byte... values);\npublic static char[] insert(final int index, final char[] array, final char... values);\npublic static double[] insert(final int index, final double[] array, final double... values);\npublic static float[] insert(final int index, final float[] array, final float... values);\npublic static int[] insert(final int index, final int[] array, final int... values);\npublic static long[] insert(final int index, final long[] array, final long... values);\npublic static short[] insert(final int index, final short[] array, final short... values);\npublic static T[] insert(final int index, final T[] array, final T... values);\npublic static void shuffle(final Object[] array);\npublic static void shuffle(final Object[] array, final Random random);\npublic static void shuffle(final boolean[] array);\npublic static void shuffle(final boolean[] array, final Random random);\npublic static void shuffle(final byte[] array);\npublic static void shuffle(final byte[] array, final Random random);\npublic static void shuffle(final char[] array);\npublic static void shuffle(final char[] array, final Random random);\npublic static void shuffle(final short[] array);\npublic static void shuffle(final short[] array, final Random random);\npublic static void shuffle(final int[] array);\npublic static void shuffle(final int[] array, final Random random);\npublic static void shuffle(final long[] array);\npublic static void shuffle(final long[] array, final Random random);\npublic static void shuffle(final float[] array);\npublic static void shuffle(final float[] array, final Random random);\npublic static void shuffle(final double[] array);\npublic static void shuffle(final double[] array, final Random random);",
        "public_field": "/**\n * An empty immutable {@code Object} array.\n */\npublic static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];\n/**\n * An empty immutable {@code Class} array.\n */\npublic static final Class<?>[] EMPTY_CLASS_ARRAY = new Class[0];\n/**\n * An empty immutable {@code String} array.\n */\npublic static final String[] EMPTY_STRING_ARRAY = new String[0];\n/**\n * An empty immutable {@code long} array.\n */\npublic static final long[] EMPTY_LONG_ARRAY = new long[0];\n/**\n * An empty immutable {@code Long} array.\n */\npublic static final Long[] EMPTY_LONG_OBJECT_ARRAY = new Long[0];\n/**\n * An empty immutable {@code int} array.\n */\npublic static final int[] EMPTY_INT_ARRAY = new int[0];\n/**\n * An empty immutable {@code Integer} array.\n */\npublic static final Integer[] EMPTY_INTEGER_OBJECT_ARRAY = new Integer[0];\n/**\n * An empty immutable {@code short} array.\n */\npublic static final short[] EMPTY_SHORT_ARRAY = new short[0];\n/**\n * An empty immutable {@code Short} array.\n */\npublic static final Short[] EMPTY_SHORT_OBJECT_ARRAY = new Short[0];\n/**\n * An empty immutable {@code byte} array.\n */\npublic static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\n/**\n * An empty immutable {@code Byte} array.\n */\npublic static final Byte[] EMPTY_BYTE_OBJECT_ARRAY = new Byte[0];\n/**\n * An empty immutable {@code double} array.\n */\npublic static final double[] EMPTY_DOUBLE_ARRAY = new double[0];\n/**\n * An empty immutable {@code Double} array.\n */\npublic static final Double[] EMPTY_DOUBLE_OBJECT_ARRAY = new Double[0];\n/**\n * An empty immutable {@code float} array.\n */\npublic static final float[] EMPTY_FLOAT_ARRAY = new float[0];\n/**\n * An empty immutable {@code Float} array.\n */\npublic static final Float[] EMPTY_FLOAT_OBJECT_ARRAY = new Float[0];\n/**\n * An empty immutable {@code boolean} array.\n */\npublic static final boolean[] EMPTY_BOOLEAN_ARRAY = new boolean[0];\n/**\n * An empty immutable {@code Boolean} array.\n */\npublic static final Boolean[] EMPTY_BOOLEAN_OBJECT_ARRAY = new Boolean[0];\n/**\n * An empty immutable {@code char} array.\n */\npublic static final char[] EMPTY_CHAR_ARRAY = new char[0];\n/**\n * An empty immutable {@code Character} array.\n */\npublic static final Character[] EMPTY_CHARACTER_OBJECT_ARRAY = new Character[0];\n/**\n * The index value when an element is not found in a list or array: {@code -1}.\n * This value is returned by methods in this class and can also be used in comparisons with values returned by\n * various method from {@link java.util.List}.\n */\npublic static final int INDEX_NOT_FOUND = -1;",
        "Method_statement": "clone(final boolean() array)",
        "Method_name": "clone",
        "Class_declaration": "public class ArrayUtils {\n",
        "constructors": "public ArrayUtils() {\n    super();\n}",
        "all_method_signature": "public ArrayUtils();\npublic static String toString(final Object array);\npublic static String toString(final Object array, final String stringIfNull);\npublic static int hashCode(final Object array);\npublic static boolean isEquals(final Object array1, final Object array2);\npublic static Map<Object, Object> toMap(final Object[] array);\npublic static T[] toArray(final T... items);\npublic static T[] clone(final T[] array);\npublic static long[] clone(final long[] array);\npublic static int[] clone(final int[] array);\npublic static short[] clone(final short[] array);\npublic static char[] clone(final char[] array);\npublic static byte[] clone(final byte[] array);\npublic static double[] clone(final double[] array);\npublic static float[] clone(final float[] array);\npublic static boolean[] clone(final boolean[] array);\npublic static T[] nullToEmpty(final T[] array, final Class<T[]> type);\npublic static Object[] nullToEmpty(final Object[] array);\npublic static Class<?>[] nullToEmpty(final Class<?>[] array);\npublic static String[] nullToEmpty(final String[] array);\npublic static long[] nullToEmpty(final long[] array);\npublic static int[] nullToEmpty(final int[] array);\npublic static short[] nullToEmpty(final short[] array);\npublic static char[] nullToEmpty(final char[] array);\npublic static byte[] nullToEmpty(final byte[] array);\npublic static double[] nullToEmpty(final double[] array);\npublic static float[] nullToEmpty(final float[] array);\npublic static boolean[] nullToEmpty(final boolean[] array);\npublic static Long[] nullToEmpty(final Long[] array);\npublic static Integer[] nullToEmpty(final Integer[] array);\npublic static Short[] nullToEmpty(final Short[] array);\npublic static Character[] nullToEmpty(final Character[] array);\npublic static Byte[] nullToEmpty(final Byte[] array);\npublic static Double[] nullToEmpty(final Double[] array);\npublic static Float[] nullToEmpty(final Float[] array);\npublic static Boolean[] nullToEmpty(final Boolean[] array);\npublic static T[] subarray(final T[] array, int startIndexInclusive, int endIndexExclusive);\npublic static long[] subarray(final long[] array, int startIndexInclusive, int endIndexExclusive);\npublic static int[] subarray(final int[] array, int startIndexInclusive, int endIndexExclusive);\npublic static short[] subarray(final short[] array, int startIndexInclusive, int endIndexExclusive);\npublic static char[] subarray(final char[] array, int startIndexInclusive, int endIndexExclusive);\npublic static byte[] subarray(final byte[] array, int startIndexInclusive, int endIndexExclusive);\npublic static double[] subarray(final double[] array, int startIndexInclusive, int endIndexExclusive);\npublic static float[] subarray(final float[] array, int startIndexInclusive, int endIndexExclusive);\npublic static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive);\npublic static boolean isSameLength(final Object[] array1, final Object[] array2);\npublic static boolean isSameLength(final long[] array1, final long[] array2);\npublic static boolean isSameLength(final int[] array1, final int[] array2);\npublic static boolean isSameLength(final short[] array1, final short[] array2);\npublic static boolean isSameLength(final char[] array1, final char[] array2);\npublic static boolean isSameLength(final byte[] array1, final byte[] array2);\npublic static boolean isSameLength(final double[] array1, final double[] array2);\npublic static boolean isSameLength(final float[] array1, final float[] array2);\npublic static boolean isSameLength(final boolean[] array1, final boolean[] array2);\npublic static int getLength(final Object array);\npublic static boolean isSameType(final Object array1, final Object array2);\npublic static void reverse(final Object[] array);\npublic static void reverse(final long[] array);\npublic static void reverse(final int[] array);\npublic static void reverse(final short[] array);\npublic static void reverse(final char[] array);\npublic static void reverse(final byte[] array);\npublic static void reverse(final double[] array);\npublic static void reverse(final float[] array);\npublic static void reverse(final boolean[] array);\npublic static void reverse(final boolean[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final byte[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final char[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final double[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final float[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final int[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final long[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final Object[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final short[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void swap(final Object[] array, final int offset1, final int offset2);\npublic static void swap(final long[] array, final int offset1, final int offset2);\npublic static void swap(final int[] array, final int offset1, final int offset2);\npublic static void swap(final short[] array, final int offset1, final int offset2);\npublic static void swap(final char[] array, final int offset1, final int offset2);\npublic static void swap(final byte[] array, final int offset1, final int offset2);\npublic static void swap(final double[] array, final int offset1, final int offset2);\npublic static void swap(final float[] array, final int offset1, final int offset2);\npublic static void swap(final boolean[] array, final int offset1, final int offset2);\npublic static void swap(final boolean[] array, int offset1, int offset2, int len);\npublic static void swap(final byte[] array, int offset1, int offset2, int len);\npublic static void swap(final char[] array, int offset1, int offset2, int len);\npublic static void swap(final double[] array, int offset1, int offset2, int len);\npublic static void swap(final float[] array, int offset1, int offset2, int len);\npublic static void swap(final int[] array, int offset1, int offset2, int len);\npublic static void swap(final long[] array, int offset1, int offset2, int len);\npublic static void swap(final Object[] array, int offset1, int offset2, int len);\npublic static void swap(final short[] array, int offset1, int offset2, int len);\npublic static void shift(final Object[] array, final int offset);\npublic static void shift(final long[] array, final int offset);\npublic static void shift(final int[] array, final int offset);\npublic static void shift(final short[] array, final int offset);\npublic static void shift(final char[] array, final int offset);\npublic static void shift(final byte[] array, final int offset);\npublic static void shift(final double[] array, final int offset);\npublic static void shift(final float[] array, final int offset);\npublic static void shift(final boolean[] array, final int offset);\npublic static void shift(final boolean[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final byte[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final char[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final double[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final float[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final int[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final long[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final Object[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final short[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static int indexOf(final Object[] array, final Object objectToFind);\npublic static int indexOf(final Object[] array, final Object objectToFind, int startIndex);\npublic static int lastIndexOf(final Object[] array, final Object objectToFind);\npublic static int lastIndexOf(final Object[] array, final Object objectToFind, int startIndex);\npublic static boolean contains(final Object[] array, final Object objectToFind);\npublic static int indexOf(final long[] array, final long valueToFind);\npublic static int indexOf(final long[] array, final long valueToFind, int startIndex);\npublic static int lastIndexOf(final long[] array, final long valueToFind);\npublic static int lastIndexOf(final long[] array, final long valueToFind, int startIndex);\npublic static boolean contains(final long[] array, final long valueToFind);\npublic static int indexOf(final int[] array, final int valueToFind);\npublic static int indexOf(final int[] array, final int valueToFind, int startIndex);\npublic static int lastIndexOf(final int[] array, final int valueToFind);\npublic static int lastIndexOf(final int[] array, final int valueToFind, int startIndex);\npublic static boolean contains(final int[] array, final int valueToFind);\npublic static int indexOf(final short[] array, final short valueToFind);\npublic static int indexOf(final short[] array, final short valueToFind, int startIndex);\npublic static int lastIndexOf(final short[] array, final short valueToFind);\npublic static int lastIndexOf(final short[] array, final short valueToFind, int startIndex);\npublic static boolean contains(final short[] array, final short valueToFind);\npublic static int indexOf(final char[] array, final char valueToFind);\npublic static int indexOf(final char[] array, final char valueToFind, int startIndex);\npublic static int lastIndexOf(final char[] array, final char valueToFind);\npublic static int lastIndexOf(final char[] array, final char valueToFind, int startIndex);\npublic static boolean contains(final char[] array, final char valueToFind);\npublic static int indexOf(final byte[] array, final byte valueToFind);\npublic static int indexOf(final byte[] array, final byte valueToFind, int startIndex);\npublic static int lastIndexOf(final byte[] array, final byte valueToFind);\npublic static int lastIndexOf(final byte[] array, final byte valueToFind, int startIndex);\npublic static boolean contains(final byte[] array, final byte valueToFind);\npublic static int indexOf(final double[] array, final double valueToFind);\npublic static int indexOf(final double[] array, final double valueToFind, final double tolerance);\npublic static int indexOf(final double[] array, final double valueToFind, int startIndex);\npublic static int indexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance);\npublic static int lastIndexOf(final double[] array, final double valueToFind);\npublic static int lastIndexOf(final double[] array, final double valueToFind, final double tolerance);\npublic static int lastIndexOf(final double[] array, final double valueToFind, int startIndex);\npublic static int lastIndexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance);\npublic static boolean contains(final double[] array, final double valueToFind);\npublic static boolean contains(final double[] array, final double valueToFind, final double tolerance);\npublic static int indexOf(final float[] array, final float valueToFind);\npublic static int indexOf(final float[] array, final float valueToFind, int startIndex);\npublic static int lastIndexOf(final float[] array, final float valueToFind);\npublic static int lastIndexOf(final float[] array, final float valueToFind, int startIndex);\npublic static boolean contains(final float[] array, final float valueToFind);\npublic static int indexOf(final boolean[] array, final boolean valueToFind);\npublic static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex);\npublic static int lastIndexOf(final boolean[] array, final boolean valueToFind);\npublic static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex);\npublic static boolean contains(final boolean[] array, final boolean valueToFind);\npublic static char[] toPrimitive(final Character[] array);\npublic static char[] toPrimitive(final Character[] array, final char valueForNull);\npublic static Character[] toObject(final char[] array);\npublic static long[] toPrimitive(final Long[] array);\npublic static long[] toPrimitive(final Long[] array, final long valueForNull);\npublic static Long[] toObject(final long[] array);\npublic static int[] toPrimitive(final Integer[] array);\npublic static int[] toPrimitive(final Integer[] array, final int valueForNull);\npublic static Integer[] toObject(final int[] array);\npublic static short[] toPrimitive(final Short[] array);\npublic static short[] toPrimitive(final Short[] array, final short valueForNull);\npublic static Short[] toObject(final short[] array);\npublic static byte[] toPrimitive(final Byte[] array);\npublic static byte[] toPrimitive(final Byte[] array, final byte valueForNull);\npublic static Byte[] toObject(final byte[] array);\npublic static double[] toPrimitive(final Double[] array);\npublic static double[] toPrimitive(final Double[] array, final double valueForNull);\npublic static Double[] toObject(final double[] array);\npublic static float[] toPrimitive(final Float[] array);\npublic static float[] toPrimitive(final Float[] array, final float valueForNull);\npublic static Float[] toObject(final float[] array);\npublic static Object toPrimitive(final Object array);\npublic static boolean[] toPrimitive(final Boolean[] array);\npublic static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull);\npublic static Boolean[] toObject(final boolean[] array);\npublic static boolean isEmpty(final Object[] array);\npublic static boolean isEmpty(final long[] array);\npublic static boolean isEmpty(final int[] array);\npublic static boolean isEmpty(final short[] array);\npublic static boolean isEmpty(final char[] array);\npublic static boolean isEmpty(final byte[] array);\npublic static boolean isEmpty(final double[] array);\npublic static boolean isEmpty(final float[] array);\npublic static boolean isEmpty(final boolean[] array);\npublic static boolean isNotEmpty(final T[] array);\npublic static boolean isNotEmpty(final long[] array);\npublic static boolean isNotEmpty(final int[] array);\npublic static boolean isNotEmpty(final short[] array);\npublic static boolean isNotEmpty(final char[] array);\npublic static boolean isNotEmpty(final byte[] array);\npublic static boolean isNotEmpty(final double[] array);\npublic static boolean isNotEmpty(final float[] array);\npublic static boolean isNotEmpty(final boolean[] array);\npublic static T[] addAll(final T[] array1, final T... array2);\npublic static boolean[] addAll(final boolean[] array1, final boolean... array2);\npublic static char[] addAll(final char[] array1, final char... array2);\npublic static byte[] addAll(final byte[] array1, final byte... array2);\npublic static short[] addAll(final short[] array1, final short... array2);\npublic static int[] addAll(final int[] array1, final int... array2);\npublic static long[] addAll(final long[] array1, final long... array2);\npublic static float[] addAll(final float[] array1, final float... array2);\npublic static double[] addAll(final double[] array1, final double... array2);\npublic static T[] add(final T[] array, final T element);\npublic static boolean[] add(final boolean[] array, final boolean element);\npublic static byte[] add(final byte[] array, final byte element);\npublic static char[] add(final char[] array, final char element);\npublic static double[] add(final double[] array, final double element);\npublic static float[] add(final float[] array, final float element);\npublic static int[] add(final int[] array, final int element);\npublic static long[] add(final long[] array, final long element);\npublic static short[] add(final short[] array, final short element);\nprivate static Object copyArrayGrow1(final Object array, final Class<?> newArrayComponentType);\npublic static T[] add(final T[] array, final int index, final T element);\npublic static boolean[] add(final boolean[] array, final int index, final boolean element);\npublic static char[] add(final char[] array, final int index, final char element);\npublic static byte[] add(final byte[] array, final int index, final byte element);\npublic static short[] add(final short[] array, final int index, final short element);\npublic static int[] add(final int[] array, final int index, final int element);\npublic static long[] add(final long[] array, final int index, final long element);\npublic static float[] add(final float[] array, final int index, final float element);\npublic static double[] add(final double[] array, final int index, final double element);\nprivate static Object add(final Object array, final int index, final Object element, final Class<?> clss);\npublic static T[] remove(final T[] array, final int index);\npublic static T[] removeElement(final T[] array, final Object element);\npublic static boolean[] remove(final boolean[] array, final int index);\npublic static boolean[] removeElement(final boolean[] array, final boolean element);\npublic static byte[] remove(final byte[] array, final int index);\npublic static byte[] removeElement(final byte[] array, final byte element);\npublic static char[] remove(final char[] array, final int index);\npublic static char[] removeElement(final char[] array, final char element);\npublic static double[] remove(final double[] array, final int index);\npublic static double[] removeElement(final double[] array, final double element);\npublic static float[] remove(final float[] array, final int index);\npublic static float[] removeElement(final float[] array, final float element);\npublic static int[] remove(final int[] array, final int index);\npublic static int[] removeElement(final int[] array, final int element);\npublic static long[] remove(final long[] array, final int index);\npublic static long[] removeElement(final long[] array, final long element);\npublic static short[] remove(final short[] array, final int index);\npublic static short[] removeElement(final short[] array, final short element);\nprivate static Object remove(final Object array, final int index);\npublic static T[] removeAll(final T[] array, final int... indices);\npublic static T[] removeElements(final T[] array, final T... values);\npublic static byte[] removeAll(final byte[] array, final int... indices);\npublic static byte[] removeElements(final byte[] array, final byte... values);\npublic static short[] removeAll(final short[] array, final int... indices);\npublic static short[] removeElements(final short[] array, final short... values);\npublic static int[] removeAll(final int[] array, final int... indices);\npublic static int[] removeElements(final int[] array, final int... values);\npublic static char[] removeAll(final char[] array, final int... indices);\npublic static char[] removeElements(final char[] array, final char... values);\npublic static long[] removeAll(final long[] array, final int... indices);\npublic static long[] removeElements(final long[] array, final long... values);\npublic static float[] removeAll(final float[] array, final int... indices);\npublic static float[] removeElements(final float[] array, final float... values);\npublic static double[] removeAll(final double[] array, final int... indices);\npublic static double[] removeElements(final double[] array, final double... values);\npublic static boolean[] removeAll(final boolean[] array, final int... indices);\npublic static boolean[] removeElements(final boolean[] array, final boolean... values);\n static Object removeAll(final Object array, final int... indices);\n static Object removeAll(final Object array, final BitSet indices);\npublic static boolean isSorted(final T[] array);\npublic static boolean isSorted(final T[] array, final Comparator<T> comparator);\npublic static boolean isSorted(final int[] array);\npublic static boolean isSorted(final long[] array);\npublic static boolean isSorted(final short[] array);\npublic static boolean isSorted(final double[] array);\npublic static boolean isSorted(final float[] array);\npublic static boolean isSorted(final byte[] array);\npublic static boolean isSorted(final char[] array);\npublic static boolean isSorted(final boolean[] array);\npublic static boolean[] removeAllOccurences(final boolean[] array, final boolean element);\npublic static char[] removeAllOccurences(final char[] array, final char element);\npublic static byte[] removeAllOccurences(final byte[] array, final byte element);\npublic static short[] removeAllOccurences(final short[] array, final short element);\npublic static int[] removeAllOccurences(final int[] array, final int element);\npublic static long[] removeAllOccurences(final long[] array, final long element);\npublic static float[] removeAllOccurences(final float[] array, final float element);\npublic static double[] removeAllOccurences(final double[] array, final double element);\npublic static T[] removeAllOccurences(final T[] array, final T element);\npublic static String[] toStringArray(final Object[] array);\npublic static String[] toStringArray(final Object[] array, final String valueForNullElements);\npublic static boolean[] insert(final int index, final boolean[] array, final boolean... values);\npublic static byte[] insert(final int index, final byte[] array, final byte... values);\npublic static char[] insert(final int index, final char[] array, final char... values);\npublic static double[] insert(final int index, final double[] array, final double... values);\npublic static float[] insert(final int index, final float[] array, final float... values);\npublic static int[] insert(final int index, final int[] array, final int... values);\npublic static long[] insert(final int index, final long[] array, final long... values);\npublic static short[] insert(final int index, final short[] array, final short... values);\npublic static T[] insert(final int index, final T[] array, final T... values);\npublic static void shuffle(final Object[] array);\npublic static void shuffle(final Object[] array, final Random random);\npublic static void shuffle(final boolean[] array);\npublic static void shuffle(final boolean[] array, final Random random);\npublic static void shuffle(final byte[] array);\npublic static void shuffle(final byte[] array, final Random random);\npublic static void shuffle(final char[] array);\npublic static void shuffle(final char[] array, final Random random);\npublic static void shuffle(final short[] array);\npublic static void shuffle(final short[] array, final Random random);\npublic static void shuffle(final int[] array);\npublic static void shuffle(final int[] array, final Random random);\npublic static void shuffle(final long[] array);\npublic static void shuffle(final long[] array, final Random random);\npublic static void shuffle(final float[] array);\npublic static void shuffle(final float[] array, final Random random);\npublic static void shuffle(final double[] array);\npublic static void shuffle(final double[] array, final Random random);",
        "Class_name": "ArrayUtils",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/ArrayUtils###clone",
        "Parameter_num": "1",
        "all_Import_statements": "import java.lang.reflect.Array;\n\nimport java.util.Arrays;\n\nimport java.util.BitSet;\n\nimport java.util.Comparator;\n\nimport java.util.HashMap;\n\nimport java.util.Map;\n\nimport java.util.Random;\n\nimport org.apache.commons.lang3.builder.EqualsBuilder;\n\nimport org.apache.commons.lang3.builder.HashCodeBuilder;\n\nimport org.apache.commons.lang3.builder.ToStringBuilder;\n\nimport org.apache.commons.lang3.builder.ToStringStyle;\n\nimport org.apache.commons.lang3.math.NumberUtils;\n\nimport org.apache.commons.lang3.mutable.MutableInt;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
        "comment": "\n     * <p>Clones an array returning a typecast result and handling\n     * {@code null}.\n     *\n     * <p>This method returns {@code null} for a {@code null} input array.\n     *\n     * @param array  the array to clone, may be {@code null}\n     * @return the cloned array, {@code null} if {@code null} input\n     ",
        "packageName": "org.apache.commons.lang3",
        "method_signature": "public static boolean[] clone(final boolean[] array);",
        "Junit_version": "4",
        "returnType": "boolean[]"
    },
    {
        "Method_body": "public static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools) {\n    if (src.length == 0 && srcPos == 0 || 0 == nBools) {\n        return dstInit;\n    }\n    if (nBools - 1 + dstPos >= 8) {\n        throw new IllegalArgumentException(\"nBools-1+dstPos is greater or equal to than 8\");\n    }\n    byte out = dstInit;\n    for (int i = 0; i < nBools; i++) {\n        final int shift = i + dstPos;\n        final int bits = (src[i + srcPos] ? 1 : 0) << shift;\n        final int mask = 0x1 << shift;\n        out = (byte) ((out & ~mask) | bits);\n    }\n    return out;\n}",
        "all_field_declaration": "",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "5",
        "Filed": "",
        "Parameter_type": "boolean[],int,byte,int,int",
        "Import_statements": "",
        "public_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
        "public_field": "",
        "Method_statement": "binaryToByte(final boolean() src, final int srcPos, final byte dstInit, final int dstPos, final int nBools)",
        "Method_name": "binaryToByte",
        "Class_declaration": "public class Conversion {\n",
        "constructors": "",
        "all_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
        "Class_name": "Conversion",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Conversion###binaryToByte",
        "Parameter_num": "5",
        "all_Import_statements": "import java.util.UUID;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
        "comment": "\n     * <p>\n     * Converts binary (represented as boolean array) into a byte using the default (little\n     * endian, Lsb0) byte and bit ordering.\n     * </p>\n     *\n     * @param src the binary to convert\n     * @param srcPos the position in {@code src}, in boolean unit, from where to start the\n     *            conversion\n     * @param dstInit initial value of the destination byte\n     * @param dstPos the position of the lsb, in bits, in the result byte\n     * @param nBools the number of booleans to convert\n     * @return a byte containing the selected bits\n     * @throws NullPointerException if {@code src} is {@code null}\n     * @throws IllegalArgumentException if {@code nBools-1+dstPos >= 8}\n     * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nBools > src.length}\n     ",
        "packageName": "org.apache.commons.lang3",
        "method_signature": "public static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);",
        "Junit_version": "4",
        "returnType": "byte"
    },
    {
        "Method_body": "public static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools) {\n    if (src.length == 0 && srcPos == 0 || 0 == nBools) {\n        return dstInit;\n    }\n    if (nBools - 1 + dstPos >= 32) {\n        throw new IllegalArgumentException(\"nBools-1+dstPos is greater or equal to than 32\");\n    }\n    int out = dstInit;\n    for (int i = 0; i < nBools; i++) {\n        final int shift = i + dstPos;\n        final int bits = (src[i + srcPos] ? 1 : 0) << shift;\n        final int mask = 0x1 << shift;\n        out = (out & ~mask) | bits;\n    }\n    return out;\n}",
        "all_field_declaration": "",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "5",
        "Filed": "",
        "Parameter_type": "boolean[],int,int,int,int",
        "Import_statements": "",
        "public_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
        "public_field": "",
        "Method_statement": "binaryToInt(final boolean() src, final int srcPos, final int dstInit, final int dstPos, final int nBools)",
        "Method_name": "binaryToInt",
        "Class_declaration": "public class Conversion {\n",
        "constructors": "",
        "all_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
        "Class_name": "Conversion",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Conversion###binaryToInt",
        "Parameter_num": "5",
        "all_Import_statements": "import java.util.UUID;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
        "comment": "\n     * <p>\n     * Converts binary (represented as boolean array) into an int using the default (little\n     * endian, Lsb0) byte and bit ordering.\n     * </p>\n     *\n     * @param src the binary to convert\n     * @param srcPos the position in {@code src}, in boolean unit, from where to start the\n     *            conversion\n     * @param dstInit initial value of the destination int\n     * @param dstPos the position of the lsb, in bits, in the result int\n     * @param nBools the number of booleans to convert\n     * @return an int containing the selected bits\n     * @throws NullPointerException if {@code src} is {@code null}\n     * @throws IllegalArgumentException if {@code nBools-1+dstPos >= 32}\n     * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nBools > src.length}\n     ",
        "packageName": "org.apache.commons.lang3",
        "method_signature": "public static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);",
        "Junit_version": "4",
        "returnType": "int"
    },
    {
        "Method_body": "public static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools) {\n    if (src.length == 0 && srcPos == 0 || 0 == nBools) {\n        return dstInit;\n    }\n    if (nBools - 1 + dstPos >= 64) {\n        throw new IllegalArgumentException(\"nBools-1+dstPos is greater or equal to than 64\");\n    }\n    long out = dstInit;\n    for (int i = 0; i < nBools; i++) {\n        final int shift = i + dstPos;\n        final long bits = (src[i + srcPos] ? 1L : 0) << shift;\n        final long mask = 0x1L << shift;\n        out = (out & ~mask) | bits;\n    }\n    return out;\n}",
        "all_field_declaration": "",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "5",
        "Filed": "",
        "Parameter_type": "boolean[],int,long,int,int",
        "Import_statements": "",
        "public_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
        "public_field": "",
        "Method_statement": "binaryToLong(final boolean() src, final int srcPos, final long dstInit, final int dstPos, final int nBools)",
        "Method_name": "binaryToLong",
        "Class_declaration": "public class Conversion {\n",
        "constructors": "",
        "all_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
        "Class_name": "Conversion",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Conversion###binaryToLong",
        "Parameter_num": "5",
        "all_Import_statements": "import java.util.UUID;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
        "comment": "\n     * <p>\n     * Converts binary (represented as boolean array) into a long using the default (little\n     * endian, Lsb0) byte and bit ordering.\n     * </p>\n     *\n     * @param src the binary to convert\n     * @param srcPos the position in {@code src}, in boolean unit, from where to start the\n     *            conversion\n     * @param dstInit initial value of the destination long\n     * @param dstPos the position of the lsb, in bits, in the result long\n     * @param nBools the number of booleans to convert\n     * @return a long containing the selected bits\n     * @throws NullPointerException if {@code src} is {@code null}\n     * @throws IllegalArgumentException if {@code nBools-1+dstPos >= 64}\n     * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nBools > src.length}\n     ",
        "packageName": "org.apache.commons.lang3",
        "method_signature": "public static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);",
        "Junit_version": "4",
        "returnType": "long"
    },
    {
        "Method_body": "public static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools) {\n    if (src.length == 0 && srcPos == 0 || 0 == nBools) {\n        return dstInit;\n    }\n    if (nBools - 1 + dstPos >= 16) {\n        throw new IllegalArgumentException(\"nBools-1+dstPos is greater or equal to than 16\");\n    }\n    short out = dstInit;\n    for (int i = 0; i < nBools; i++) {\n        final int shift = i + dstPos;\n        final int bits = (src[i + srcPos] ? 1 : 0) << shift;\n        final int mask = 0x1 << shift;\n        out = (short) ((out & ~mask) | bits);\n    }\n    return out;\n}",
        "all_field_declaration": "",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "5",
        "Filed": "",
        "Parameter_type": "boolean[],int,short,int,int",
        "Import_statements": "",
        "public_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
        "public_field": "",
        "Method_statement": "binaryToShort(final boolean() src, final int srcPos, final short dstInit, final int dstPos, final int nBools)",
        "Method_name": "binaryToShort",
        "Class_declaration": "public class Conversion {\n",
        "constructors": "",
        "all_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
        "Class_name": "Conversion",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Conversion###binaryToShort",
        "Parameter_num": "5",
        "all_Import_statements": "import java.util.UUID;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
        "comment": "\n     * <p>\n     * Converts binary (represented as boolean array) into a short using the default (little\n     * endian, Lsb0) byte and bit ordering.\n     * </p>\n     *\n     * @param src the binary to convert\n     * @param srcPos the position in {@code src}, in boolean unit, from where to start the\n     *            conversion\n     * @param dstInit initial value of the destination short\n     * @param dstPos the position of the lsb, in bits, in the result short\n     * @param nBools the number of booleans to convert\n     * @return a short containing the selected bits\n     * @throws NullPointerException if {@code src} is {@code null}\n     * @throws IllegalArgumentException if {@code nBools-1+dstPos >= 16}\n     * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nBools > src.length}\n     ",
        "packageName": "org.apache.commons.lang3",
        "method_signature": "public static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);",
        "Junit_version": "4",
        "returnType": "short"
    },
    {
        "Method_body": "public static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes) {\n    if (src.length == 0 && srcPos == 0 || 0 == nBytes) {\n        return dstInit;\n    }\n    if ((nBytes - 1) * 8 + dstPos >= 32) {\n        throw new IllegalArgumentException(\"(nBytes-1)*8+dstPos is greater or equal to than 32\");\n    }\n    int out = dstInit;\n    for (int i = 0; i < nBytes; i++) {\n        final int shift = i * 8 + dstPos;\n        final int bits = (0xff & src[i + srcPos]) << shift;\n        final int mask = 0xff << shift;\n        out = (out & ~mask) | bits;\n    }\n    return out;\n}",
        "all_field_declaration": "",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "5",
        "Filed": "",
        "Parameter_type": "byte[],int,int,int,int",
        "Import_statements": "",
        "public_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
        "public_field": "",
        "Method_statement": "byteArrayToInt(final byte() src, final int srcPos, final int dstInit, final int dstPos, final int nBytes)",
        "Method_name": "byteArrayToInt",
        "Class_declaration": "public class Conversion {\n",
        "constructors": "",
        "all_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
        "Class_name": "Conversion",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Conversion###byteArrayToInt",
        "Parameter_num": "5",
        "all_Import_statements": "import java.util.UUID;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
        "comment": "\n     * <p>\n     * Converts an array of byte into an int using the default (little endian, Lsb0) byte and bit\n     * ordering.\n     * </p>\n     *\n     * @param src the byte array to convert\n     * @param srcPos the position in {@code src}, in byte unit, from where to start the\n     *            conversion\n     * @param dstInit initial value of the destination int\n     * @param dstPos the position of the lsb, in bits, in the result int\n     * @param nBytes the number of bytes to convert\n     * @return an int containing the selected bits\n     * @throws NullPointerException if {@code src} is {@code null}\n     * @throws IllegalArgumentException if {@code (nBytes-1)*8+dstPos >= 32}\n     * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nBytes > src.length}\n     ",
        "packageName": "org.apache.commons.lang3",
        "method_signature": "public static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);",
        "Junit_version": "4",
        "returnType": "int"
    },
    {
        "Method_body": "public static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes) {\n    if (src.length == 0 && srcPos == 0 || 0 == nBytes) {\n        return dstInit;\n    }\n    if ((nBytes - 1) * 8 + dstPos >= 64) {\n        throw new IllegalArgumentException(\"(nBytes-1)*8+dstPos is greater or equal to than 64\");\n    }\n    long out = dstInit;\n    for (int i = 0; i < nBytes; i++) {\n        final int shift = i * 8 + dstPos;\n        final long bits = (0xffL & src[i + srcPos]) << shift;\n        final long mask = 0xffL << shift;\n        out = (out & ~mask) | bits;\n    }\n    return out;\n}",
        "all_field_declaration": "",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "5",
        "Filed": "",
        "Parameter_type": "byte[],int,long,int,int",
        "Import_statements": "",
        "public_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
        "public_field": "",
        "Method_statement": "byteArrayToLong(final byte() src, final int srcPos, final long dstInit, final int dstPos, final int nBytes)",
        "Method_name": "byteArrayToLong",
        "Class_declaration": "public class Conversion {\n",
        "constructors": "",
        "all_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
        "Class_name": "Conversion",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Conversion###byteArrayToLong",
        "Parameter_num": "5",
        "all_Import_statements": "import java.util.UUID;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
        "comment": "\n     * <p>\n     * Converts an array of byte into a long using the default (little endian, Lsb0) byte and\n     * bit ordering.\n     * </p>\n     *\n     * @param src the byte array to convert\n     * @param srcPos the position in {@code src}, in byte unit, from where to start the\n     *            conversion\n     * @param dstInit initial value of the destination long\n     * @param dstPos the position of the lsb, in bits, in the result long\n     * @param nBytes the number of bytes to convert\n     * @return a long containing the selected bits\n     * @throws NullPointerException if {@code src} is {@code null}\n     * @throws IllegalArgumentException if {@code (nBytes-1)*8+dstPos >= 64}\n     * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nBytes > src.length}\n     ",
        "packageName": "org.apache.commons.lang3",
        "method_signature": "public static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);",
        "Junit_version": "4",
        "returnType": "long"
    },
    {
        "Method_body": "public static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex) {\n    if (0 == nHex) {\n        return dstInit;\n    }\n    if ((nHex - 1) * 4 + dstPos >= 8) {\n        throw new IllegalArgumentException(\"(nHexs-1)*4+dstPos is greater or equal to than 8\");\n    }\n    byte out = dstInit;\n    for (int i = 0; i < nHex; i++) {\n        final int shift = i * 4 + dstPos;\n        final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift;\n        final int mask = 0xf << shift;\n        out = (byte) ((out & ~mask) | bits);\n    }\n    return out;\n}",
        "all_field_declaration": "",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "5",
        "Filed": "",
        "Parameter_type": "String,int,byte,int,int",
        "Import_statements": "",
        "public_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
        "public_field": "",
        "Method_statement": "hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex)",
        "Method_name": "hexToByte",
        "Class_declaration": "public class Conversion {\n",
        "constructors": "",
        "all_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
        "Class_name": "Conversion",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Conversion###hexToByte",
        "Parameter_num": "5",
        "all_Import_statements": "import java.util.UUID;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
        "comment": "\n     * <p>\n     * Converts an array of Char into a byte using the default (little endian, Lsb0) byte and\n     * bit ordering.\n     * </p>\n     *\n     * @param src the hex string to convert\n     * @param srcPos the position in {@code src}, in Char unit, from where to start the\n     *            conversion\n     * @param dstInit initial value of the destination byte\n     * @param dstPos the position of the lsb, in bits, in the result byte\n     * @param nHex the number of Chars to convert\n     * @return a byte containing the selected bits\n     * @throws IllegalArgumentException if {@code (nHexs-1)*4+dstPos >= 8}\n     ",
        "packageName": "org.apache.commons.lang3",
        "method_signature": "public static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);",
        "Junit_version": "4",
        "returnType": "byte"
    },
    {
        "Method_body": "public static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex) {\n    if (0 == nHex) {\n        return dstInit;\n    }\n    if ((nHex - 1) * 4 + dstPos >= 32) {\n        throw new IllegalArgumentException(\"(nHexs-1)*4+dstPos is greater or equal to than 32\");\n    }\n    int out = dstInit;\n    for (int i = 0; i < nHex; i++) {\n        final int shift = i * 4 + dstPos;\n        final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift;\n        final int mask = 0xf << shift;\n        out = (out & ~mask) | bits;\n    }\n    return out;\n}",
        "all_field_declaration": "",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "5",
        "Filed": "",
        "Parameter_type": "String,int,int,int,int",
        "Import_statements": "",
        "public_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
        "public_field": "",
        "Method_statement": "hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex)",
        "Method_name": "hexToInt",
        "Class_declaration": "public class Conversion {\n",
        "constructors": "",
        "all_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
        "Class_name": "Conversion",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Conversion###hexToInt",
        "Parameter_num": "5",
        "all_Import_statements": "import java.util.UUID;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
        "comment": "\n     * <p>\n     * Converts an array of Char into an int using the default (little endian, Lsb0) byte and bit\n     * ordering.\n     * </p>\n     *\n     * @param src the hex string to convert\n     * @param srcPos the position in {@code src}, in Char unit, from where to start the\n     *            conversion\n     * @param dstInit initial value of the destination int\n     * @param dstPos the position of the lsb, in bits, in the result int\n     * @param nHex the number of Chars to convert\n     * @return an int containing the selected bits\n     * @throws IllegalArgumentException if {@code (nHexs-1)*4+dstPos >= 32}\n     ",
        "packageName": "org.apache.commons.lang3",
        "method_signature": "public static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);",
        "Junit_version": "4",
        "returnType": "int"
    },
    {
        "Method_body": "public static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex) {\n    if (0 == nHex) {\n        return dstInit;\n    }\n    if ((nHex - 1) * 4 + dstPos >= 64) {\n        throw new IllegalArgumentException(\"(nHexs-1)*4+dstPos is greater or equal to than 64\");\n    }\n    long out = dstInit;\n    for (int i = 0; i < nHex; i++) {\n        final int shift = i * 4 + dstPos;\n        final long bits = (0xfL & hexDigitToInt(src.charAt(i + srcPos))) << shift;\n        final long mask = 0xfL << shift;\n        out = (out & ~mask) | bits;\n    }\n    return out;\n}",
        "all_field_declaration": "",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "5",
        "Filed": "",
        "Parameter_type": "String,int,long,int,int",
        "Import_statements": "",
        "public_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
        "public_field": "",
        "Method_statement": "hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex)",
        "Method_name": "hexToLong",
        "Class_declaration": "public class Conversion {\n",
        "constructors": "",
        "all_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
        "Class_name": "Conversion",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Conversion###hexToLong",
        "Parameter_num": "5",
        "all_Import_statements": "import java.util.UUID;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
        "comment": "\n     * <p>\n     * Converts an array of Char into a long using the default (little endian, Lsb0) byte and\n     * bit ordering.\n     * </p>\n     *\n     * @param src the hex string to convert\n     * @param srcPos the position in {@code src}, in Char unit, from where to start the\n     *            conversion\n     * @param dstInit initial value of the destination long\n     * @param dstPos the position of the lsb, in bits, in the result long\n     * @param nHex the number of Chars to convert\n     * @return a long containing the selected bits\n     * @throws IllegalArgumentException if {@code (nHexs-1)*4+dstPos >= 64}\n     ",
        "packageName": "org.apache.commons.lang3",
        "method_signature": "public static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);",
        "Junit_version": "4",
        "returnType": "long"
    },
    {
        "Method_body": "public static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex) {\n    if (0 == nHex) {\n        return dstInit;\n    }\n    if ((nHex - 1) * 4 + dstPos >= 16) {\n        throw new IllegalArgumentException(\"(nHexs-1)*4+dstPos is greater or equal to than 16\");\n    }\n    short out = dstInit;\n    for (int i = 0; i < nHex; i++) {\n        final int shift = i * 4 + dstPos;\n        final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift;\n        final int mask = 0xf << shift;\n        out = (short) ((out & ~mask) | bits);\n    }\n    return out;\n}",
        "all_field_declaration": "",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "5",
        "Filed": "",
        "Parameter_type": "String,int,short,int,int",
        "Import_statements": "",
        "public_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
        "public_field": "",
        "Method_statement": "hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex)",
        "Method_name": "hexToShort",
        "Class_declaration": "public class Conversion {\n",
        "constructors": "",
        "all_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
        "Class_name": "Conversion",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Conversion###hexToShort",
        "Parameter_num": "5",
        "all_Import_statements": "import java.util.UUID;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
        "comment": "\n     * <p>\n     * Converts an array of Char into a short using the default (little endian, Lsb0) byte and\n     * bit ordering.\n     * </p>\n     *\n     * @param src the hex string to convert\n     * @param srcPos the position in {@code src}, in Char unit, from where to start the\n     *            conversion\n     * @param dstInit initial value of the destination short\n     * @param dstPos the position of the lsb, in bits, in the result short\n     * @param nHex the number of Chars to convert\n     * @return a short containing the selected bits\n     * @throws IllegalArgumentException if {@code (nHexs-1)*4+dstPos >= 16}\n     ",
        "packageName": "org.apache.commons.lang3",
        "method_signature": "public static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);",
        "Junit_version": "4",
        "returnType": "short"
    },
    {
        "Method_body": "public static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) {\n    if (0 == nHexs) {\n        return dstInit;\n    }\n    if ((nHexs - 1) * 4 + srcPos >= 64) {\n        throw new IllegalArgumentException(\"(nHexs-1)*4+srcPos is greater or equal to than 64\");\n    }\n    final StringBuilder sb = new StringBuilder(dstInit);\n    int append = sb.length();\n    for (int i = 0; i < nHexs; i++) {\n        final int shift = i * 4 + srcPos;\n        final int bits = (int) (0xF & (src >> shift));\n        if (dstPos + i == append) {\n            ++append;\n            sb.append(intToHexDigit(bits));\n        } else {\n            sb.setCharAt(dstPos + i, intToHexDigit(bits));\n        }\n    }\n    return sb.toString();\n}",
        "all_field_declaration": "",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "6",
        "Filed": "",
        "Parameter_type": "long,int,String,int,int",
        "Import_statements": "",
        "public_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
        "public_field": "",
        "Method_statement": "longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs)",
        "Method_name": "longToHex",
        "Class_declaration": "public class Conversion {\n",
        "constructors": "",
        "all_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
        "Class_name": "Conversion",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Conversion###longToHex",
        "Parameter_num": "5",
        "all_Import_statements": "import java.util.UUID;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
        "comment": "\n     * <p>\n     * Converts a long into an array of Char using the default (little endian, Lsb0) byte and\n     * bit ordering.\n     * </p>\n     *\n     * @param src the long to convert\n     * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n     * @param dstInit the initial value for the result String\n     * @param dstPos the position in {@code dst} where to copy the result\n     * @param nHexs the number of Chars to copy to {@code dst}, must be smaller or equal to the\n     *            width of the input (from srcPos to msb)\n     * @return {@code dst}\n     * @throws IllegalArgumentException if {@code (nHexs-1)*4+srcPos >= 64}\n     * @throws StringIndexOutOfBoundsException if {@code dst.init.length() < dstPos}\n     ",
        "packageName": "org.apache.commons.lang3",
        "method_signature": "public static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);",
        "Junit_version": "4",
        "returnType": "String"
    },
    {
        "Method_body": "public static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts) {\n    if (0 == nInts) {\n        return dst;\n    }\n    if ((nInts - 1) * 32 + srcPos >= 64) {\n        throw new IllegalArgumentException(\"(nInts-1)*32+srcPos is greater or equal to than 64\");\n    }\n    for (int i = 0; i < nInts; i++) {\n        final int shift = i * 32 + srcPos;\n        dst[dstPos + i] = (int) (0xffffffff & (src >> shift));\n    }\n    return dst;\n}",
        "all_field_declaration": "",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "4",
        "Filed": "",
        "Parameter_type": "long,int,int[],int,int",
        "Import_statements": "",
        "public_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
        "public_field": "",
        "Method_statement": "longToIntArray(final long src, final int srcPos, final int() dst, final int dstPos, final int nInts)",
        "Method_name": "longToIntArray",
        "Class_declaration": "public class Conversion {\n",
        "constructors": "",
        "all_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
        "Class_name": "Conversion",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Conversion###longToIntArray",
        "Parameter_num": "5",
        "all_Import_statements": "import java.util.UUID;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
        "comment": "\n     * <p>\n     * Converts a long into an array of int using the default (little endian, Lsb0) byte and bit\n     * ordering.\n     * </p>\n     *\n     * @param src the long to convert\n     * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n     * @param dst the destination array\n     * @param dstPos the position in {@code dst} where to copy the result\n     * @param nInts the number of ints to copy to {@code dst}, must be smaller or equal to the\n     *            width of the input (from srcPos to msb)\n     * @return {@code dst}\n     * @throws NullPointerException if {@code dst} is {@code null} and {@code nInts > 0}\n     * @throws IllegalArgumentException if {@code (nInts-1)*32+srcPos >= 64}\n     * @throws ArrayIndexOutOfBoundsException if {@code dstPos + nInts > dst.length}\n     ",
        "packageName": "org.apache.commons.lang3",
        "method_signature": "public static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);",
        "Junit_version": "4",
        "returnType": "int[]"
    },
    {
        "Method_body": "public static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts) {\n    if (src.length == 0 && srcPos == 0 || 0 == nShorts) {\n        return dstInit;\n    }\n    if ((nShorts - 1) * 16 + dstPos >= 32) {\n        throw new IllegalArgumentException(\"(nShorts-1)*16+dstPos is greater or equal to than 32\");\n    }\n    int out = dstInit;\n    for (int i = 0; i < nShorts; i++) {\n        final int shift = i * 16 + dstPos;\n        final int bits = (0xffff & src[i + srcPos]) << shift;\n        final int mask = 0xffff << shift;\n        out = (out & ~mask) | bits;\n    }\n    return out;\n}",
        "all_field_declaration": "",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "5",
        "Filed": "",
        "Parameter_type": "short[],int,int,int,int",
        "Import_statements": "",
        "public_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
        "public_field": "",
        "Method_statement": "shortArrayToInt(final short() src, final int srcPos, final int dstInit, final int dstPos, final int nShorts)",
        "Method_name": "shortArrayToInt",
        "Class_declaration": "public class Conversion {\n",
        "constructors": "",
        "all_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
        "Class_name": "Conversion",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Conversion###shortArrayToInt",
        "Parameter_num": "5",
        "all_Import_statements": "import java.util.UUID;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
        "comment": "\n     * <p>\n     * Converts an array of short into an int using the default (little endian, Lsb0) byte and\n     * bit ordering.\n     * </p>\n     *\n     * @param src the short array to convert\n     * @param srcPos the position in {@code src}, in short unit, from where to start the\n     *            conversion\n     * @param dstInit initial value of the destination int\n     * @param dstPos the position of the lsb, in bits, in the result int\n     * @param nShorts the number of shorts to convert\n     * @return an int containing the selected bits\n     * @throws NullPointerException if {@code src} is {@code null}\n     * @throws IllegalArgumentException if {@code (nShorts-1)*16+dstPos >= 32}\n     * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nShorts > src.length}\n     ",
        "packageName": "org.apache.commons.lang3",
        "method_signature": "public static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);",
        "Junit_version": "4",
        "returnType": "int"
    },
    {
        "Method_body": "public static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts) {\n    if (src.length == 0 && srcPos == 0 || 0 == nShorts) {\n        return dstInit;\n    }\n    if ((nShorts - 1) * 16 + dstPos >= 64) {\n        throw new IllegalArgumentException(\"(nShorts-1)*16+dstPos is greater or equal to than 64\");\n    }\n    long out = dstInit;\n    for (int i = 0; i < nShorts; i++) {\n        final int shift = i * 16 + dstPos;\n        final long bits = (0xffffL & src[i + srcPos]) << shift;\n        final long mask = 0xffffL << shift;\n        out = (out & ~mask) | bits;\n    }\n    return out;\n}",
        "all_field_declaration": "",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "5",
        "Filed": "",
        "Parameter_type": "short[],int,long,int,int",
        "Import_statements": "",
        "public_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
        "public_field": "",
        "Method_statement": "shortArrayToLong(final short() src, final int srcPos, final long dstInit, final int dstPos, final int nShorts)",
        "Method_name": "shortArrayToLong",
        "Class_declaration": "public class Conversion {\n",
        "constructors": "",
        "all_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
        "Class_name": "Conversion",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Conversion###shortArrayToLong",
        "Parameter_num": "5",
        "all_Import_statements": "import java.util.UUID;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
        "comment": "\n     * <p>\n     * Converts an array of short into a long using the default (little endian, Lsb0) byte and\n     * bit ordering.\n     * </p>\n     *\n     * @param src the short array to convert\n     * @param srcPos the position in {@code src}, in short unit, from where to start the\n     *            conversion\n     * @param dstInit initial value of the destination long\n     * @param dstPos the position of the lsb, in bits, in the result long\n     * @param nShorts the number of shorts to convert\n     * @return a long containing the selected bits\n     * @throws NullPointerException if {@code src} is {@code null}\n     * @throws IllegalArgumentException if {@code (nShorts-1)*16+dstPos >= 64}\n     * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nShorts > src.length}\n     ",
        "packageName": "org.apache.commons.lang3",
        "method_signature": "public static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);",
        "Junit_version": "4",
        "returnType": "long"
    },
    {
        "Method_body": "public static Calendar round(final Calendar date, final int field) {\n    if (date == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    final Calendar rounded = (Calendar) date.clone();\n    modify(rounded, field, ModifyType.ROUND);\n    return rounded;\n}",
        "all_field_declaration": "/**\n * Number of milliseconds in a standard second.\n * @since 2.1\n */\npublic static final long MILLIS_PER_SECOND = 1000;\n/**\n * Number of milliseconds in a standard minute.\n * @since 2.1\n */\npublic static final long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND;\n/**\n * Number of milliseconds in a standard hour.\n * @since 2.1\n */\npublic static final long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE;\n/**\n * Number of milliseconds in a standard day.\n * @since 2.1\n */\npublic static final long MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR;\n/**\n * This is half a month, so this represents whether a date is in the top\n * or bottom half of the month.\n */\npublic static final int SEMI_MONTH = 1001;\nprivate static final int[][] fields = { { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */\n}, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } };\n/**\n * A week range, starting on Sunday.\n */\npublic static final int RANGE_WEEK_SUNDAY = 1;\n/**\n * A week range, starting on Monday.\n */\npublic static final int RANGE_WEEK_MONDAY = 2;\n/**\n * A week range, starting on the day focused.\n */\npublic static final int RANGE_WEEK_RELATIVE = 3;\n/**\n * A week range, centered around the day focused.\n */\npublic static final int RANGE_WEEK_CENTER = 4;\n/**\n * A month range, the week starting on Sunday.\n */\npublic static final int RANGE_MONTH_SUNDAY = 5;\n/**\n * A month range, the week starting on Monday.\n */\npublic static final int RANGE_MONTH_MONDAY = 6;",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "4",
        "Filed": "",
        "Parameter_type": "Calendar,int",
        "Import_statements": "import java.util.Calendar;\n",
        "public_method_signature": "public DateUtils();\npublic static boolean isSameDay(final Date date1, final Date date2);\npublic static boolean isSameDay(final Calendar cal1, final Calendar cal2);\npublic static boolean isSameInstant(final Date date1, final Date date2);\npublic static boolean isSameInstant(final Calendar cal1, final Calendar cal2);\npublic static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2);\npublic static Date parseDate(final String str, final String... parsePatterns) throws ParseException;\npublic static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException;\npublic static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException;\npublic static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException;\npublic static Date addYears(final Date date, final int amount);\npublic static Date addMonths(final Date date, final int amount);\npublic static Date addWeeks(final Date date, final int amount);\npublic static Date addDays(final Date date, final int amount);\npublic static Date addHours(final Date date, final int amount);\npublic static Date addMinutes(final Date date, final int amount);\npublic static Date addSeconds(final Date date, final int amount);\npublic static Date addMilliseconds(final Date date, final int amount);\npublic static Date setYears(final Date date, final int amount);\npublic static Date setMonths(final Date date, final int amount);\npublic static Date setDays(final Date date, final int amount);\npublic static Date setHours(final Date date, final int amount);\npublic static Date setMinutes(final Date date, final int amount);\npublic static Date setSeconds(final Date date, final int amount);\npublic static Date setMilliseconds(final Date date, final int amount);\npublic static Calendar toCalendar(final Date date);\npublic static Calendar toCalendar(final Date date, final TimeZone tz);\npublic static Date round(final Date date, final int field);\npublic static Calendar round(final Calendar date, final int field);\npublic static Date round(final Object date, final int field);\npublic static Date truncate(final Date date, final int field);\npublic static Calendar truncate(final Calendar date, final int field);\npublic static Date truncate(final Object date, final int field);\npublic static Date ceiling(final Date date, final int field);\npublic static Calendar ceiling(final Calendar date, final int field);\npublic static Date ceiling(final Object date, final int field);\npublic static Iterator<Calendar> iterator(final Date focus, final int rangeStyle);\npublic static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle);\npublic static Iterator<?> iterator(final Object focus, final int rangeStyle);\npublic static long getFragmentInMilliseconds(final Date date, final int fragment);\npublic static long getFragmentInSeconds(final Date date, final int fragment);\npublic static long getFragmentInMinutes(final Date date, final int fragment);\npublic static long getFragmentInHours(final Date date, final int fragment);\npublic static long getFragmentInDays(final Date date, final int fragment);\npublic static long getFragmentInMilliseconds(final Calendar calendar, final int fragment);\npublic static long getFragmentInSeconds(final Calendar calendar, final int fragment);\npublic static long getFragmentInMinutes(final Calendar calendar, final int fragment);\npublic static long getFragmentInHours(final Calendar calendar, final int fragment);\npublic static long getFragmentInDays(final Calendar calendar, final int fragment);\npublic static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field);\npublic static boolean truncatedEquals(final Date date1, final Date date2, final int field);\npublic static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field);\npublic static int truncatedCompareTo(final Date date1, final Date date2, final int field);",
        "public_field": "/**\n * Number of milliseconds in a standard second.\n * @since 2.1\n */\npublic static final long MILLIS_PER_SECOND = 1000;\n/**\n * Number of milliseconds in a standard minute.\n * @since 2.1\n */\npublic static final long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND;\n/**\n * Number of milliseconds in a standard hour.\n * @since 2.1\n */\npublic static final long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE;\n/**\n * Number of milliseconds in a standard day.\n * @since 2.1\n */\npublic static final long MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR;\n/**\n * This is half a month, so this represents whether a date is in the top\n * or bottom half of the month.\n */\npublic static final int SEMI_MONTH = 1001;\n/**\n * A week range, starting on Sunday.\n */\npublic static final int RANGE_WEEK_SUNDAY = 1;\n/**\n * A week range, starting on Monday.\n */\npublic static final int RANGE_WEEK_MONDAY = 2;\n/**\n * A week range, starting on the day focused.\n */\npublic static final int RANGE_WEEK_RELATIVE = 3;\n/**\n * A week range, centered around the day focused.\n */\npublic static final int RANGE_WEEK_CENTER = 4;\n/**\n * A month range, the week starting on Sunday.\n */\npublic static final int RANGE_MONTH_SUNDAY = 5;\n/**\n * A month range, the week starting on Monday.\n */\npublic static final int RANGE_MONTH_MONDAY = 6;",
        "Method_statement": "round(final Calendar date, final int field)",
        "Method_name": "round",
        "Class_declaration": "public class DateUtils {\n",
        "constructors": "public DateUtils() {\n    super();\n}",
        "all_method_signature": "public DateUtils();\npublic static boolean isSameDay(final Date date1, final Date date2);\npublic static boolean isSameDay(final Calendar cal1, final Calendar cal2);\npublic static boolean isSameInstant(final Date date1, final Date date2);\npublic static boolean isSameInstant(final Calendar cal1, final Calendar cal2);\npublic static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2);\npublic static Date parseDate(final String str, final String... parsePatterns) throws ParseException;\npublic static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException;\npublic static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException;\npublic static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException;\nprivate static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException;\npublic static Date addYears(final Date date, final int amount);\npublic static Date addMonths(final Date date, final int amount);\npublic static Date addWeeks(final Date date, final int amount);\npublic static Date addDays(final Date date, final int amount);\npublic static Date addHours(final Date date, final int amount);\npublic static Date addMinutes(final Date date, final int amount);\npublic static Date addSeconds(final Date date, final int amount);\npublic static Date addMilliseconds(final Date date, final int amount);\nprivate static Date add(final Date date, final int calendarField, final int amount);\npublic static Date setYears(final Date date, final int amount);\npublic static Date setMonths(final Date date, final int amount);\npublic static Date setDays(final Date date, final int amount);\npublic static Date setHours(final Date date, final int amount);\npublic static Date setMinutes(final Date date, final int amount);\npublic static Date setSeconds(final Date date, final int amount);\npublic static Date setMilliseconds(final Date date, final int amount);\nprivate static Date set(final Date date, final int calendarField, final int amount);\npublic static Calendar toCalendar(final Date date);\npublic static Calendar toCalendar(final Date date, final TimeZone tz);\npublic static Date round(final Date date, final int field);\npublic static Calendar round(final Calendar date, final int field);\npublic static Date round(final Object date, final int field);\npublic static Date truncate(final Date date, final int field);\npublic static Calendar truncate(final Calendar date, final int field);\npublic static Date truncate(final Object date, final int field);\npublic static Date ceiling(final Date date, final int field);\npublic static Calendar ceiling(final Calendar date, final int field);\npublic static Date ceiling(final Object date, final int field);\nprivate static void modify(final Calendar val, final int field, final ModifyType modType);\npublic static Iterator<Calendar> iterator(final Date focus, final int rangeStyle);\npublic static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle);\npublic static Iterator<?> iterator(final Object focus, final int rangeStyle);\npublic static long getFragmentInMilliseconds(final Date date, final int fragment);\npublic static long getFragmentInSeconds(final Date date, final int fragment);\npublic static long getFragmentInMinutes(final Date date, final int fragment);\npublic static long getFragmentInHours(final Date date, final int fragment);\npublic static long getFragmentInDays(final Date date, final int fragment);\npublic static long getFragmentInMilliseconds(final Calendar calendar, final int fragment);\npublic static long getFragmentInSeconds(final Calendar calendar, final int fragment);\npublic static long getFragmentInMinutes(final Calendar calendar, final int fragment);\npublic static long getFragmentInHours(final Calendar calendar, final int fragment);\npublic static long getFragmentInDays(final Calendar calendar, final int fragment);\nprivate static long getFragment(final Date date, final int fragment, final TimeUnit unit);\nprivate static long getFragment(final Calendar calendar, final int fragment, final TimeUnit unit);\npublic static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field);\npublic static boolean truncatedEquals(final Date date1, final Date date2, final int field);\npublic static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field);\npublic static int truncatedCompareTo(final Date date1, final Date date2, final int field);\nprivate static void validateDateNotNull(final Date date);",
        "Class_name": "DateUtils",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/time/DateUtils###round",
        "Parameter_num": "2",
        "all_Import_statements": "import java.text.ParseException;\n\nimport java.text.ParsePosition;\n\nimport java.util.Calendar;\n\nimport java.util.Date;\n\nimport java.util.Iterator;\n\nimport java.util.Locale;\n\nimport java.util.NoSuchElementException;\n\nimport java.util.TimeZone;\n\nimport java.util.concurrent.TimeUnit;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n\nimport org.apache.commons.lang3.Validate;\n",
        "comment": "\n     * <p>Rounds a date, leaving the field specified as the most\n     * significant field.</p>\n     *\n     * <p>For example, if you had the date-time of 28 Mar 2002\n     * 13:45:01.231, if this was passed with HOUR, it would return\n     * 28 Mar 2002 14:00:00.000. If this was passed with MONTH, it\n     * would return 1 April 2002 0:00:00.000.</p>\n     *\n     * <p>For a date in a timezone that handles the change to daylight\n     * saving time, rounding to Calendar.HOUR_OF_DAY will behave as follows.\n     * Suppose daylight saving time begins at 02:00 on March 30. Rounding a\n     * date that crosses this time would produce the following values:\n     * </p>\n     * <ul>\n     * <li>March 30, 2003 01:10 rounds to March 30, 2003 01:00</li>\n     * <li>March 30, 2003 01:40 rounds to March 30, 2003 03:00</li>\n     * <li>March 30, 2003 02:10 rounds to March 30, 2003 03:00</li>\n     * <li>March 30, 2003 02:40 rounds to March 30, 2003 04:00</li>\n     * </ul>\n     *\n     * @param date  the date to work with, not null\n     * @param field  the field from {@code Calendar} or <code>SEMI_MONTH</code>\n     * @return the different rounded date, not null\n     * @throws IllegalArgumentException if the date is <code>null</code>\n     * @throws ArithmeticException if the year is over 280 million\n     ",
        "packageName": "org.apache.commons.lang3.time",
        "method_signature": "public static Calendar round(final Calendar date, final int field);",
        "Junit_version": "4",
        "returnType": "Calendar"
    },
    {
        "Method_body": "public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) {\n    String duration = formatDuration(durationMillis, \"d' days 'H' hours 'm' minutes 's' seconds'\");\n    if (suppressLeadingZeroElements) {\n        duration = \" \" + duration;\n        String tmp = StringUtils.replaceOnce(duration, \" 0 days\", StringUtils.EMPTY);\n        if (tmp.length() != duration.length()) {\n            duration = tmp;\n            tmp = StringUtils.replaceOnce(duration, \" 0 hours\", StringUtils.EMPTY);\n            if (tmp.length() != duration.length()) {\n                duration = tmp;\n                tmp = StringUtils.replaceOnce(duration, \" 0 minutes\", StringUtils.EMPTY);\n                duration = tmp;\n                if (tmp.length() != duration.length()) {\n                    duration = StringUtils.replaceOnce(tmp, \" 0 seconds\", StringUtils.EMPTY);\n                }\n            }\n        }\n        if (duration.length() != 0) {\n            duration = duration.substring(1);\n        }\n    }\n    if (suppressTrailingZeroElements) {\n        String tmp = StringUtils.replaceOnce(duration, \" 0 seconds\", StringUtils.EMPTY);\n        if (tmp.length() != duration.length()) {\n            duration = tmp;\n            tmp = StringUtils.replaceOnce(duration, \" 0 minutes\", StringUtils.EMPTY);\n            if (tmp.length() != duration.length()) {\n                duration = tmp;\n                tmp = StringUtils.replaceOnce(duration, \" 0 hours\", StringUtils.EMPTY);\n                if (tmp.length() != duration.length()) {\n                    duration = StringUtils.replaceOnce(tmp, \" 0 days\", StringUtils.EMPTY);\n                }\n            }\n        }\n    }\n    duration = \" \" + duration;\n    duration = StringUtils.replaceOnce(duration, \" 1 seconds\", \" 1 second\");\n    duration = StringUtils.replaceOnce(duration, \" 1 minutes\", \" 1 minute\");\n    duration = StringUtils.replaceOnce(duration, \" 1 hours\", \" 1 hour\");\n    duration = StringUtils.replaceOnce(duration, \" 1 days\", \" 1 day\");\n    return duration.trim();\n}",
        "all_field_declaration": "/**\n * <p>Pattern used with <code>FastDateFormat</code> and <code>SimpleDateFormat</code>\n * for the ISO 8601 period format used in durations.</p>\n *\n * @see org.apache.commons.lang3.time.FastDateFormat\n * @see java.text.SimpleDateFormat\n */\npublic static final String ISO_EXTENDED_FORMAT_PATTERN = \"'P'yyyy'Y'M'M'd'DT'H'H'm'M's.SSS'S'\";\nstatic final Object y = \"y\";\nstatic final Object M = \"M\";\nstatic final Object d = \"d\";\nstatic final Object H = \"H\";\nstatic final Object m = \"m\";\nstatic final Object s = \"s\";\nstatic final Object S = \"S\";",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "9",
        "Filed": "static final Object y = \"y\";static final Object M = \"M\";static final Object d = \"d\";static final Object H = \"H\";static final Object m = \"m\";static final Object s = \"s\";static final Object S = \"S\";",
        "Parameter_type": "long,boolean,boolean",
        "Import_statements": "import org.apache.commons.lang3.StringUtils;\n",
        "public_method_signature": "public DurationFormatUtils();\npublic static String formatDurationHMS(final long durationMillis);\npublic static String formatDurationISO(final long durationMillis);\npublic static String formatDuration(final long durationMillis, final String format);\npublic static String formatDuration(final long durationMillis, final String format, final boolean padWithZeros);\npublic static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements);\npublic static String formatPeriodISO(final long startMillis, final long endMillis);\npublic static String formatPeriod(final long startMillis, final long endMillis, final String format);\npublic static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone);",
        "public_field": "/**\n * <p>Pattern used with <code>FastDateFormat</code> and <code>SimpleDateFormat</code>\n * for the ISO 8601 period format used in durations.</p>\n *\n * @see org.apache.commons.lang3.time.FastDateFormat\n * @see java.text.SimpleDateFormat\n */\npublic static final String ISO_EXTENDED_FORMAT_PATTERN = \"'P'yyyy'Y'M'M'd'DT'H'H'm'M's.SSS'S'\";",
        "Method_statement": "formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements)",
        "Method_name": "formatDurationWords",
        "Class_declaration": "public class DurationFormatUtils {\n",
        "constructors": "public DurationFormatUtils() {\n    super();\n}",
        "all_method_signature": "public DurationFormatUtils();\npublic static String formatDurationHMS(final long durationMillis);\npublic static String formatDurationISO(final long durationMillis);\npublic static String formatDuration(final long durationMillis, final String format);\npublic static String formatDuration(final long durationMillis, final String format, final boolean padWithZeros);\npublic static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements);\npublic static String formatPeriodISO(final long startMillis, final long endMillis);\npublic static String formatPeriod(final long startMillis, final long endMillis, final String format);\npublic static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone);\n static String format(final Token[] tokens, final long years, final long months, final long days, final long hours, final long minutes, final long seconds, final long milliseconds, final boolean padWithZeros);\nprivate static String paddedValue(final long value, final boolean padWithZeros, final int count);\n static Token[] lexx(final String format);",
        "Class_name": "DurationFormatUtils",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/time/DurationFormatUtils###formatDurationWords",
        "Parameter_num": "3",
        "all_Import_statements": "import java.util.ArrayList;\n\nimport java.util.Calendar;\n\nimport java.util.Date;\n\nimport java.util.GregorianCalendar;\n\nimport java.util.TimeZone;\n\nimport org.apache.commons.lang3.StringUtils;\n\nimport org.apache.commons.lang3.Validate;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
        "comment": "\n     * <p>Formats an elapsed time into a pluralization correct string.</p>\n     *\n     * <p>This method formats durations using the days and lower fields of the\n     * format pattern. Months and larger are not used.</p>\n     *\n     * @param durationMillis  the elapsed time to report in milliseconds\n     * @param suppressLeadingZeroElements  suppresses leading 0 elements\n     * @param suppressTrailingZeroElements  suppresses trailing 0 elements\n     * @return the formatted text in days/hours/minutes/seconds, not null\n     * @throws java.lang.IllegalArgumentException if durationMillis is negative\n     ",
        "packageName": "org.apache.commons.lang3.time",
        "method_signature": "public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements);",
        "Junit_version": "4",
        "returnType": "String"
    },
    {
        "Method_body": "@GwtIncompatible(\"incompatible method\")\npublic EqualsBuilder reflectionAppend(final Object lhs, final Object rhs) {\n    if (!isEquals) {\n        return this;\n    }\n    if (lhs == rhs) {\n        return this;\n    }\n    if (lhs == null || rhs == null) {\n        isEquals = false;\n        return this;\n    }\n    final Class<?> lhsClass = lhs.getClass();\n    final Class<?> rhsClass = rhs.getClass();\n    Class<?> testClass;\n    if (lhsClass.isInstance(rhs)) {\n        testClass = lhsClass;\n        if (!rhsClass.isInstance(lhs)) {\n            testClass = rhsClass;\n        }\n    } else if (rhsClass.isInstance(lhs)) {\n        testClass = rhsClass;\n        if (!lhsClass.isInstance(rhs)) {\n            testClass = lhsClass;\n        }\n    } else {\n        isEquals = false;\n        return this;\n    }\n    try {\n        if (testClass.isArray()) {\n            append(lhs, rhs);\n        } else {\n            reflectionAppend(lhs, rhs, testClass);\n            while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {\n                testClass = testClass.getSuperclass();\n                reflectionAppend(lhs, rhs, testClass);\n            }\n        }\n    } catch (final IllegalArgumentException e) {\n        isEquals = false;\n        return this;\n    }\n    return this;\n}",
        "all_field_declaration": "/**\n * <p>\n * A registry of objects used by reflection methods to detect cyclical object references and avoid infinite loops.\n * </p>\n *\n * @since 3.0\n */\n@GwtIncompatible(\"incompatible method\")\nprivate static final ThreadLocal<Set<Pair<IDKey, IDKey>>> REGISTRY = new ThreadLocal<>();\nprivate boolean isEquals = true;\nprivate boolean testTransients = false;\nprivate boolean testRecursive = false;\nprivate Class<?> reflectUpToClass = null;\nprivate String[] excludeFields = null;",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "9",
        "Filed": "private boolean isEquals = true;private Class<?> reflectUpToClass = null;",
        "Parameter_type": "Object,Object",
        "Import_statements": "import com.google.gwt.core.shared.GwtIncompatible;\n",
        "public_method_signature": "public EqualsBuilder();\npublic EqualsBuilder setTestTransients(final boolean testTransients);\npublic EqualsBuilder setTestRecursive(final boolean testRecursive);\npublic EqualsBuilder setReflectUpToClass(final Class<?> reflectUpToClass);\npublic EqualsBuilder setExcludeFields(final String... excludeFields);\npublic static boolean reflectionEquals(final Object lhs, final Object rhs, final Collection<String> excludeFields);\npublic static boolean reflectionEquals(final Object lhs, final Object rhs, final String... excludeFields);\npublic static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients);\npublic static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields);\npublic static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final boolean testRecursive, final String... excludeFields);\npublic EqualsBuilder reflectionAppend(final Object lhs, final Object rhs);\npublic EqualsBuilder appendSuper(final boolean superEquals);\npublic EqualsBuilder append(final Object lhs, final Object rhs);\npublic EqualsBuilder append(final long lhs, final long rhs);\npublic EqualsBuilder append(final int lhs, final int rhs);\npublic EqualsBuilder append(final short lhs, final short rhs);\npublic EqualsBuilder append(final char lhs, final char rhs);\npublic EqualsBuilder append(final byte lhs, final byte rhs);\npublic EqualsBuilder append(final double lhs, final double rhs);\npublic EqualsBuilder append(final float lhs, final float rhs);\npublic EqualsBuilder append(final boolean lhs, final boolean rhs);\npublic EqualsBuilder append(final Object[] lhs, final Object[] rhs);\npublic EqualsBuilder append(final long[] lhs, final long[] rhs);\npublic EqualsBuilder append(final int[] lhs, final int[] rhs);\npublic EqualsBuilder append(final short[] lhs, final short[] rhs);\npublic EqualsBuilder append(final char[] lhs, final char[] rhs);\npublic EqualsBuilder append(final byte[] lhs, final byte[] rhs);\npublic EqualsBuilder append(final double[] lhs, final double[] rhs);\npublic EqualsBuilder append(final float[] lhs, final float[] rhs);\npublic EqualsBuilder append(final boolean[] lhs, final boolean[] rhs);\npublic boolean isEquals();\npublic Boolean build();\npublic void reset();",
        "public_field": "",
        "Method_statement": "reflectionAppend(final Object lhs, final Object rhs)",
        "Method_name": "reflectionAppend",
        "Class_declaration": "public class EqualsBuilder {\n",
        "constructors": "public EqualsBuilder() {\n}",
        "all_method_signature": " static Set<Pair<IDKey, IDKey>> getRegistry();\n static Pair<IDKey, IDKey> getRegisterPair(final Object lhs, final Object rhs);\n static boolean isRegistered(final Object lhs, final Object rhs);\nprivate static void register(final Object lhs, final Object rhs);\nprivate static void unregister(final Object lhs, final Object rhs);\npublic EqualsBuilder();\npublic EqualsBuilder setTestTransients(final boolean testTransients);\npublic EqualsBuilder setTestRecursive(final boolean testRecursive);\npublic EqualsBuilder setReflectUpToClass(final Class<?> reflectUpToClass);\npublic EqualsBuilder setExcludeFields(final String... excludeFields);\npublic static boolean reflectionEquals(final Object lhs, final Object rhs, final Collection<String> excludeFields);\npublic static boolean reflectionEquals(final Object lhs, final Object rhs, final String... excludeFields);\npublic static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients);\npublic static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields);\npublic static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final boolean testRecursive, final String... excludeFields);\npublic EqualsBuilder reflectionAppend(final Object lhs, final Object rhs);\nprivate void reflectionAppend(final Object lhs, final Object rhs, final Class<?> clazz);\npublic EqualsBuilder appendSuper(final boolean superEquals);\npublic EqualsBuilder append(final Object lhs, final Object rhs);\nprivate void appendArray(final Object lhs, final Object rhs);\npublic EqualsBuilder append(final long lhs, final long rhs);\npublic EqualsBuilder append(final int lhs, final int rhs);\npublic EqualsBuilder append(final short lhs, final short rhs);\npublic EqualsBuilder append(final char lhs, final char rhs);\npublic EqualsBuilder append(final byte lhs, final byte rhs);\npublic EqualsBuilder append(final double lhs, final double rhs);\npublic EqualsBuilder append(final float lhs, final float rhs);\npublic EqualsBuilder append(final boolean lhs, final boolean rhs);\npublic EqualsBuilder append(final Object[] lhs, final Object[] rhs);\npublic EqualsBuilder append(final long[] lhs, final long[] rhs);\npublic EqualsBuilder append(final int[] lhs, final int[] rhs);\npublic EqualsBuilder append(final short[] lhs, final short[] rhs);\npublic EqualsBuilder append(final char[] lhs, final char[] rhs);\npublic EqualsBuilder append(final byte[] lhs, final byte[] rhs);\npublic EqualsBuilder append(final double[] lhs, final double[] rhs);\npublic EqualsBuilder append(final float[] lhs, final float[] rhs);\npublic EqualsBuilder append(final boolean[] lhs, final boolean[] rhs);\npublic boolean isEquals();\npublic Boolean build();\nprotected void setEquals(final boolean isEquals);\npublic void reset();",
        "Class_name": "EqualsBuilder",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/builder/EqualsBuilder###reflectionAppend",
        "Parameter_num": "2",
        "all_Import_statements": "import java.lang.reflect.AccessibleObject;\n\nimport java.lang.reflect.Field;\n\nimport java.lang.reflect.Modifier;\n\nimport java.util.Collection;\n\nimport java.util.HashSet;\n\nimport java.util.Set;\n\nimport org.apache.commons.lang3.ArrayUtils;\n\nimport org.apache.commons.lang3.ClassUtils;\n\nimport org.apache.commons.lang3.tuple.Pair;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
        "comment": "\n     * <p>Tests if two <code>objects</code> by using reflection.</p>\n     *\n     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n     * fields. This means that it will throw a security exception if run under\n     * a security manager, if the permissions are not set up correctly. It is also\n     * not as efficient as testing explicitly. Non-primitive fields are compared using\n     * <code>equals()</code>.</p>\n     *\n     * <p>If the testTransients field is set to <code>true</code>, transient\n     * members will be tested, otherwise they are ignored, as they are likely\n     * derived fields, and not part of the value of the <code>Object</code>.</p>\n     *\n     * <p>Static fields will not be included. Superclass fields will be appended\n     * up to and including the specified superclass in field <code>reflectUpToClass</code>.\n     * A null superclass is treated as java.lang.Object.</p>\n     *\n     * <p>Field names listed in field <code>excludeFields</code> will be ignored.</p>\n     *\n     * @param lhs  the left hand object\n     * @param rhs  the left hand object\n     * @return EqualsBuilder - used to chain calls.\n     ",
        "packageName": "org.apache.commons.lang3.builder",
        "method_signature": "public EqualsBuilder reflectionAppend(final Object lhs, final Object rhs);",
        "Junit_version": "4",
        "returnType": "EqualsBuilder"
    },
    {
        "Method_body": "@Override\npublic String format(final Date date) {\n    final Calendar c = newCalendar();\n    c.setTime(date);\n    return applyRulesToString(c);\n}",
        "all_field_declaration": "// A lot of the speed in this class comes from caching, but some comes\n// from the special int to StringBuffer conversion.\n// \n// The following produces a padded 2 digit number:\n// buffer.append((char)(value / 10 + '0'));\n// buffer.append((char)(value % 10 + '0'));\n// \n// Note that the fastest append to StringBuffer is a single char (used here).\n// Note that Integer.toString() is not called, the conversion is simply\n// taking the value and adding (mathematically) the ASCII value for '0'.\n// So, don't change this code! It works and is very fast.\n/**\n * Required for serialization support.\n *\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = 1L;\n/**\n * FULL locale dependent date or time style.\n */\npublic static final int FULL = DateFormat.FULL;\n/**\n * LONG locale dependent date or time style.\n */\npublic static final int LONG = DateFormat.LONG;\n/**\n * MEDIUM locale dependent date or time style.\n */\npublic static final int MEDIUM = DateFormat.MEDIUM;\n/**\n * SHORT locale dependent date or time style.\n */\npublic static final int SHORT = DateFormat.SHORT;\n/**\n * The pattern.\n */\nprivate final String mPattern;\n/**\n * The time zone.\n */\nprivate final TimeZone mTimeZone;\n/**\n * The locale.\n */\nprivate final Locale mLocale;\n/**\n * The parsed rules.\n */\nprivate transient Rule[] mRules;\n/**\n * The estimated maximum length.\n */\nprivate transient int mMaxLengthEstimate;\nprivate static final int MAX_DIGITS = 10;\nprivate static final ConcurrentMap<TimeZoneDisplayKey, String> cTimeZoneDisplayCache = new ConcurrentHashMap<>(7);",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "3",
        "Filed": "",
        "Parameter_type": "Date",
        "Import_statements": "import java.util.Calendar;\nimport java.util.Date;\n",
        "public_method_signature": "public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos);\npublic String format(final long millis);\npublic String format(final Date date);\npublic String format(final Calendar calendar);\npublic StringBuffer format(final long millis, final StringBuffer buf);\npublic StringBuffer format(final Date date, final StringBuffer buf);\npublic StringBuffer format(final Calendar calendar, final StringBuffer buf);\npublic B format(final long millis, final B buf);\npublic B format(final Date date, final B buf);\npublic B format(Calendar calendar, final B buf);\npublic String getPattern();\npublic TimeZone getTimeZone();\npublic Locale getLocale();\npublic int getMaxLengthEstimate();\npublic boolean equals(final Object obj);\npublic int hashCode();\npublic String toString();",
        "public_field": "/**\n * FULL locale dependent date or time style.\n */\npublic static final int FULL = DateFormat.FULL;\n/**\n * LONG locale dependent date or time style.\n */\npublic static final int LONG = DateFormat.LONG;\n/**\n * MEDIUM locale dependent date or time style.\n */\npublic static final int MEDIUM = DateFormat.MEDIUM;\n/**\n * SHORT locale dependent date or time style.\n */\npublic static final int SHORT = DateFormat.SHORT;",
        "Method_statement": "format(final Date date)",
        "Method_name": "format",
        "Class_declaration": "public class FastDatePrinter {\n",
        "constructors": "protected FastDatePrinter(final String pattern, final TimeZone timeZone, final Locale locale) {\n    mPattern = pattern;\n    mTimeZone = timeZone;\n    mLocale = locale;\n    init();\n}",
        "all_method_signature": "protected FastDatePrinter(final String pattern, final TimeZone timeZone, final Locale locale);\nprivate void init();\nprotected List<Rule> parsePattern();\nprotected String parseToken(final String pattern, final int[] indexRef);\nprotected NumberRule selectNumberRule(final int field, final int padding);\npublic StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos);\n String format(final Object obj);\npublic String format(final long millis);\nprivate String applyRulesToString(final Calendar c);\nprivate Calendar newCalendar();\npublic String format(final Date date);\npublic String format(final Calendar calendar);\npublic StringBuffer format(final long millis, final StringBuffer buf);\npublic StringBuffer format(final Date date, final StringBuffer buf);\npublic StringBuffer format(final Calendar calendar, final StringBuffer buf);\npublic B format(final long millis, final B buf);\npublic B format(final Date date, final B buf);\npublic B format(Calendar calendar, final B buf);\nprotected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf);\nprivate B applyRules(final Calendar calendar, final B buf);\npublic String getPattern();\npublic TimeZone getTimeZone();\npublic Locale getLocale();\npublic int getMaxLengthEstimate();\npublic boolean equals(final Object obj);\npublic int hashCode();\npublic String toString();\nprivate void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException;\nprivate static void appendDigits(final Appendable buffer, final int value) throws IOException;\nprivate static void appendFullDigits(final Appendable buffer, int value, int minFieldWidth) throws IOException;\n static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale);",
        "Class_name": "FastDatePrinter",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/time/FastDatePrinter###format",
        "Parameter_num": "1",
        "all_Import_statements": "import java.io.IOException;\n\nimport java.io.ObjectInputStream;\n\nimport java.io.Serializable;\n\nimport java.text.DateFormat;\n\nimport java.text.DateFormatSymbols;\n\nimport java.text.FieldPosition;\n\nimport java.util.ArrayList;\n\nimport java.util.Calendar;\n\nimport java.util.Date;\n\nimport java.util.List;\n\nimport java.util.Locale;\n\nimport java.util.TimeZone;\n\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport java.util.concurrent.ConcurrentMap;\n\nimport org.apache.commons.lang3.exception.ExceptionUtils;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
        "comment": " (non-Javadoc)\n     * @see org.apache.commons.lang3.time.DatePrinter#format(java.util.Date)\n     ",
        "packageName": "org.apache.commons.lang3.time",
        "method_signature": "public String format(final Date date);",
        "Junit_version": "4",
        "returnType": "String"
    },
    {
        "Method_body": "public static List<Field> getFieldsListWithAnnotation(final Class<?> cls, final Class<? extends Annotation> annotationCls) {\n    Validate.isTrue(annotationCls != null, \"The annotation class must not be null\");\n    final List<Field> allFields = getAllFieldsList(cls);\n    final List<Field> annotatedFields = new ArrayList<>();\n    for (final Field field : allFields) {\n        if (field.getAnnotation(annotationCls) != null) {\n            annotatedFields.add(field);\n        }\n    }\n    return annotatedFields;\n}",
        "all_field_declaration": "",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "5",
        "Filed": "",
        "Parameter_type": "Class<?>,Class<? extends Annotation>",
        "Import_statements": "import org.apache.commons.lang3.Validate;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.List;\n",
        "public_method_signature": "public FieldUtils();\npublic static Field getField(final Class<?> cls, final String fieldName);\npublic static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess);\npublic static Field getDeclaredField(final Class<?> cls, final String fieldName);\npublic static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess);\npublic static Field[] getAllFields(final Class<?> cls);\npublic static List<Field> getAllFieldsList(final Class<?> cls);\npublic static Field[] getFieldsWithAnnotation(final Class<?> cls, final Class<? extends Annotation> annotationCls);\npublic static List<Field> getFieldsListWithAnnotation(final Class<?> cls, final Class<? extends Annotation> annotationCls);\npublic static Object readStaticField(final Field field) throws IllegalAccessException;\npublic static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException;\npublic static Object readStaticField(final Class<?> cls, final String fieldName) throws IllegalAccessException;\npublic static Object readStaticField(final Class<?> cls, final String fieldName, final boolean forceAccess) throws IllegalAccessException;\npublic static Object readDeclaredStaticField(final Class<?> cls, final String fieldName) throws IllegalAccessException;\npublic static Object readDeclaredStaticField(final Class<?> cls, final String fieldName, final boolean forceAccess) throws IllegalAccessException;\npublic static Object readField(final Field field, final Object target) throws IllegalAccessException;\npublic static Object readField(final Field field, final Object target, final boolean forceAccess) throws IllegalAccessException;\npublic static Object readField(final Object target, final String fieldName) throws IllegalAccessException;\npublic static Object readField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException;\npublic static Object readDeclaredField(final Object target, final String fieldName) throws IllegalAccessException;\npublic static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException;\npublic static void writeStaticField(final Field field, final Object value) throws IllegalAccessException;\npublic static void writeStaticField(final Field field, final Object value, final boolean forceAccess) throws IllegalAccessException;\npublic static void writeStaticField(final Class<?> cls, final String fieldName, final Object value) throws IllegalAccessException;\npublic static void writeStaticField(final Class<?> cls, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException;\npublic static void writeDeclaredStaticField(final Class<?> cls, final String fieldName, final Object value) throws IllegalAccessException;\npublic static void writeDeclaredStaticField(final Class<?> cls, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException;\npublic static void writeField(final Field field, final Object target, final Object value) throws IllegalAccessException;\npublic static void writeField(final Field field, final Object target, final Object value, final boolean forceAccess) throws IllegalAccessException;\npublic static void removeFinalModifier(final Field field);\npublic static void removeFinalModifier(final Field field, final boolean forceAccess);\npublic static void writeField(final Object target, final String fieldName, final Object value) throws IllegalAccessException;\npublic static void writeField(final Object target, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException;\npublic static void writeDeclaredField(final Object target, final String fieldName, final Object value) throws IllegalAccessException;\npublic static void writeDeclaredField(final Object target, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException;",
        "public_field": "",
        "Method_statement": "getFieldsListWithAnnotation(final Class<?> cls, final Class<? extends Annotation> annotationCls)",
        "Method_name": "getFieldsListWithAnnotation",
        "Class_declaration": "public class FieldUtils {\n",
        "constructors": "public FieldUtils() {\n    super();\n}",
        "all_method_signature": "public FieldUtils();\npublic static Field getField(final Class<?> cls, final String fieldName);\npublic static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess);\npublic static Field getDeclaredField(final Class<?> cls, final String fieldName);\npublic static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess);\npublic static Field[] getAllFields(final Class<?> cls);\npublic static List<Field> getAllFieldsList(final Class<?> cls);\npublic static Field[] getFieldsWithAnnotation(final Class<?> cls, final Class<? extends Annotation> annotationCls);\npublic static List<Field> getFieldsListWithAnnotation(final Class<?> cls, final Class<? extends Annotation> annotationCls);\npublic static Object readStaticField(final Field field) throws IllegalAccessException;\npublic static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException;\npublic static Object readStaticField(final Class<?> cls, final String fieldName) throws IllegalAccessException;\npublic static Object readStaticField(final Class<?> cls, final String fieldName, final boolean forceAccess) throws IllegalAccessException;\npublic static Object readDeclaredStaticField(final Class<?> cls, final String fieldName) throws IllegalAccessException;\npublic static Object readDeclaredStaticField(final Class<?> cls, final String fieldName, final boolean forceAccess) throws IllegalAccessException;\npublic static Object readField(final Field field, final Object target) throws IllegalAccessException;\npublic static Object readField(final Field field, final Object target, final boolean forceAccess) throws IllegalAccessException;\npublic static Object readField(final Object target, final String fieldName) throws IllegalAccessException;\npublic static Object readField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException;\npublic static Object readDeclaredField(final Object target, final String fieldName) throws IllegalAccessException;\npublic static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException;\npublic static void writeStaticField(final Field field, final Object value) throws IllegalAccessException;\npublic static void writeStaticField(final Field field, final Object value, final boolean forceAccess) throws IllegalAccessException;\npublic static void writeStaticField(final Class<?> cls, final String fieldName, final Object value) throws IllegalAccessException;\npublic static void writeStaticField(final Class<?> cls, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException;\npublic static void writeDeclaredStaticField(final Class<?> cls, final String fieldName, final Object value) throws IllegalAccessException;\npublic static void writeDeclaredStaticField(final Class<?> cls, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException;\npublic static void writeField(final Field field, final Object target, final Object value) throws IllegalAccessException;\npublic static void writeField(final Field field, final Object target, final Object value, final boolean forceAccess) throws IllegalAccessException;\npublic static void removeFinalModifier(final Field field);\npublic static void removeFinalModifier(final Field field, final boolean forceAccess);\npublic static void writeField(final Object target, final String fieldName, final Object value) throws IllegalAccessException;\npublic static void writeField(final Object target, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException;\npublic static void writeDeclaredField(final Object target, final String fieldName, final Object value) throws IllegalAccessException;\npublic static void writeDeclaredField(final Object target, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException;",
        "Class_name": "FieldUtils",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/reflect/FieldUtils###getFieldsListWithAnnotation",
        "Parameter_num": "2",
        "all_Import_statements": "import org.apache.commons.lang3.ClassUtils;\n\nimport org.apache.commons.lang3.StringUtils;\n\nimport org.apache.commons.lang3.Validate;\n\nimport java.lang.annotation.Annotation;\n\nimport java.lang.reflect.Field;\n\nimport java.lang.reflect.Modifier;\n\nimport java.util.ArrayList;\n\nimport java.util.Collections;\n\nimport java.util.List;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
        "comment": "\n     * Gets all fields of the given class and its parents (if any) that are annotated with the given annotation.\n     * @param cls\n     *            the {@link Class} to query\n     * @param annotationCls\n     *            the {@link Annotation} that must be present on a field to be matched\n     * @return a list of Fields (possibly empty).\n     * @throws IllegalArgumentException\n     *            if the class or annotation are {@code null}\n     * @since 3.4\n     ",
        "packageName": "org.apache.commons.lang3.reflect",
        "method_signature": "public static List<Field> getFieldsListWithAnnotation(final Class<?> cls, final Class<? extends Annotation> annotationCls);",
        "Junit_version": "4",
        "returnType": "List<Field>"
    },
    {
        "Method_body": "@Override\npublic boolean equals(final Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof Fraction)) {\n        return false;\n    }\n    final Fraction other = (Fraction) obj;\n    return getNumerator() == other.getNumerator() && getDenominator() == other.getDenominator();\n}",
        "all_field_declaration": "/**\n * Required for serialization support. Lang version 2.0.\n *\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = 65382027393090L;\n/**\n * <code>Fraction</code> representation of 0.\n */\npublic static final Fraction ZERO = new Fraction(0, 1);\n/**\n * <code>Fraction</code> representation of 1.\n */\npublic static final Fraction ONE = new Fraction(1, 1);\n/**\n * <code>Fraction</code> representation of 1/2.\n */\npublic static final Fraction ONE_HALF = new Fraction(1, 2);\n/**\n * <code>Fraction</code> representation of 1/3.\n */\npublic static final Fraction ONE_THIRD = new Fraction(1, 3);\n/**\n * <code>Fraction</code> representation of 2/3.\n */\npublic static final Fraction TWO_THIRDS = new Fraction(2, 3);\n/**\n * <code>Fraction</code> representation of 1/4.\n */\npublic static final Fraction ONE_QUARTER = new Fraction(1, 4);\n/**\n * <code>Fraction</code> representation of 2/4.\n */\npublic static final Fraction TWO_QUARTERS = new Fraction(2, 4);\n/**\n * <code>Fraction</code> representation of 3/4.\n */\npublic static final Fraction THREE_QUARTERS = new Fraction(3, 4);\n/**\n * <code>Fraction</code> representation of 1/5.\n */\npublic static final Fraction ONE_FIFTH = new Fraction(1, 5);\n/**\n * <code>Fraction</code> representation of 2/5.\n */\npublic static final Fraction TWO_FIFTHS = new Fraction(2, 5);\n/**\n * <code>Fraction</code> representation of 3/5.\n */\npublic static final Fraction THREE_FIFTHS = new Fraction(3, 5);\n/**\n * <code>Fraction</code> representation of 4/5.\n */\npublic static final Fraction FOUR_FIFTHS = new Fraction(4, 5);\n/**\n * The numerator number part of the fraction (the three in three sevenths).\n */\nprivate final int numerator;\n/**\n * The denominator number part of the fraction (the seven in three sevenths).\n */\nprivate final int denominator;\n/**\n * Cached output hashCode (class is immutable).\n */\nprivate transient int hashCode = 0;\n/**\n * Cached output toString (class is immutable).\n */\nprivate transient String toString = null;\n/**\n * Cached output toProperString (class is immutable).\n */\nprivate transient String toProperString = null;",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "4",
        "Filed": "",
        "Parameter_type": "Object",
        "Import_statements": "",
        "public_method_signature": "public static Fraction getFraction(int numerator, int denominator);\npublic static Fraction getFraction(final int whole, final int numerator, final int denominator);\npublic static Fraction getReducedFraction(int numerator, int denominator);\npublic static Fraction getFraction(double value);\npublic static Fraction getFraction(String str);\npublic int getNumerator();\npublic int getDenominator();\npublic int getProperNumerator();\npublic int getProperWhole();\npublic int intValue();\npublic long longValue();\npublic float floatValue();\npublic double doubleValue();\npublic Fraction reduce();\npublic Fraction invert();\npublic Fraction negate();\npublic Fraction abs();\npublic Fraction pow(final int power);\npublic Fraction add(final Fraction fraction);\npublic Fraction subtract(final Fraction fraction);\npublic Fraction multiplyBy(final Fraction fraction);\npublic Fraction divideBy(final Fraction fraction);\npublic boolean equals(final Object obj);\npublic int hashCode();\npublic int compareTo(final Fraction other);\npublic String toString();\npublic String toProperString();",
        "public_field": "/**\n * <code>Fraction</code> representation of 0.\n */\npublic static final Fraction ZERO = new Fraction(0, 1);\n/**\n * <code>Fraction</code> representation of 1.\n */\npublic static final Fraction ONE = new Fraction(1, 1);\n/**\n * <code>Fraction</code> representation of 1/2.\n */\npublic static final Fraction ONE_HALF = new Fraction(1, 2);\n/**\n * <code>Fraction</code> representation of 1/3.\n */\npublic static final Fraction ONE_THIRD = new Fraction(1, 3);\n/**\n * <code>Fraction</code> representation of 2/3.\n */\npublic static final Fraction TWO_THIRDS = new Fraction(2, 3);\n/**\n * <code>Fraction</code> representation of 1/4.\n */\npublic static final Fraction ONE_QUARTER = new Fraction(1, 4);\n/**\n * <code>Fraction</code> representation of 2/4.\n */\npublic static final Fraction TWO_QUARTERS = new Fraction(2, 4);\n/**\n * <code>Fraction</code> representation of 3/4.\n */\npublic static final Fraction THREE_QUARTERS = new Fraction(3, 4);\n/**\n * <code>Fraction</code> representation of 1/5.\n */\npublic static final Fraction ONE_FIFTH = new Fraction(1, 5);\n/**\n * <code>Fraction</code> representation of 2/5.\n */\npublic static final Fraction TWO_FIFTHS = new Fraction(2, 5);\n/**\n * <code>Fraction</code> representation of 3/5.\n */\npublic static final Fraction THREE_FIFTHS = new Fraction(3, 5);\n/**\n * <code>Fraction</code> representation of 4/5.\n */\npublic static final Fraction FOUR_FIFTHS = new Fraction(4, 5);",
        "Method_statement": "equals(final Object obj)",
        "Method_name": "equals",
        "Class_declaration": "public  final class Fraction {\n",
        "constructors": "private Fraction(final int numerator, final int denominator) {\n    super();\n    this.numerator = numerator;\n    this.denominator = denominator;\n}",
        "all_method_signature": "private Fraction(final int numerator, final int denominator);\npublic static Fraction getFraction(int numerator, int denominator);\npublic static Fraction getFraction(final int whole, final int numerator, final int denominator);\npublic static Fraction getReducedFraction(int numerator, int denominator);\npublic static Fraction getFraction(double value);\npublic static Fraction getFraction(String str);\npublic int getNumerator();\npublic int getDenominator();\npublic int getProperNumerator();\npublic int getProperWhole();\npublic int intValue();\npublic long longValue();\npublic float floatValue();\npublic double doubleValue();\npublic Fraction reduce();\npublic Fraction invert();\npublic Fraction negate();\npublic Fraction abs();\npublic Fraction pow(final int power);\nprivate static int greatestCommonDivisor(int u, int v);\nprivate static int mulAndCheck(final int x, final int y);\nprivate static int mulPosAndCheck(final int x, final int y);\nprivate static int addAndCheck(final int x, final int y);\nprivate static int subAndCheck(final int x, final int y);\npublic Fraction add(final Fraction fraction);\npublic Fraction subtract(final Fraction fraction);\nprivate Fraction addSub(final Fraction fraction, final boolean isAdd);\npublic Fraction multiplyBy(final Fraction fraction);\npublic Fraction divideBy(final Fraction fraction);\npublic boolean equals(final Object obj);\npublic int hashCode();\npublic int compareTo(final Fraction other);\npublic String toString();\npublic String toProperString();",
        "Class_name": "Fraction",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/math/Fraction###equals",
        "Parameter_num": "1",
        "all_Import_statements": "import java.math.BigInteger;\n\nimport org.apache.commons.lang3.Validate;\n",
        "comment": "\n     * <p>Compares this fraction to another object to test if they are equal.</p>.\n     *\n     * <p>To be equal, both values must be equal. Thus 2/4 is not equal to 1/2.</p>\n     *\n     * @param obj the reference object with which to compare\n     * @return <code>true</code> if this object is equal\n     ",
        "packageName": "org.apache.commons.lang3.math",
        "method_signature": "public boolean equals(final Object obj);",
        "Junit_version": "4",
        "returnType": "boolean"
    },
    {
        "Method_body": "public Fraction reduce() {\n    if (numerator == 0) {\n        return equals(ZERO) ? this : ZERO;\n    }\n    final int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);\n    if (gcd == 1) {\n        return this;\n    }\n    return Fraction.getFraction(numerator / gcd, denominator / gcd);\n}",
        "all_field_declaration": "/**\n * Required for serialization support. Lang version 2.0.\n *\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = 65382027393090L;\n/**\n * <code>Fraction</code> representation of 0.\n */\npublic static final Fraction ZERO = new Fraction(0, 1);\n/**\n * <code>Fraction</code> representation of 1.\n */\npublic static final Fraction ONE = new Fraction(1, 1);\n/**\n * <code>Fraction</code> representation of 1/2.\n */\npublic static final Fraction ONE_HALF = new Fraction(1, 2);\n/**\n * <code>Fraction</code> representation of 1/3.\n */\npublic static final Fraction ONE_THIRD = new Fraction(1, 3);\n/**\n * <code>Fraction</code> representation of 2/3.\n */\npublic static final Fraction TWO_THIRDS = new Fraction(2, 3);\n/**\n * <code>Fraction</code> representation of 1/4.\n */\npublic static final Fraction ONE_QUARTER = new Fraction(1, 4);\n/**\n * <code>Fraction</code> representation of 2/4.\n */\npublic static final Fraction TWO_QUARTERS = new Fraction(2, 4);\n/**\n * <code>Fraction</code> representation of 3/4.\n */\npublic static final Fraction THREE_QUARTERS = new Fraction(3, 4);\n/**\n * <code>Fraction</code> representation of 1/5.\n */\npublic static final Fraction ONE_FIFTH = new Fraction(1, 5);\n/**\n * <code>Fraction</code> representation of 2/5.\n */\npublic static final Fraction TWO_FIFTHS = new Fraction(2, 5);\n/**\n * <code>Fraction</code> representation of 3/5.\n */\npublic static final Fraction THREE_FIFTHS = new Fraction(3, 5);\n/**\n * <code>Fraction</code> representation of 4/5.\n */\npublic static final Fraction FOUR_FIFTHS = new Fraction(4, 5);\n/**\n * The numerator number part of the fraction (the three in three sevenths).\n */\nprivate final int numerator;\n/**\n * The denominator number part of the fraction (the seven in three sevenths).\n */\nprivate final int denominator;\n/**\n * Cached output hashCode (class is immutable).\n */\nprivate transient int hashCode = 0;\n/**\n * Cached output toString (class is immutable).\n */\nprivate transient String toString = null;\n/**\n * Cached output toProperString (class is immutable).\n */\nprivate transient String toProperString = null;",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "4",
        "Filed": "public static final Fraction ZERO = new Fraction(0, 1);private final int numerator;private final int denominator;",
        "Parameter_type": "",
        "Import_statements": "",
        "public_method_signature": "public static Fraction getFraction(int numerator, int denominator);\npublic static Fraction getFraction(final int whole, final int numerator, final int denominator);\npublic static Fraction getReducedFraction(int numerator, int denominator);\npublic static Fraction getFraction(double value);\npublic static Fraction getFraction(String str);\npublic int getNumerator();\npublic int getDenominator();\npublic int getProperNumerator();\npublic int getProperWhole();\npublic int intValue();\npublic long longValue();\npublic float floatValue();\npublic double doubleValue();\npublic Fraction reduce();\npublic Fraction invert();\npublic Fraction negate();\npublic Fraction abs();\npublic Fraction pow(final int power);\npublic Fraction add(final Fraction fraction);\npublic Fraction subtract(final Fraction fraction);\npublic Fraction multiplyBy(final Fraction fraction);\npublic Fraction divideBy(final Fraction fraction);\npublic boolean equals(final Object obj);\npublic int hashCode();\npublic int compareTo(final Fraction other);\npublic String toString();\npublic String toProperString();",
        "public_field": "/**\n * <code>Fraction</code> representation of 0.\n */\npublic static final Fraction ZERO = new Fraction(0, 1);\n/**\n * <code>Fraction</code> representation of 1.\n */\npublic static final Fraction ONE = new Fraction(1, 1);\n/**\n * <code>Fraction</code> representation of 1/2.\n */\npublic static final Fraction ONE_HALF = new Fraction(1, 2);\n/**\n * <code>Fraction</code> representation of 1/3.\n */\npublic static final Fraction ONE_THIRD = new Fraction(1, 3);\n/**\n * <code>Fraction</code> representation of 2/3.\n */\npublic static final Fraction TWO_THIRDS = new Fraction(2, 3);\n/**\n * <code>Fraction</code> representation of 1/4.\n */\npublic static final Fraction ONE_QUARTER = new Fraction(1, 4);\n/**\n * <code>Fraction</code> representation of 2/4.\n */\npublic static final Fraction TWO_QUARTERS = new Fraction(2, 4);\n/**\n * <code>Fraction</code> representation of 3/4.\n */\npublic static final Fraction THREE_QUARTERS = new Fraction(3, 4);\n/**\n * <code>Fraction</code> representation of 1/5.\n */\npublic static final Fraction ONE_FIFTH = new Fraction(1, 5);\n/**\n * <code>Fraction</code> representation of 2/5.\n */\npublic static final Fraction TWO_FIFTHS = new Fraction(2, 5);\n/**\n * <code>Fraction</code> representation of 3/5.\n */\npublic static final Fraction THREE_FIFTHS = new Fraction(3, 5);\n/**\n * <code>Fraction</code> representation of 4/5.\n */\npublic static final Fraction FOUR_FIFTHS = new Fraction(4, 5);",
        "Method_statement": "reduce()",
        "Method_name": "reduce",
        "Class_declaration": "public  final class Fraction {\n",
        "constructors": "private Fraction(final int numerator, final int denominator) {\n    super();\n    this.numerator = numerator;\n    this.denominator = denominator;\n}",
        "all_method_signature": "private Fraction(final int numerator, final int denominator);\npublic static Fraction getFraction(int numerator, int denominator);\npublic static Fraction getFraction(final int whole, final int numerator, final int denominator);\npublic static Fraction getReducedFraction(int numerator, int denominator);\npublic static Fraction getFraction(double value);\npublic static Fraction getFraction(String str);\npublic int getNumerator();\npublic int getDenominator();\npublic int getProperNumerator();\npublic int getProperWhole();\npublic int intValue();\npublic long longValue();\npublic float floatValue();\npublic double doubleValue();\npublic Fraction reduce();\npublic Fraction invert();\npublic Fraction negate();\npublic Fraction abs();\npublic Fraction pow(final int power);\nprivate static int greatestCommonDivisor(int u, int v);\nprivate static int mulAndCheck(final int x, final int y);\nprivate static int mulPosAndCheck(final int x, final int y);\nprivate static int addAndCheck(final int x, final int y);\nprivate static int subAndCheck(final int x, final int y);\npublic Fraction add(final Fraction fraction);\npublic Fraction subtract(final Fraction fraction);\nprivate Fraction addSub(final Fraction fraction, final boolean isAdd);\npublic Fraction multiplyBy(final Fraction fraction);\npublic Fraction divideBy(final Fraction fraction);\npublic boolean equals(final Object obj);\npublic int hashCode();\npublic int compareTo(final Fraction other);\npublic String toString();\npublic String toProperString();",
        "Class_name": "Fraction",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/math/Fraction###reduce",
        "Parameter_num": "0",
        "all_Import_statements": "import java.math.BigInteger;\n\nimport org.apache.commons.lang3.Validate;\n",
        "comment": "\n     * <p>Reduce the fraction to the smallest values for the numerator and\n     * denominator, returning the result.</p>\n     *\n     * <p>For example, if this fraction represents 2/4, then the result\n     * will be 1/2.</p>\n     *\n     * @return a new reduced fraction instance, or this if no simplification possible\n     ",
        "packageName": "org.apache.commons.lang3.math",
        "method_signature": "public Fraction reduce();",
        "Junit_version": "4",
        "returnType": "Fraction"
    },
    {
        "Method_body": "public byte getAndDecrement() {\n    final byte last = value;\n    value--;\n    return last;\n}",
        "all_field_declaration": "/**\n * Required for serialization support.\n *\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = -1585823265L;\n/**\n * The mutable value.\n */\nprivate byte value;",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "3",
        "Filed": "private byte value;",
        "Parameter_type": "",
        "Import_statements": "",
        "public_method_signature": "public MutableByte();\npublic MutableByte(final byte value);\npublic MutableByte(final Number value);\npublic MutableByte(final String value) throws NumberFormatException;\npublic Byte getValue();\npublic void setValue(final byte value);\npublic void setValue(final Number value);\npublic void increment();\npublic byte getAndIncrement();\npublic byte incrementAndGet();\npublic void decrement();\npublic byte getAndDecrement();\npublic byte decrementAndGet();\npublic void add(final byte operand);\npublic void add(final Number operand);\npublic void subtract(final byte operand);\npublic void subtract(final Number operand);\npublic byte addAndGet(final byte operand);\npublic byte addAndGet(final Number operand);\npublic byte getAndAdd(final byte operand);\npublic byte getAndAdd(final Number operand);\npublic byte byteValue();\npublic int intValue();\npublic long longValue();\npublic float floatValue();\npublic double doubleValue();\npublic Byte toByte();\npublic boolean equals(final Object obj);\npublic int hashCode();\npublic int compareTo(final MutableByte other);\npublic String toString();",
        "public_field": "",
        "Method_statement": "getAndDecrement()",
        "Method_name": "getAndDecrement",
        "Class_declaration": "public class MutableByte {\n",
        "constructors": "public MutableByte() {\n    super();\n}public MutableByte(final byte value) {\n    super();\n    this.value = value;\n}public MutableByte(final Number value) {\n    super();\n    this.value = value.byteValue();\n}public MutableByte(final String value) throws NumberFormatException {\n    super();\n    this.value = Byte.parseByte(value);\n}",
        "all_method_signature": "public MutableByte();\npublic MutableByte(final byte value);\npublic MutableByte(final Number value);\npublic MutableByte(final String value) throws NumberFormatException;\npublic Byte getValue();\npublic void setValue(final byte value);\npublic void setValue(final Number value);\npublic void increment();\npublic byte getAndIncrement();\npublic byte incrementAndGet();\npublic void decrement();\npublic byte getAndDecrement();\npublic byte decrementAndGet();\npublic void add(final byte operand);\npublic void add(final Number operand);\npublic void subtract(final byte operand);\npublic void subtract(final Number operand);\npublic byte addAndGet(final byte operand);\npublic byte addAndGet(final Number operand);\npublic byte getAndAdd(final byte operand);\npublic byte getAndAdd(final Number operand);\npublic byte byteValue();\npublic int intValue();\npublic long longValue();\npublic float floatValue();\npublic double doubleValue();\npublic Byte toByte();\npublic boolean equals(final Object obj);\npublic int hashCode();\npublic int compareTo(final MutableByte other);\npublic String toString();",
        "Class_name": "MutableByte",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/mutable/MutableByte###getAndDecrement",
        "Parameter_num": "0",
        "all_Import_statements": "import org.apache.commons.lang3.math.NumberUtils;\n",
        "comment": "\n     * Decrements this instance's value by 1; this method returns the value associated with the instance\n     * immediately prior to the decrement operation. This method is not thread safe.\n     *\n     * @return the value associated with the instance before it was decremented\n     * @since 3.5\n     ",
        "packageName": "org.apache.commons.lang3.mutable",
        "method_signature": "public byte getAndDecrement();",
        "Junit_version": "4",
        "returnType": "byte"
    },
    {
        "Method_body": "public int getAndDecrement() {\n    final int last = value;\n    value--;\n    return last;\n}",
        "all_field_declaration": "/**\n * Required for serialization support.\n *\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = 512176391864L;\n/**\n * The mutable value.\n */\nprivate int value;",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "3",
        "Filed": "private int value;",
        "Parameter_type": "",
        "Import_statements": "",
        "public_method_signature": "public MutableInt();\npublic MutableInt(final int value);\npublic MutableInt(final Number value);\npublic MutableInt(final String value) throws NumberFormatException;\npublic Integer getValue();\npublic void setValue(final int value);\npublic void setValue(final Number value);\npublic void increment();\npublic int getAndIncrement();\npublic int incrementAndGet();\npublic void decrement();\npublic int getAndDecrement();\npublic int decrementAndGet();\npublic void add(final int operand);\npublic void add(final Number operand);\npublic void subtract(final int operand);\npublic void subtract(final Number operand);\npublic int addAndGet(final int operand);\npublic int addAndGet(final Number operand);\npublic int getAndAdd(final int operand);\npublic int getAndAdd(final Number operand);\npublic int intValue();\npublic long longValue();\npublic float floatValue();\npublic double doubleValue();\npublic Integer toInteger();\npublic boolean equals(final Object obj);\npublic int hashCode();\npublic int compareTo(final MutableInt other);\npublic String toString();",
        "public_field": "",
        "Method_statement": "getAndDecrement()",
        "Method_name": "getAndDecrement",
        "Class_declaration": "public class MutableInt {\n",
        "constructors": "public MutableInt() {\n    super();\n}public MutableInt(final int value) {\n    super();\n    this.value = value;\n}public MutableInt(final Number value) {\n    super();\n    this.value = value.intValue();\n}public MutableInt(final String value) throws NumberFormatException {\n    super();\n    this.value = Integer.parseInt(value);\n}",
        "all_method_signature": "public MutableInt();\npublic MutableInt(final int value);\npublic MutableInt(final Number value);\npublic MutableInt(final String value) throws NumberFormatException;\npublic Integer getValue();\npublic void setValue(final int value);\npublic void setValue(final Number value);\npublic void increment();\npublic int getAndIncrement();\npublic int incrementAndGet();\npublic void decrement();\npublic int getAndDecrement();\npublic int decrementAndGet();\npublic void add(final int operand);\npublic void add(final Number operand);\npublic void subtract(final int operand);\npublic void subtract(final Number operand);\npublic int addAndGet(final int operand);\npublic int addAndGet(final Number operand);\npublic int getAndAdd(final int operand);\npublic int getAndAdd(final Number operand);\npublic int intValue();\npublic long longValue();\npublic float floatValue();\npublic double doubleValue();\npublic Integer toInteger();\npublic boolean equals(final Object obj);\npublic int hashCode();\npublic int compareTo(final MutableInt other);\npublic String toString();",
        "Class_name": "MutableInt",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/mutable/MutableInt###getAndDecrement",
        "Parameter_num": "0",
        "all_Import_statements": "import org.apache.commons.lang3.math.NumberUtils;\n",
        "comment": "\n     * Decrements this instance's value by 1; this method returns the value associated with the instance\n     * immediately prior to the decrement operation. This method is not thread safe.\n     *\n     * @return the value associated with the instance before it was decremented\n     * @since 3.5\n     ",
        "packageName": "org.apache.commons.lang3.mutable",
        "method_signature": "public int getAndDecrement();",
        "Junit_version": "4",
        "returnType": "int"
    },
    {
        "Method_body": "public static BigInteger createBigInteger(final String str) {\n    if (str == null) {\n        return null;\n    }\n    int pos = 0;\n    int radix = 10;\n    boolean negate = false;\n    if (str.startsWith(\"-\")) {\n        negate = true;\n        pos = 1;\n    }\n    if (str.startsWith(\"0x\", pos) || str.startsWith(\"0X\", pos)) {\n        radix = 16;\n        pos += 2;\n    } else if (str.startsWith(\"#\", pos)) {\n        radix = 16;\n        pos++;\n    } else if (str.startsWith(\"0\", pos) && str.length() > pos + 1) {\n        radix = 8;\n        pos++;\n    }\n    final BigInteger value = new BigInteger(str.substring(pos), radix);\n    return negate ? value.negate() : value;\n}",
        "all_field_declaration": "/**\n * Reusable Long constant for zero.\n */\npublic static final Long LONG_ZERO = Long.valueOf(0L);\n/**\n * Reusable Long constant for one.\n */\npublic static final Long LONG_ONE = Long.valueOf(1L);\n/**\n * Reusable Long constant for minus one.\n */\npublic static final Long LONG_MINUS_ONE = Long.valueOf(-1L);\n/**\n * Reusable Integer constant for zero.\n */\npublic static final Integer INTEGER_ZERO = Integer.valueOf(0);\n/**\n * Reusable Integer constant for one.\n */\npublic static final Integer INTEGER_ONE = Integer.valueOf(1);\n/**\n * Reusable Integer constant for minus one.\n */\npublic static final Integer INTEGER_MINUS_ONE = Integer.valueOf(-1);\n/**\n * Reusable Short constant for zero.\n */\npublic static final Short SHORT_ZERO = Short.valueOf((short) 0);\n/**\n * Reusable Short constant for one.\n */\npublic static final Short SHORT_ONE = Short.valueOf((short) 1);\n/**\n * Reusable Short constant for minus one.\n */\npublic static final Short SHORT_MINUS_ONE = Short.valueOf((short) -1);\n/**\n * Reusable Byte constant for zero.\n */\npublic static final Byte BYTE_ZERO = Byte.valueOf((byte) 0);\n/**\n * Reusable Byte constant for one.\n */\npublic static final Byte BYTE_ONE = Byte.valueOf((byte) 1);\n/**\n * Reusable Byte constant for minus one.\n */\npublic static final Byte BYTE_MINUS_ONE = Byte.valueOf((byte) -1);\n/**\n * Reusable Double constant for zero.\n */\npublic static final Double DOUBLE_ZERO = Double.valueOf(0.0d);\n/**\n * Reusable Double constant for one.\n */\npublic static final Double DOUBLE_ONE = Double.valueOf(1.0d);\n/**\n * Reusable Double constant for minus one.\n */\npublic static final Double DOUBLE_MINUS_ONE = Double.valueOf(-1.0d);\n/**\n * Reusable Float constant for zero.\n */\npublic static final Float FLOAT_ZERO = Float.valueOf(0.0f);\n/**\n * Reusable Float constant for one.\n */\npublic static final Float FLOAT_ONE = Float.valueOf(1.0f);\n/**\n * Reusable Float constant for minus one.\n */\npublic static final Float FLOAT_MINUS_ONE = Float.valueOf(-1.0f);",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "8",
        "Filed": "",
        "Parameter_type": "String",
        "Import_statements": "import java.math.BigInteger;\n",
        "public_method_signature": "public NumberUtils();\npublic static int toInt(final String str);\npublic static int toInt(final String str, final int defaultValue);\npublic static long toLong(final String str);\npublic static long toLong(final String str, final long defaultValue);\npublic static float toFloat(final String str);\npublic static float toFloat(final String str, final float defaultValue);\npublic static double toDouble(final String str);\npublic static double toDouble(final String str, final double defaultValue);\npublic static byte toByte(final String str);\npublic static byte toByte(final String str, final byte defaultValue);\npublic static short toShort(final String str);\npublic static short toShort(final String str, final short defaultValue);\npublic static Number createNumber(final String str) throws NumberFormatException;\npublic static Float createFloat(final String str);\npublic static Double createDouble(final String str);\npublic static Integer createInteger(final String str);\npublic static Long createLong(final String str);\npublic static BigInteger createBigInteger(final String str);\npublic static BigDecimal createBigDecimal(final String str);\npublic static long min(final long... array);\npublic static int min(final int... array);\npublic static short min(final short... array);\npublic static byte min(final byte... array);\npublic static double min(final double... array);\npublic static float min(final float... array);\npublic static long max(final long... array);\npublic static int max(final int... array);\npublic static short max(final short... array);\npublic static byte max(final byte... array);\npublic static double max(final double... array);\npublic static float max(final float... array);\npublic static long min(long a, final long b, final long c);\npublic static int min(int a, final int b, final int c);\npublic static short min(short a, final short b, final short c);\npublic static byte min(byte a, final byte b, final byte c);\npublic static double min(final double a, final double b, final double c);\npublic static float min(final float a, final float b, final float c);\npublic static long max(long a, final long b, final long c);\npublic static int max(int a, final int b, final int c);\npublic static short max(short a, final short b, final short c);\npublic static byte max(byte a, final byte b, final byte c);\npublic static double max(final double a, final double b, final double c);\npublic static float max(final float a, final float b, final float c);\npublic static boolean isDigits(final String str);\npublic static boolean isNumber(final String str);\npublic static boolean isCreatable(final String str);\npublic static boolean isParsable(final String str);\npublic static int compare(final int x, final int y);\npublic static int compare(final long x, final long y);\npublic static int compare(final short x, final short y);\npublic static int compare(final byte x, final byte y);",
        "public_field": "/**\n * Reusable Long constant for zero.\n */\npublic static final Long LONG_ZERO = Long.valueOf(0L);\n/**\n * Reusable Long constant for one.\n */\npublic static final Long LONG_ONE = Long.valueOf(1L);\n/**\n * Reusable Long constant for minus one.\n */\npublic static final Long LONG_MINUS_ONE = Long.valueOf(-1L);\n/**\n * Reusable Integer constant for zero.\n */\npublic static final Integer INTEGER_ZERO = Integer.valueOf(0);\n/**\n * Reusable Integer constant for one.\n */\npublic static final Integer INTEGER_ONE = Integer.valueOf(1);\n/**\n * Reusable Integer constant for minus one.\n */\npublic static final Integer INTEGER_MINUS_ONE = Integer.valueOf(-1);\n/**\n * Reusable Short constant for zero.\n */\npublic static final Short SHORT_ZERO = Short.valueOf((short) 0);\n/**\n * Reusable Short constant for one.\n */\npublic static final Short SHORT_ONE = Short.valueOf((short) 1);\n/**\n * Reusable Short constant for minus one.\n */\npublic static final Short SHORT_MINUS_ONE = Short.valueOf((short) -1);\n/**\n * Reusable Byte constant for zero.\n */\npublic static final Byte BYTE_ZERO = Byte.valueOf((byte) 0);\n/**\n * Reusable Byte constant for one.\n */\npublic static final Byte BYTE_ONE = Byte.valueOf((byte) 1);\n/**\n * Reusable Byte constant for minus one.\n */\npublic static final Byte BYTE_MINUS_ONE = Byte.valueOf((byte) -1);\n/**\n * Reusable Double constant for zero.\n */\npublic static final Double DOUBLE_ZERO = Double.valueOf(0.0d);\n/**\n * Reusable Double constant for one.\n */\npublic static final Double DOUBLE_ONE = Double.valueOf(1.0d);\n/**\n * Reusable Double constant for minus one.\n */\npublic static final Double DOUBLE_MINUS_ONE = Double.valueOf(-1.0d);\n/**\n * Reusable Float constant for zero.\n */\npublic static final Float FLOAT_ZERO = Float.valueOf(0.0f);\n/**\n * Reusable Float constant for one.\n */\npublic static final Float FLOAT_ONE = Float.valueOf(1.0f);\n/**\n * Reusable Float constant for minus one.\n */\npublic static final Float FLOAT_MINUS_ONE = Float.valueOf(-1.0f);",
        "Method_statement": "createBigInteger(final String str)",
        "Method_name": "createBigInteger",
        "Class_declaration": "public class NumberUtils {\n",
        "constructors": "public NumberUtils() {\n    super();\n}",
        "all_method_signature": "public NumberUtils();\npublic static int toInt(final String str);\npublic static int toInt(final String str, final int defaultValue);\npublic static long toLong(final String str);\npublic static long toLong(final String str, final long defaultValue);\npublic static float toFloat(final String str);\npublic static float toFloat(final String str, final float defaultValue);\npublic static double toDouble(final String str);\npublic static double toDouble(final String str, final double defaultValue);\npublic static byte toByte(final String str);\npublic static byte toByte(final String str, final byte defaultValue);\npublic static short toShort(final String str);\npublic static short toShort(final String str, final short defaultValue);\npublic static Number createNumber(final String str) throws NumberFormatException;\nprivate static String getMantissa(final String str);\nprivate static String getMantissa(final String str, final int stopPos);\nprivate static boolean isAllZeros(final String str);\npublic static Float createFloat(final String str);\npublic static Double createDouble(final String str);\npublic static Integer createInteger(final String str);\npublic static Long createLong(final String str);\npublic static BigInteger createBigInteger(final String str);\npublic static BigDecimal createBigDecimal(final String str);\npublic static long min(final long... array);\npublic static int min(final int... array);\npublic static short min(final short... array);\npublic static byte min(final byte... array);\npublic static double min(final double... array);\npublic static float min(final float... array);\npublic static long max(final long... array);\npublic static int max(final int... array);\npublic static short max(final short... array);\npublic static byte max(final byte... array);\npublic static double max(final double... array);\npublic static float max(final float... array);\nprivate static void validateArray(final long[] array);\nprivate static void validateArray(final int[] array);\nprivate static void validateArray(final short[] array);\nprivate static void validateArray(final byte[] array);\nprivate static void validateArray(final double[] array);\nprivate static void validateArray(final float[] array);\npublic static long min(long a, final long b, final long c);\npublic static int min(int a, final int b, final int c);\npublic static short min(short a, final short b, final short c);\npublic static byte min(byte a, final byte b, final byte c);\npublic static double min(final double a, final double b, final double c);\npublic static float min(final float a, final float b, final float c);\npublic static long max(long a, final long b, final long c);\npublic static int max(int a, final int b, final int c);\npublic static short max(short a, final short b, final short c);\npublic static byte max(byte a, final byte b, final byte c);\npublic static double max(final double a, final double b, final double c);\npublic static float max(final float a, final float b, final float c);\npublic static boolean isDigits(final String str);\npublic static boolean isNumber(final String str);\npublic static boolean isCreatable(final String str);\npublic static boolean isParsable(final String str);\nprivate static boolean withDecimalsParsing(final String str, final int beginIdx);\npublic static int compare(final int x, final int y);\npublic static int compare(final long x, final long y);\npublic static int compare(final short x, final short y);\npublic static int compare(final byte x, final byte y);",
        "Class_name": "NumberUtils",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/math/NumberUtils###createBigInteger",
        "Parameter_num": "1",
        "all_Import_statements": "import java.lang.reflect.Array;\n\nimport java.math.BigDecimal;\n\nimport java.math.BigInteger;\n\nimport org.apache.commons.lang3.StringUtils;\n\nimport org.apache.commons.lang3.Validate;\n",
        "comment": "\n     * <p>Convert a <code>String</code> to a <code>BigInteger</code>;\n     * since 3.2 it handles hex (0x or #) and octal (0) notations.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>BigInteger</code> (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     ",
        "packageName": "org.apache.commons.lang3.math",
        "method_signature": "public static BigInteger createBigInteger(final String str);",
        "Junit_version": "4",
        "returnType": "BigInteger"
    },
    {
        "Method_body": "@Override\npublic int hashCode() {\n    int result = hashCode;\n    if (hashCode == 0) {\n        result = 17;\n        result = 37 * result + getClass().hashCode();\n        result = 37 * result + minimum.hashCode();\n        result = 37 * result + maximum.hashCode();\n        hashCode = result;\n    }\n    return result;\n}",
        "all_field_declaration": "/**\n * Serialization version.\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = 1L;\n/**\n * The ordering scheme used in this range.\n */\nprivate final Comparator<T> comparator;\n/**\n * The minimum value in this range (inclusive).\n */\nprivate final T minimum;\n/**\n * The maximum value in this range (inclusive).\n */\nprivate final T maximum;\n/**\n * Cached output hashCode (class is immutable).\n */\nprivate transient int hashCode;\n/**\n * Cached output toString (class is immutable).\n */\nprivate transient String toString;",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "3",
        "Filed": "private final T minimum;private final T maximum;private transient int hashCode;",
        "Parameter_type": "",
        "Import_statements": "",
        "public_method_signature": "public static Range<T> is(final T element);\npublic static Range<T> is(final T element, final Comparator<T> comparator);\npublic static Range<T> between(final T fromInclusive, final T toInclusive);\npublic static Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator);\npublic T getMinimum();\npublic T getMaximum();\npublic Comparator<T> getComparator();\npublic boolean isNaturalOrdering();\npublic boolean contains(final T element);\npublic boolean isAfter(final T element);\npublic boolean isStartedBy(final T element);\npublic boolean isEndedBy(final T element);\npublic boolean isBefore(final T element);\npublic int elementCompareTo(final T element);\npublic boolean containsRange(final Range<T> otherRange);\npublic boolean isAfterRange(final Range<T> otherRange);\npublic boolean isOverlappedBy(final Range<T> otherRange);\npublic boolean isBeforeRange(final Range<T> otherRange);\npublic Range<T> intersectionWith(final Range<T> other);\npublic boolean equals(final Object obj);\npublic int hashCode();\npublic String toString();\npublic String toString(final String format);",
        "public_field": "",
        "Method_statement": "hashCode()",
        "Method_name": "hashCode",
        "Class_declaration": "public  final class Range {\n",
        "constructors": "@SuppressWarnings(\"unchecked\")\nprivate Range(final T element1, final T element2, final Comparator<T> comp) {\n    if (element1 == null || element2 == null) {\n        throw new IllegalArgumentException(\"Elements in a range must not be null: element1=\" + element1 + \", element2=\" + element2);\n    }\n    if (comp == null) {\n        this.comparator = ComparableComparator.INSTANCE;\n    } else {\n        this.comparator = comp;\n    }\n    if (this.comparator.compare(element1, element2) < 1) {\n        this.minimum = element1;\n        this.maximum = element2;\n    } else {\n        this.minimum = element2;\n        this.maximum = element1;\n    }\n}",
        "all_method_signature": "public static Range<T> is(final T element);\npublic static Range<T> is(final T element, final Comparator<T> comparator);\npublic static Range<T> between(final T fromInclusive, final T toInclusive);\npublic static Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator);\nprivate Range(final T element1, final T element2, final Comparator<T> comp);\npublic T getMinimum();\npublic T getMaximum();\npublic Comparator<T> getComparator();\npublic boolean isNaturalOrdering();\npublic boolean contains(final T element);\npublic boolean isAfter(final T element);\npublic boolean isStartedBy(final T element);\npublic boolean isEndedBy(final T element);\npublic boolean isBefore(final T element);\npublic int elementCompareTo(final T element);\npublic boolean containsRange(final Range<T> otherRange);\npublic boolean isAfterRange(final Range<T> otherRange);\npublic boolean isOverlappedBy(final Range<T> otherRange);\npublic boolean isBeforeRange(final Range<T> otherRange);\npublic Range<T> intersectionWith(final Range<T> other);\npublic boolean equals(final Object obj);\npublic int hashCode();\npublic String toString();\npublic String toString(final String format);",
        "Class_name": "Range",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Range###hashCode",
        "Parameter_num": "0",
        "all_Import_statements": "import java.io.Serializable;\n\nimport java.util.Comparator;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
        "comment": "\n     * <p>Gets a suitable hash code for the range.</p>\n     *\n     * @return a hash code value for this object\n     ",
        "packageName": "org.apache.commons.lang3",
        "method_signature": "public int hashCode();",
        "Junit_version": "4",
        "returnType": "int"
    },
    {
        "Method_body": "public static <T extends Serializable> T clone(final T object) {\n    if (object == null) {\n        return null;\n    }\n    final byte[] objectData = serialize(object);\n    final ByteArrayInputStream bais = new ByteArrayInputStream(objectData);\n    try (ClassLoaderAwareObjectInputStream in = new ClassLoaderAwareObjectInputStream(bais, object.getClass().getClassLoader())) {\n        @SuppressWarnings(\"unchecked\")\n        final T readObject = (T) in.readObject();\n        return readObject;\n    } catch (final ClassNotFoundException ex) {\n        throw new SerializationException(\"ClassNotFoundException while reading cloned object data\", ex);\n    } catch (final IOException ex) {\n        throw new SerializationException(\"IOException while reading or closing cloned object data\", ex);\n    }\n}",
        "all_field_declaration": "",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "4",
        "Filed": "",
        "Parameter_type": "T",
        "Import_statements": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectInputStream;\nimport java.io.Serializable;\n",
        "public_method_signature": "public SerializationUtils();\npublic static T clone(final T object);\npublic static T roundtrip(final T msg);\npublic static void serialize(final Serializable obj, final OutputStream outputStream);\npublic static byte[] serialize(final Serializable obj);\npublic static T deserialize(final InputStream inputStream);\npublic static T deserialize(final byte[] objectData);",
        "public_field": "",
        "Method_statement": "clone(final T object)",
        "Method_name": "clone",
        "Class_declaration": "public class SerializationUtils {\n",
        "constructors": "public SerializationUtils() {\n    super();\n}",
        "all_method_signature": "public SerializationUtils();\npublic static T clone(final T object);\npublic static T roundtrip(final T msg);\npublic static void serialize(final Serializable obj, final OutputStream outputStream);\npublic static byte[] serialize(final Serializable obj);\npublic static T deserialize(final InputStream inputStream);\npublic static T deserialize(final byte[] objectData);",
        "Class_name": "SerializationUtils",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/SerializationUtils###clone",
        "Parameter_num": "1",
        "all_Import_statements": "import java.io.ByteArrayInputStream;\n\nimport java.io.ByteArrayOutputStream;\n\nimport java.io.IOException;\n\nimport java.io.InputStream;\n\nimport java.io.ObjectInputStream;\n\nimport java.io.ObjectOutputStream;\n\nimport java.io.ObjectStreamClass;\n\nimport java.io.OutputStream;\n\nimport java.io.Serializable;\n\nimport java.util.HashMap;\n\nimport java.util.Map;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
        "comment": "\n     * <p>Deep clone an {@code Object} using serialization.</p>\n     *\n     * <p>This is many times slower than writing clone methods by hand\n     * on all objects in your object graph. However, for complex object\n     * graphs, or for those that don't support deep cloning this can\n     * be a simple alternative implementation. Of course all the objects\n     * must be {@code Serializable}.</p>\n     *\n     * @param <T> the type of the object involved\n     * @param object  the {@code Serializable} object to clone\n     * @return the cloned object\n     * @throws SerializationException (runtime) if the serialization fails\n     ",
        "packageName": "org.apache.commons.lang3",
        "method_signature": "public static T clone(final T object);",
        "Junit_version": "4",
        "returnType": "T"
    },
    {
        "Method_body": "public StrBuilder setCharAt(final int index, final char ch) {\n    if (index < 0 || index >= length()) {\n        throw new StringIndexOutOfBoundsException(index);\n    }\n    buffer[index] = ch;\n    return this;\n}",
        "all_field_declaration": "/**\n * The extra capacity for new builders.\n */\nstatic final int CAPACITY = 32;\n/**\n * Required for serialization support.\n *\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = 7628716375283629643L;\n/**\n * Internal data storage.\n */\n// TODO make private?\nprotected char[] buffer;\n/**\n * Current size of the buffer.\n */\n// TODO make private?\nprotected int size;\n/**\n * The new line.\n */\nprivate String newLine;\n/**\n * The null text.\n */\nprivate String nullText;",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "3",
        "Filed": "protected char[] buffer;",
        "Parameter_type": "int,char",
        "Import_statements": "import org.apache.commons.lang3.builder.Builder;\n",
        "public_method_signature": "public StrBuilder();\npublic StrBuilder(int initialCapacity);\npublic StrBuilder(final String str);\npublic String getNewLineText();\npublic StrBuilder setNewLineText(final String newLine);\npublic String getNullText();\npublic StrBuilder setNullText(String nullText);\npublic int length();\npublic StrBuilder setLength(final int length);\npublic int capacity();\npublic StrBuilder ensureCapacity(final int capacity);\npublic StrBuilder minimizeCapacity();\npublic int size();\npublic boolean isEmpty();\npublic StrBuilder clear();\npublic char charAt(final int index);\npublic StrBuilder setCharAt(final int index, final char ch);\npublic StrBuilder deleteCharAt(final int index);\npublic char[] toCharArray();\npublic char[] toCharArray(final int startIndex, int endIndex);\npublic char[] getChars(char[] destination);\npublic void getChars(final int startIndex, final int endIndex, final char[] destination, final int destinationIndex);\npublic int readFrom(final Readable readable) throws IOException;\npublic StrBuilder appendNewLine();\npublic StrBuilder appendNull();\npublic StrBuilder append(final Object obj);\npublic StrBuilder append(final CharSequence seq);\npublic StrBuilder append(final CharSequence seq, final int startIndex, final int length);\npublic StrBuilder append(final String str);\npublic StrBuilder append(final String str, final int startIndex, final int length);\npublic StrBuilder append(final String format, final Object... objs);\npublic StrBuilder append(final CharBuffer buf);\npublic StrBuilder append(final CharBuffer buf, final int startIndex, final int length);\npublic StrBuilder append(final StringBuffer str);\npublic StrBuilder append(final StringBuffer str, final int startIndex, final int length);\npublic StrBuilder append(final StringBuilder str);\npublic StrBuilder append(final StringBuilder str, final int startIndex, final int length);\npublic StrBuilder append(final StrBuilder str);\npublic StrBuilder append(final StrBuilder str, final int startIndex, final int length);\npublic StrBuilder append(final char[] chars);\npublic StrBuilder append(final char[] chars, final int startIndex, final int length);\npublic StrBuilder append(final boolean value);\npublic StrBuilder append(final char ch);\npublic StrBuilder append(final int value);\npublic StrBuilder append(final long value);\npublic StrBuilder append(final float value);\npublic StrBuilder append(final double value);\npublic StrBuilder appendln(final Object obj);\npublic StrBuilder appendln(final String str);\npublic StrBuilder appendln(final String str, final int startIndex, final int length);\npublic StrBuilder appendln(final String format, final Object... objs);\npublic StrBuilder appendln(final StringBuffer str);\npublic StrBuilder appendln(final StringBuilder str);\npublic StrBuilder appendln(final StringBuilder str, final int startIndex, final int length);\npublic StrBuilder appendln(final StringBuffer str, final int startIndex, final int length);\npublic StrBuilder appendln(final StrBuilder str);\npublic StrBuilder appendln(final StrBuilder str, final int startIndex, final int length);\npublic StrBuilder appendln(final char[] chars);\npublic StrBuilder appendln(final char[] chars, final int startIndex, final int length);\npublic StrBuilder appendln(final boolean value);\npublic StrBuilder appendln(final char ch);\npublic StrBuilder appendln(final int value);\npublic StrBuilder appendln(final long value);\npublic StrBuilder appendln(final float value);\npublic StrBuilder appendln(final double value);\npublic StrBuilder appendAll(@SuppressWarnings(\"unchecked\") final T... array);\npublic StrBuilder appendAll(final Iterable<?> iterable);\npublic StrBuilder appendAll(final Iterator<?> it);\npublic StrBuilder appendWithSeparators(final Object[] array, final String separator);\npublic StrBuilder appendWithSeparators(final Iterable<?> iterable, final String separator);\npublic StrBuilder appendWithSeparators(final Iterator<?> it, final String separator);\npublic StrBuilder appendSeparator(final String separator);\npublic StrBuilder appendSeparator(final String standard, final String defaultIfEmpty);\npublic StrBuilder appendSeparator(final char separator);\npublic StrBuilder appendSeparator(final char standard, final char defaultIfEmpty);\npublic StrBuilder appendSeparator(final String separator, final int loopIndex);\npublic StrBuilder appendSeparator(final char separator, final int loopIndex);\npublic StrBuilder appendPadding(final int length, final char padChar);\npublic StrBuilder appendFixedWidthPadLeft(final Object obj, final int width, final char padChar);\npublic StrBuilder appendFixedWidthPadLeft(final int value, final int width, final char padChar);\npublic StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar);\npublic StrBuilder appendFixedWidthPadRight(final int value, final int width, final char padChar);\npublic StrBuilder insert(final int index, final Object obj);\npublic StrBuilder insert(final int index, String str);\npublic StrBuilder insert(final int index, final char[] chars);\npublic StrBuilder insert(final int index, final char[] chars, final int offset, final int length);\npublic StrBuilder insert(int index, final boolean value);\npublic StrBuilder insert(final int index, final char value);\npublic StrBuilder insert(final int index, final int value);\npublic StrBuilder insert(final int index, final long value);\npublic StrBuilder insert(final int index, final float value);\npublic StrBuilder insert(final int index, final double value);\npublic StrBuilder delete(final int startIndex, int endIndex);\npublic StrBuilder deleteAll(final char ch);\npublic StrBuilder deleteFirst(final char ch);\npublic StrBuilder deleteAll(final String str);\npublic StrBuilder deleteFirst(final String str);\npublic StrBuilder deleteAll(final StrMatcher matcher);\npublic StrBuilder deleteFirst(final StrMatcher matcher);\npublic StrBuilder replace(final int startIndex, int endIndex, final String replaceStr);\npublic StrBuilder replaceAll(final char search, final char replace);\npublic StrBuilder replaceFirst(final char search, final char replace);\npublic StrBuilder replaceAll(final String searchStr, final String replaceStr);\npublic StrBuilder replaceFirst(final String searchStr, final String replaceStr);\npublic StrBuilder replaceAll(final StrMatcher matcher, final String replaceStr);\npublic StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr);\npublic StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount);\npublic StrBuilder reverse();\npublic StrBuilder trim();\npublic boolean startsWith(final String str);\npublic boolean endsWith(final String str);\npublic CharSequence subSequence(final int startIndex, final int endIndex);\npublic String substring(final int start);\npublic String substring(final int startIndex, int endIndex);\npublic String leftString(final int length);\npublic String rightString(final int length);\npublic String midString(int index, final int length);\npublic boolean contains(final char ch);\npublic boolean contains(final String str);\npublic boolean contains(final StrMatcher matcher);\npublic int indexOf(final char ch);\npublic int indexOf(final char ch, int startIndex);\npublic int indexOf(final String str);\npublic int indexOf(final String str, int startIndex);\npublic int indexOf(final StrMatcher matcher);\npublic int indexOf(final StrMatcher matcher, int startIndex);\npublic int lastIndexOf(final char ch);\npublic int lastIndexOf(final char ch, int startIndex);\npublic int lastIndexOf(final String str);\npublic int lastIndexOf(final String str, int startIndex);\npublic int lastIndexOf(final StrMatcher matcher);\npublic int lastIndexOf(final StrMatcher matcher, int startIndex);\npublic StrTokenizer asTokenizer();\npublic Reader asReader();\npublic Writer asWriter();\npublic void appendTo(final Appendable appendable) throws IOException;\npublic boolean equalsIgnoreCase(final StrBuilder other);\npublic boolean equals(final StrBuilder other);\npublic boolean equals(final Object obj);\npublic int hashCode();\npublic String toString();\npublic StringBuffer toStringBuffer();\npublic StringBuilder toStringBuilder();\npublic String build();",
        "public_field": "",
        "Method_statement": "setCharAt(final int index, final char ch)",
        "Method_name": "setCharAt",
        "Class_declaration": "public class StrBuilder {\n",
        "constructors": "public StrBuilder() {\n    this(CAPACITY);\n}public StrBuilder(int initialCapacity) {\n    super();\n    if (initialCapacity <= 0) {\n        initialCapacity = CAPACITY;\n    }\n    buffer = new char[initialCapacity];\n}public StrBuilder(final String str) {\n    super();\n    if (str == null) {\n        buffer = new char[CAPACITY];\n    } else {\n        buffer = new char[str.length() + CAPACITY];\n        append(str);\n    }\n}",
        "all_method_signature": "public StrBuilder();\npublic StrBuilder(int initialCapacity);\npublic StrBuilder(final String str);\npublic String getNewLineText();\npublic StrBuilder setNewLineText(final String newLine);\npublic String getNullText();\npublic StrBuilder setNullText(String nullText);\npublic int length();\npublic StrBuilder setLength(final int length);\npublic int capacity();\npublic StrBuilder ensureCapacity(final int capacity);\npublic StrBuilder minimizeCapacity();\npublic int size();\npublic boolean isEmpty();\npublic StrBuilder clear();\npublic char charAt(final int index);\npublic StrBuilder setCharAt(final int index, final char ch);\npublic StrBuilder deleteCharAt(final int index);\npublic char[] toCharArray();\npublic char[] toCharArray(final int startIndex, int endIndex);\npublic char[] getChars(char[] destination);\npublic void getChars(final int startIndex, final int endIndex, final char[] destination, final int destinationIndex);\npublic int readFrom(final Readable readable) throws IOException;\npublic StrBuilder appendNewLine();\npublic StrBuilder appendNull();\npublic StrBuilder append(final Object obj);\npublic StrBuilder append(final CharSequence seq);\npublic StrBuilder append(final CharSequence seq, final int startIndex, final int length);\npublic StrBuilder append(final String str);\npublic StrBuilder append(final String str, final int startIndex, final int length);\npublic StrBuilder append(final String format, final Object... objs);\npublic StrBuilder append(final CharBuffer buf);\npublic StrBuilder append(final CharBuffer buf, final int startIndex, final int length);\npublic StrBuilder append(final StringBuffer str);\npublic StrBuilder append(final StringBuffer str, final int startIndex, final int length);\npublic StrBuilder append(final StringBuilder str);\npublic StrBuilder append(final StringBuilder str, final int startIndex, final int length);\npublic StrBuilder append(final StrBuilder str);\npublic StrBuilder append(final StrBuilder str, final int startIndex, final int length);\npublic StrBuilder append(final char[] chars);\npublic StrBuilder append(final char[] chars, final int startIndex, final int length);\npublic StrBuilder append(final boolean value);\npublic StrBuilder append(final char ch);\npublic StrBuilder append(final int value);\npublic StrBuilder append(final long value);\npublic StrBuilder append(final float value);\npublic StrBuilder append(final double value);\npublic StrBuilder appendln(final Object obj);\npublic StrBuilder appendln(final String str);\npublic StrBuilder appendln(final String str, final int startIndex, final int length);\npublic StrBuilder appendln(final String format, final Object... objs);\npublic StrBuilder appendln(final StringBuffer str);\npublic StrBuilder appendln(final StringBuilder str);\npublic StrBuilder appendln(final StringBuilder str, final int startIndex, final int length);\npublic StrBuilder appendln(final StringBuffer str, final int startIndex, final int length);\npublic StrBuilder appendln(final StrBuilder str);\npublic StrBuilder appendln(final StrBuilder str, final int startIndex, final int length);\npublic StrBuilder appendln(final char[] chars);\npublic StrBuilder appendln(final char[] chars, final int startIndex, final int length);\npublic StrBuilder appendln(final boolean value);\npublic StrBuilder appendln(final char ch);\npublic StrBuilder appendln(final int value);\npublic StrBuilder appendln(final long value);\npublic StrBuilder appendln(final float value);\npublic StrBuilder appendln(final double value);\npublic StrBuilder appendAll(@SuppressWarnings(\"unchecked\") final T... array);\npublic StrBuilder appendAll(final Iterable<?> iterable);\npublic StrBuilder appendAll(final Iterator<?> it);\npublic StrBuilder appendWithSeparators(final Object[] array, final String separator);\npublic StrBuilder appendWithSeparators(final Iterable<?> iterable, final String separator);\npublic StrBuilder appendWithSeparators(final Iterator<?> it, final String separator);\npublic StrBuilder appendSeparator(final String separator);\npublic StrBuilder appendSeparator(final String standard, final String defaultIfEmpty);\npublic StrBuilder appendSeparator(final char separator);\npublic StrBuilder appendSeparator(final char standard, final char defaultIfEmpty);\npublic StrBuilder appendSeparator(final String separator, final int loopIndex);\npublic StrBuilder appendSeparator(final char separator, final int loopIndex);\npublic StrBuilder appendPadding(final int length, final char padChar);\npublic StrBuilder appendFixedWidthPadLeft(final Object obj, final int width, final char padChar);\npublic StrBuilder appendFixedWidthPadLeft(final int value, final int width, final char padChar);\npublic StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar);\npublic StrBuilder appendFixedWidthPadRight(final int value, final int width, final char padChar);\npublic StrBuilder insert(final int index, final Object obj);\npublic StrBuilder insert(final int index, String str);\npublic StrBuilder insert(final int index, final char[] chars);\npublic StrBuilder insert(final int index, final char[] chars, final int offset, final int length);\npublic StrBuilder insert(int index, final boolean value);\npublic StrBuilder insert(final int index, final char value);\npublic StrBuilder insert(final int index, final int value);\npublic StrBuilder insert(final int index, final long value);\npublic StrBuilder insert(final int index, final float value);\npublic StrBuilder insert(final int index, final double value);\nprivate void deleteImpl(final int startIndex, final int endIndex, final int len);\npublic StrBuilder delete(final int startIndex, int endIndex);\npublic StrBuilder deleteAll(final char ch);\npublic StrBuilder deleteFirst(final char ch);\npublic StrBuilder deleteAll(final String str);\npublic StrBuilder deleteFirst(final String str);\npublic StrBuilder deleteAll(final StrMatcher matcher);\npublic StrBuilder deleteFirst(final StrMatcher matcher);\nprivate void replaceImpl(final int startIndex, final int endIndex, final int removeLen, final String insertStr, final int insertLen);\npublic StrBuilder replace(final int startIndex, int endIndex, final String replaceStr);\npublic StrBuilder replaceAll(final char search, final char replace);\npublic StrBuilder replaceFirst(final char search, final char replace);\npublic StrBuilder replaceAll(final String searchStr, final String replaceStr);\npublic StrBuilder replaceFirst(final String searchStr, final String replaceStr);\npublic StrBuilder replaceAll(final StrMatcher matcher, final String replaceStr);\npublic StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr);\npublic StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount);\nprivate StrBuilder replaceImpl(final StrMatcher matcher, final String replaceStr, final int from, int to, int replaceCount);\npublic StrBuilder reverse();\npublic StrBuilder trim();\npublic boolean startsWith(final String str);\npublic boolean endsWith(final String str);\npublic CharSequence subSequence(final int startIndex, final int endIndex);\npublic String substring(final int start);\npublic String substring(final int startIndex, int endIndex);\npublic String leftString(final int length);\npublic String rightString(final int length);\npublic String midString(int index, final int length);\npublic boolean contains(final char ch);\npublic boolean contains(final String str);\npublic boolean contains(final StrMatcher matcher);\npublic int indexOf(final char ch);\npublic int indexOf(final char ch, int startIndex);\npublic int indexOf(final String str);\npublic int indexOf(final String str, int startIndex);\npublic int indexOf(final StrMatcher matcher);\npublic int indexOf(final StrMatcher matcher, int startIndex);\npublic int lastIndexOf(final char ch);\npublic int lastIndexOf(final char ch, int startIndex);\npublic int lastIndexOf(final String str);\npublic int lastIndexOf(final String str, int startIndex);\npublic int lastIndexOf(final StrMatcher matcher);\npublic int lastIndexOf(final StrMatcher matcher, int startIndex);\npublic StrTokenizer asTokenizer();\npublic Reader asReader();\npublic Writer asWriter();\npublic void appendTo(final Appendable appendable) throws IOException;\npublic boolean equalsIgnoreCase(final StrBuilder other);\npublic boolean equals(final StrBuilder other);\npublic boolean equals(final Object obj);\npublic int hashCode();\npublic String toString();\npublic StringBuffer toStringBuffer();\npublic StringBuilder toStringBuilder();\npublic String build();\nprotected int validateRange(final int startIndex, int endIndex);\nprotected void validateIndex(final int index);",
        "Class_name": "StrBuilder",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/text/StrBuilder###setCharAt",
        "Parameter_num": "2",
        "all_Import_statements": "import java.io.IOException;\n\nimport java.io.Reader;\n\nimport java.io.Serializable;\n\nimport java.io.Writer;\n\nimport java.nio.CharBuffer;\n\nimport java.util.Iterator;\n\nimport java.util.List;\n\nimport java.util.Objects;\n\nimport org.apache.commons.lang3.ArrayUtils;\n\nimport org.apache.commons.lang3.CharUtils;\n\nimport org.apache.commons.lang3.StringUtils;\n\nimport org.apache.commons.lang3.builder.Builder;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
        "comment": "\n     * Sets the character at the specified index.\n     *\n     * @see #charAt(int)\n     * @see #deleteCharAt(int)\n     * @param index  the index to set\n     * @param ch  the new character\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     ",
        "packageName": "org.apache.commons.lang3.text",
        "method_signature": "public StrBuilder setCharAt(final int index, final char ch);",
        "Junit_version": "4",
        "returnType": "StrBuilder"
    },
    {
        "Method_body": "public static Class<?> getRawType(final Type type, final Type assigningType) {\n    if (type instanceof Class<?>) {\n        return (Class<?>) type;\n    }\n    if (type instanceof ParameterizedType) {\n        return getRawType((ParameterizedType) type);\n    }\n    if (type instanceof TypeVariable<?>) {\n        if (assigningType == null) {\n            return null;\n        }\n        final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration();\n        if (!(genericDeclaration instanceof Class<?>)) {\n            return null;\n        }\n        final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType, (Class<?>) genericDeclaration);\n        if (typeVarAssigns == null) {\n            return null;\n        }\n        final Type typeArgument = typeVarAssigns.get(type);\n        if (typeArgument == null) {\n            return null;\n        }\n        return getRawType(typeArgument, assigningType);\n    }\n    if (type instanceof GenericArrayType) {\n        final Class<?> rawComponentType = getRawType(((GenericArrayType) type).getGenericComponentType(), assigningType);\n        return Array.newInstance(rawComponentType, 0).getClass();\n    }\n    if (type instanceof WildcardType) {\n        return null;\n    }\n    throw new IllegalArgumentException(\"unknown type: \" + type);\n}",
        "all_field_declaration": "/**\n * A wildcard instance matching {@code ?}.\n * @since 3.2\n */\npublic static final WildcardType WILDCARD_ALL = wildcardType().withUpperBounds(Object.class).build();",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "6",
        "Filed": "",
        "Parameter_type": "Type,Type",
        "Import_statements": "import java.lang.reflect.Array;\nimport java.lang.reflect.GenericArrayType;\nimport java.lang.reflect.GenericDeclaration;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.lang.reflect.WildcardType;\nimport java.util.Map;\n",
        "public_method_signature": "public TypeUtils();\npublic static boolean isAssignable(final Type type, final Type toType);\npublic static Map<TypeVariable<?>, Type> getTypeArguments(final ParameterizedType type);\npublic static Map<TypeVariable<?>, Type> getTypeArguments(final Type type, final Class<?> toClass);\npublic static Map<TypeVariable<?>, Type> determineTypeArguments(final Class<?> cls, final ParameterizedType superType);\npublic static boolean isInstance(final Object value, final Type type);\npublic static Type[] normalizeUpperBounds(final Type[] bounds);\npublic static Type[] getImplicitBounds(final TypeVariable<?> typeVariable);\npublic static Type[] getImplicitUpperBounds(final WildcardType wildcardType);\npublic static Type[] getImplicitLowerBounds(final WildcardType wildcardType);\npublic static boolean typesSatisfyVariables(final Map<TypeVariable<?>, Type> typeVarAssigns);\npublic static Class<?> getRawType(final Type type, final Type assigningType);\npublic static boolean isArrayType(final Type type);\npublic static Type getArrayComponentType(final Type type);\npublic static Type unrollVariables(Map<TypeVariable<?>, Type> typeArguments, final Type type);\npublic static boolean containsTypeVariables(final Type type);\npublic static final ParameterizedType parameterize(final Class<?> raw, final Type... typeArguments);\npublic static final ParameterizedType parameterize(final Class<?> raw, final Map<TypeVariable<?>, Type> typeArgMappings);\npublic static final ParameterizedType parameterizeWithOwner(final Type owner, final Class<?> raw, final Type... typeArguments);\npublic static final ParameterizedType parameterizeWithOwner(final Type owner, final Class<?> raw, final Map<TypeVariable<?>, Type> typeArgMappings);\npublic static WildcardTypeBuilder wildcardType();\npublic static GenericArrayType genericArrayType(final Type componentType);\npublic static boolean equals(final Type t1, final Type t2);\npublic static String toString(final Type type);\npublic static String toLongString(final TypeVariable<?> var);\npublic static Typed<T> wrap(final Type type);\npublic static Typed<T> wrap(final Class<T> type);",
        "public_field": "/**\n * A wildcard instance matching {@code ?}.\n * @since 3.2\n */\npublic static final WildcardType WILDCARD_ALL = wildcardType().withUpperBounds(Object.class).build();",
        "Method_statement": "getRawType(final Type type, final Type assigningType)",
        "Method_name": "getRawType",
        "Class_declaration": "public class TypeUtils {\n",
        "constructors": "public TypeUtils() {\n    super();\n}",
        "all_method_signature": "public TypeUtils();\npublic static boolean isAssignable(final Type type, final Type toType);\nprivate static boolean isAssignable(final Type type, final Type toType, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static boolean isAssignable(final Type type, final Class<?> toClass);\nprivate static boolean isAssignable(final Type type, final ParameterizedType toParameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static Type unrollVariableAssignments(TypeVariable<?> var, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static boolean isAssignable(final Type type, final GenericArrayType toGenericArrayType, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static boolean isAssignable(final Type type, final TypeVariable<?> toTypeVariable, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static Type substituteTypeVariables(final Type type, final Map<TypeVariable<?>, Type> typeVarAssigns);\npublic static Map<TypeVariable<?>, Type> getTypeArguments(final ParameterizedType type);\npublic static Map<TypeVariable<?>, Type> getTypeArguments(final Type type, final Class<?> toClass);\nprivate static Map<TypeVariable<?>, Type> getTypeArguments(final Type type, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns);\nprivate static Map<TypeVariable<?>, Type> getTypeArguments(final ParameterizedType parameterizedType, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns);\nprivate static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns);\npublic static Map<TypeVariable<?>, Type> determineTypeArguments(final Class<?> cls, final ParameterizedType superType);\nprivate static void mapTypeVariablesToArguments(final Class<T> cls, final ParameterizedType parameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static Type getClosestParentType(final Class<?> cls, final Class<?> superClass);\npublic static boolean isInstance(final Object value, final Type type);\npublic static Type[] normalizeUpperBounds(final Type[] bounds);\npublic static Type[] getImplicitBounds(final TypeVariable<?> typeVariable);\npublic static Type[] getImplicitUpperBounds(final WildcardType wildcardType);\npublic static Type[] getImplicitLowerBounds(final WildcardType wildcardType);\npublic static boolean typesSatisfyVariables(final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static Class<?> getRawType(final ParameterizedType parameterizedType);\npublic static Class<?> getRawType(final Type type, final Type assigningType);\npublic static boolean isArrayType(final Type type);\npublic static Type getArrayComponentType(final Type type);\npublic static Type unrollVariables(Map<TypeVariable<?>, Type> typeArguments, final Type type);\nprivate static Type[] unrollBounds(final Map<TypeVariable<?>, Type> typeArguments, final Type[] bounds);\npublic static boolean containsTypeVariables(final Type type);\npublic static final ParameterizedType parameterize(final Class<?> raw, final Type... typeArguments);\npublic static final ParameterizedType parameterize(final Class<?> raw, final Map<TypeVariable<?>, Type> typeArgMappings);\npublic static final ParameterizedType parameterizeWithOwner(final Type owner, final Class<?> raw, final Type... typeArguments);\npublic static final ParameterizedType parameterizeWithOwner(final Type owner, final Class<?> raw, final Map<TypeVariable<?>, Type> typeArgMappings);\nprivate static Type[] extractTypeArgumentsFrom(final Map<TypeVariable<?>, Type> mappings, final TypeVariable<?>[] variables);\npublic static WildcardTypeBuilder wildcardType();\npublic static GenericArrayType genericArrayType(final Type componentType);\npublic static boolean equals(final Type t1, final Type t2);\nprivate static boolean equals(final ParameterizedType p, final Type t);\nprivate static boolean equals(final GenericArrayType a, final Type t);\nprivate static boolean equals(final WildcardType w, final Type t);\nprivate static boolean equals(final Type[] t1, final Type[] t2);\npublic static String toString(final Type type);\npublic static String toLongString(final TypeVariable<?> var);\npublic static Typed<T> wrap(final Type type);\npublic static Typed<T> wrap(final Class<T> type);\nprivate static String classToString(final Class<?> c);\nprivate static String typeVariableToString(final TypeVariable<?> v);\nprivate static String parameterizedTypeToString(final ParameterizedType p);\nprivate static void appendRecursiveTypes(final StringBuilder buf, final int[] recursiveTypeIndexes, final Type[] argumentTypes);\nprivate static int[] findRecursiveTypes(final ParameterizedType p);\nprivate static boolean containsVariableTypeSameParametrizedTypeBound(final TypeVariable<?> typeVariable, final ParameterizedType p);\nprivate static String wildcardTypeToString(final WildcardType w);\nprivate static String genericArrayTypeToString(final GenericArrayType g);\nprivate static StringBuilder appendAllTo(final StringBuilder buf, final String sep, final T... types);\nprivate static String toString(final T object);",
        "Class_name": "TypeUtils",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/reflect/TypeUtils###getRawType",
        "Parameter_num": "2",
        "all_Import_statements": "import java.lang.reflect.Array;\n\nimport java.lang.reflect.GenericArrayType;\n\nimport java.lang.reflect.GenericDeclaration;\n\nimport java.lang.reflect.ParameterizedType;\n\nimport java.lang.reflect.Type;\n\nimport java.lang.reflect.TypeVariable;\n\nimport java.lang.reflect.WildcardType;\n\nimport java.util.Arrays;\n\nimport java.util.Collections;\n\nimport java.util.HashMap;\n\nimport java.util.HashSet;\n\nimport java.util.List;\n\nimport java.util.Map;\n\nimport java.util.Objects;\n\nimport java.util.Set;\n\nimport org.apache.commons.lang3.ArrayUtils;\n\nimport org.apache.commons.lang3.ClassUtils;\n\nimport org.apache.commons.lang3.ObjectUtils;\n\nimport org.apache.commons.lang3.Validate;\n\nimport org.apache.commons.lang3.builder.Builder;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
        "comment": "\n     * <p>Get the raw type of a Java type, given its context. Primarily for use\n     * with {@link TypeVariable}s and {@link GenericArrayType}s, or when you do\n     * not know the runtime type of {@code type}: if you know you have a\n     * {@link Class} instance, it is already raw; if you know you have a\n     * {@link ParameterizedType}, its raw type is only a method call away.</p>\n     *\n     * @param type to resolve\n     * @param assigningType type to be resolved against\n     * @return the resolved {@link Class} object or {@code null} if\n     * the type could not be resolved\n     ",
        "packageName": "org.apache.commons.lang3.reflect",
        "method_signature": "public static Class<?> getRawType(final Type type, final Type assigningType);",
        "Junit_version": "4",
        "returnType": "Class<?>"
    },
    {
        "Method_body": "private static boolean isAssignable(final Type type, final Class<?> toClass) {\n    if (type == null) {\n        return toClass == null || !toClass.isPrimitive();\n    }\n    if (toClass == null) {\n        return false;\n    }\n    if (toClass.equals(type)) {\n        return true;\n    }\n    if (type instanceof Class<?>) {\n        return ClassUtils.isAssignable((Class<?>) type, toClass);\n    }\n    if (type instanceof ParameterizedType) {\n        return isAssignable(getRawType((ParameterizedType) type), toClass);\n    }\n    if (type instanceof TypeVariable<?>) {\n        for (final Type bound : ((TypeVariable<?>) type).getBounds()) {\n            if (isAssignable(bound, toClass)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (type instanceof GenericArrayType) {\n        return toClass.equals(Object.class) || toClass.isArray() && isAssignable(((GenericArrayType) type).getGenericComponentType(), toClass.getComponentType());\n    }\n    if (type instanceof WildcardType) {\n        return false;\n    }\n    throw new IllegalStateException(\"found an unhandled type: \" + type);\n}",
        "all_field_declaration": "/**\n * A wildcard instance matching {@code ?}.\n * @since 3.2\n */\npublic static final WildcardType WILDCARD_ALL = wildcardType().withUpperBounds(Object.class).build();",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "9",
        "Filed": "",
        "Parameter_type": "Type,Class<?>",
        "Import_statements": "import java.lang.reflect.Array;\nimport java.lang.reflect.GenericArrayType;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.lang.reflect.WildcardType;\nimport org.apache.commons.lang3.ClassUtils;\n",
        "public_method_signature": "public TypeUtils();\npublic static boolean isAssignable(final Type type, final Type toType);\npublic static Map<TypeVariable<?>, Type> getTypeArguments(final ParameterizedType type);\npublic static Map<TypeVariable<?>, Type> getTypeArguments(final Type type, final Class<?> toClass);\npublic static Map<TypeVariable<?>, Type> determineTypeArguments(final Class<?> cls, final ParameterizedType superType);\npublic static boolean isInstance(final Object value, final Type type);\npublic static Type[] normalizeUpperBounds(final Type[] bounds);\npublic static Type[] getImplicitBounds(final TypeVariable<?> typeVariable);\npublic static Type[] getImplicitUpperBounds(final WildcardType wildcardType);\npublic static Type[] getImplicitLowerBounds(final WildcardType wildcardType);\npublic static boolean typesSatisfyVariables(final Map<TypeVariable<?>, Type> typeVarAssigns);\npublic static Class<?> getRawType(final Type type, final Type assigningType);\npublic static boolean isArrayType(final Type type);\npublic static Type getArrayComponentType(final Type type);\npublic static Type unrollVariables(Map<TypeVariable<?>, Type> typeArguments, final Type type);\npublic static boolean containsTypeVariables(final Type type);\npublic static final ParameterizedType parameterize(final Class<?> raw, final Type... typeArguments);\npublic static final ParameterizedType parameterize(final Class<?> raw, final Map<TypeVariable<?>, Type> typeArgMappings);\npublic static final ParameterizedType parameterizeWithOwner(final Type owner, final Class<?> raw, final Type... typeArguments);\npublic static final ParameterizedType parameterizeWithOwner(final Type owner, final Class<?> raw, final Map<TypeVariable<?>, Type> typeArgMappings);\npublic static WildcardTypeBuilder wildcardType();\npublic static GenericArrayType genericArrayType(final Type componentType);\npublic static boolean equals(final Type t1, final Type t2);\npublic static String toString(final Type type);\npublic static String toLongString(final TypeVariable<?> var);\npublic static Typed<T> wrap(final Type type);\npublic static Typed<T> wrap(final Class<T> type);",
        "public_field": "/**\n * A wildcard instance matching {@code ?}.\n * @since 3.2\n */\npublic static final WildcardType WILDCARD_ALL = wildcardType().withUpperBounds(Object.class).build();",
        "Method_statement": "isAssignable(final Type type, final Class<?> toClass)",
        "Method_name": "isAssignable",
        "Class_declaration": "public class TypeUtils {\n",
        "constructors": "public TypeUtils() {\n    super();\n}",
        "all_method_signature": "public TypeUtils();\npublic static boolean isAssignable(final Type type, final Type toType);\nprivate static boolean isAssignable(final Type type, final Type toType, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static boolean isAssignable(final Type type, final Class<?> toClass);\nprivate static boolean isAssignable(final Type type, final ParameterizedType toParameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static Type unrollVariableAssignments(TypeVariable<?> var, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static boolean isAssignable(final Type type, final GenericArrayType toGenericArrayType, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static boolean isAssignable(final Type type, final TypeVariable<?> toTypeVariable, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static Type substituteTypeVariables(final Type type, final Map<TypeVariable<?>, Type> typeVarAssigns);\npublic static Map<TypeVariable<?>, Type> getTypeArguments(final ParameterizedType type);\npublic static Map<TypeVariable<?>, Type> getTypeArguments(final Type type, final Class<?> toClass);\nprivate static Map<TypeVariable<?>, Type> getTypeArguments(final Type type, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns);\nprivate static Map<TypeVariable<?>, Type> getTypeArguments(final ParameterizedType parameterizedType, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns);\nprivate static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns);\npublic static Map<TypeVariable<?>, Type> determineTypeArguments(final Class<?> cls, final ParameterizedType superType);\nprivate static void mapTypeVariablesToArguments(final Class<T> cls, final ParameterizedType parameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static Type getClosestParentType(final Class<?> cls, final Class<?> superClass);\npublic static boolean isInstance(final Object value, final Type type);\npublic static Type[] normalizeUpperBounds(final Type[] bounds);\npublic static Type[] getImplicitBounds(final TypeVariable<?> typeVariable);\npublic static Type[] getImplicitUpperBounds(final WildcardType wildcardType);\npublic static Type[] getImplicitLowerBounds(final WildcardType wildcardType);\npublic static boolean typesSatisfyVariables(final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static Class<?> getRawType(final ParameterizedType parameterizedType);\npublic static Class<?> getRawType(final Type type, final Type assigningType);\npublic static boolean isArrayType(final Type type);\npublic static Type getArrayComponentType(final Type type);\npublic static Type unrollVariables(Map<TypeVariable<?>, Type> typeArguments, final Type type);\nprivate static Type[] unrollBounds(final Map<TypeVariable<?>, Type> typeArguments, final Type[] bounds);\npublic static boolean containsTypeVariables(final Type type);\npublic static final ParameterizedType parameterize(final Class<?> raw, final Type... typeArguments);\npublic static final ParameterizedType parameterize(final Class<?> raw, final Map<TypeVariable<?>, Type> typeArgMappings);\npublic static final ParameterizedType parameterizeWithOwner(final Type owner, final Class<?> raw, final Type... typeArguments);\npublic static final ParameterizedType parameterizeWithOwner(final Type owner, final Class<?> raw, final Map<TypeVariable<?>, Type> typeArgMappings);\nprivate static Type[] extractTypeArgumentsFrom(final Map<TypeVariable<?>, Type> mappings, final TypeVariable<?>[] variables);\npublic static WildcardTypeBuilder wildcardType();\npublic static GenericArrayType genericArrayType(final Type componentType);\npublic static boolean equals(final Type t1, final Type t2);\nprivate static boolean equals(final ParameterizedType p, final Type t);\nprivate static boolean equals(final GenericArrayType a, final Type t);\nprivate static boolean equals(final WildcardType w, final Type t);\nprivate static boolean equals(final Type[] t1, final Type[] t2);\npublic static String toString(final Type type);\npublic static String toLongString(final TypeVariable<?> var);\npublic static Typed<T> wrap(final Type type);\npublic static Typed<T> wrap(final Class<T> type);\nprivate static String classToString(final Class<?> c);\nprivate static String typeVariableToString(final TypeVariable<?> v);\nprivate static String parameterizedTypeToString(final ParameterizedType p);\nprivate static void appendRecursiveTypes(final StringBuilder buf, final int[] recursiveTypeIndexes, final Type[] argumentTypes);\nprivate static int[] findRecursiveTypes(final ParameterizedType p);\nprivate static boolean containsVariableTypeSameParametrizedTypeBound(final TypeVariable<?> typeVariable, final ParameterizedType p);\nprivate static String wildcardTypeToString(final WildcardType w);\nprivate static String genericArrayTypeToString(final GenericArrayType g);\nprivate static StringBuilder appendAllTo(final StringBuilder buf, final String sep, final T... types);\nprivate static String toString(final T object);",
        "Class_name": "TypeUtils",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/reflect/TypeUtils###isAssignable",
        "Parameter_num": "2",
        "all_Import_statements": "import java.lang.reflect.Array;\n\nimport java.lang.reflect.GenericArrayType;\n\nimport java.lang.reflect.GenericDeclaration;\n\nimport java.lang.reflect.ParameterizedType;\n\nimport java.lang.reflect.Type;\n\nimport java.lang.reflect.TypeVariable;\n\nimport java.lang.reflect.WildcardType;\n\nimport java.util.Arrays;\n\nimport java.util.Collections;\n\nimport java.util.HashMap;\n\nimport java.util.HashSet;\n\nimport java.util.List;\n\nimport java.util.Map;\n\nimport java.util.Objects;\n\nimport java.util.Set;\n\nimport org.apache.commons.lang3.ArrayUtils;\n\nimport org.apache.commons.lang3.ClassUtils;\n\nimport org.apache.commons.lang3.ObjectUtils;\n\nimport org.apache.commons.lang3.Validate;\n\nimport org.apache.commons.lang3.builder.Builder;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
        "comment": "\n     * <p>Checks if the subject type may be implicitly cast to the target class\n     * following the Java generics rules.</p>\n     *\n     * @param type the subject type to be assigned to the target type\n     * @param toClass the target class\n     * @return {@code true} if {@code type} is assignable to {@code toClass}.\n     ",
        "packageName": "org.apache.commons.lang3.reflect",
        "method_signature": "private static boolean isAssignable(final Type type, final Class<?> toClass);",
        "Junit_version": "4",
        "returnType": "boolean"
    },
    {
        "Method_body": "public static final ParameterizedType parameterize(final Class<?> raw, final Map<TypeVariable<?>, Type> typeArgMappings) {\n    Validate.notNull(raw, \"raw class is null\");\n    Validate.notNull(typeArgMappings, \"typeArgMappings is null\");\n    return parameterizeWithOwner(null, raw, extractTypeArgumentsFrom(typeArgMappings, raw.getTypeParameters()));\n}",
        "all_field_declaration": "/**\n * A wildcard instance matching {@code ?}.\n * @since 3.2\n */\npublic static final WildcardType WILDCARD_ALL = wildcardType().withUpperBounds(Object.class).build();",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "3",
        "Filed": "",
        "Parameter_type": "Class<?>,Map<TypeVariable<?>, Type>",
        "Import_statements": "import java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.util.Map;\nimport org.apache.commons.lang3.Validate;\n",
        "public_method_signature": "public TypeUtils();\npublic static boolean isAssignable(final Type type, final Type toType);\npublic static Map<TypeVariable<?>, Type> getTypeArguments(final ParameterizedType type);\npublic static Map<TypeVariable<?>, Type> getTypeArguments(final Type type, final Class<?> toClass);\npublic static Map<TypeVariable<?>, Type> determineTypeArguments(final Class<?> cls, final ParameterizedType superType);\npublic static boolean isInstance(final Object value, final Type type);\npublic static Type[] normalizeUpperBounds(final Type[] bounds);\npublic static Type[] getImplicitBounds(final TypeVariable<?> typeVariable);\npublic static Type[] getImplicitUpperBounds(final WildcardType wildcardType);\npublic static Type[] getImplicitLowerBounds(final WildcardType wildcardType);\npublic static boolean typesSatisfyVariables(final Map<TypeVariable<?>, Type> typeVarAssigns);\npublic static Class<?> getRawType(final Type type, final Type assigningType);\npublic static boolean isArrayType(final Type type);\npublic static Type getArrayComponentType(final Type type);\npublic static Type unrollVariables(Map<TypeVariable<?>, Type> typeArguments, final Type type);\npublic static boolean containsTypeVariables(final Type type);\npublic static final ParameterizedType parameterize(final Class<?> raw, final Type... typeArguments);\npublic static final ParameterizedType parameterize(final Class<?> raw, final Map<TypeVariable<?>, Type> typeArgMappings);\npublic static final ParameterizedType parameterizeWithOwner(final Type owner, final Class<?> raw, final Type... typeArguments);\npublic static final ParameterizedType parameterizeWithOwner(final Type owner, final Class<?> raw, final Map<TypeVariable<?>, Type> typeArgMappings);\npublic static WildcardTypeBuilder wildcardType();\npublic static GenericArrayType genericArrayType(final Type componentType);\npublic static boolean equals(final Type t1, final Type t2);\npublic static String toString(final Type type);\npublic static String toLongString(final TypeVariable<?> var);\npublic static Typed<T> wrap(final Type type);\npublic static Typed<T> wrap(final Class<T> type);",
        "public_field": "/**\n * A wildcard instance matching {@code ?}.\n * @since 3.2\n */\npublic static final WildcardType WILDCARD_ALL = wildcardType().withUpperBounds(Object.class).build();",
        "Method_statement": "parameterize(final Class<?> raw, final Map<TypeVariable<?>, Type> typeArgMappings)",
        "Method_name": "parameterize",
        "Class_declaration": "public class TypeUtils {\n",
        "constructors": "public TypeUtils() {\n    super();\n}",
        "all_method_signature": "public TypeUtils();\npublic static boolean isAssignable(final Type type, final Type toType);\nprivate static boolean isAssignable(final Type type, final Type toType, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static boolean isAssignable(final Type type, final Class<?> toClass);\nprivate static boolean isAssignable(final Type type, final ParameterizedType toParameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static Type unrollVariableAssignments(TypeVariable<?> var, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static boolean isAssignable(final Type type, final GenericArrayType toGenericArrayType, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static boolean isAssignable(final Type type, final TypeVariable<?> toTypeVariable, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static Type substituteTypeVariables(final Type type, final Map<TypeVariable<?>, Type> typeVarAssigns);\npublic static Map<TypeVariable<?>, Type> getTypeArguments(final ParameterizedType type);\npublic static Map<TypeVariable<?>, Type> getTypeArguments(final Type type, final Class<?> toClass);\nprivate static Map<TypeVariable<?>, Type> getTypeArguments(final Type type, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns);\nprivate static Map<TypeVariable<?>, Type> getTypeArguments(final ParameterizedType parameterizedType, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns);\nprivate static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns);\npublic static Map<TypeVariable<?>, Type> determineTypeArguments(final Class<?> cls, final ParameterizedType superType);\nprivate static void mapTypeVariablesToArguments(final Class<T> cls, final ParameterizedType parameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static Type getClosestParentType(final Class<?> cls, final Class<?> superClass);\npublic static boolean isInstance(final Object value, final Type type);\npublic static Type[] normalizeUpperBounds(final Type[] bounds);\npublic static Type[] getImplicitBounds(final TypeVariable<?> typeVariable);\npublic static Type[] getImplicitUpperBounds(final WildcardType wildcardType);\npublic static Type[] getImplicitLowerBounds(final WildcardType wildcardType);\npublic static boolean typesSatisfyVariables(final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static Class<?> getRawType(final ParameterizedType parameterizedType);\npublic static Class<?> getRawType(final Type type, final Type assigningType);\npublic static boolean isArrayType(final Type type);\npublic static Type getArrayComponentType(final Type type);\npublic static Type unrollVariables(Map<TypeVariable<?>, Type> typeArguments, final Type type);\nprivate static Type[] unrollBounds(final Map<TypeVariable<?>, Type> typeArguments, final Type[] bounds);\npublic static boolean containsTypeVariables(final Type type);\npublic static final ParameterizedType parameterize(final Class<?> raw, final Type... typeArguments);\npublic static final ParameterizedType parameterize(final Class<?> raw, final Map<TypeVariable<?>, Type> typeArgMappings);\npublic static final ParameterizedType parameterizeWithOwner(final Type owner, final Class<?> raw, final Type... typeArguments);\npublic static final ParameterizedType parameterizeWithOwner(final Type owner, final Class<?> raw, final Map<TypeVariable<?>, Type> typeArgMappings);\nprivate static Type[] extractTypeArgumentsFrom(final Map<TypeVariable<?>, Type> mappings, final TypeVariable<?>[] variables);\npublic static WildcardTypeBuilder wildcardType();\npublic static GenericArrayType genericArrayType(final Type componentType);\npublic static boolean equals(final Type t1, final Type t2);\nprivate static boolean equals(final ParameterizedType p, final Type t);\nprivate static boolean equals(final GenericArrayType a, final Type t);\nprivate static boolean equals(final WildcardType w, final Type t);\nprivate static boolean equals(final Type[] t1, final Type[] t2);\npublic static String toString(final Type type);\npublic static String toLongString(final TypeVariable<?> var);\npublic static Typed<T> wrap(final Type type);\npublic static Typed<T> wrap(final Class<T> type);\nprivate static String classToString(final Class<?> c);\nprivate static String typeVariableToString(final TypeVariable<?> v);\nprivate static String parameterizedTypeToString(final ParameterizedType p);\nprivate static void appendRecursiveTypes(final StringBuilder buf, final int[] recursiveTypeIndexes, final Type[] argumentTypes);\nprivate static int[] findRecursiveTypes(final ParameterizedType p);\nprivate static boolean containsVariableTypeSameParametrizedTypeBound(final TypeVariable<?> typeVariable, final ParameterizedType p);\nprivate static String wildcardTypeToString(final WildcardType w);\nprivate static String genericArrayTypeToString(final GenericArrayType g);\nprivate static StringBuilder appendAllTo(final StringBuilder buf, final String sep, final T... types);\nprivate static String toString(final T object);",
        "Class_name": "TypeUtils",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/reflect/TypeUtils###parameterize",
        "Parameter_num": "2",
        "all_Import_statements": "import java.lang.reflect.Array;\n\nimport java.lang.reflect.GenericArrayType;\n\nimport java.lang.reflect.GenericDeclaration;\n\nimport java.lang.reflect.ParameterizedType;\n\nimport java.lang.reflect.Type;\n\nimport java.lang.reflect.TypeVariable;\n\nimport java.lang.reflect.WildcardType;\n\nimport java.util.Arrays;\n\nimport java.util.Collections;\n\nimport java.util.HashMap;\n\nimport java.util.HashSet;\n\nimport java.util.List;\n\nimport java.util.Map;\n\nimport java.util.Objects;\n\nimport java.util.Set;\n\nimport org.apache.commons.lang3.ArrayUtils;\n\nimport org.apache.commons.lang3.ClassUtils;\n\nimport org.apache.commons.lang3.ObjectUtils;\n\nimport org.apache.commons.lang3.Validate;\n\nimport org.apache.commons.lang3.builder.Builder;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
        "comment": "\n     * Create a parameterized type instance.\n     *\n     * @param raw the raw class to create a parameterized type instance for\n     * @param typeArgMappings the mapping used for parameterization\n     * @return {@link ParameterizedType}\n     * @since 3.2\n     ",
        "packageName": "org.apache.commons.lang3.reflect",
        "method_signature": "public static final ParameterizedType parameterize(final Class<?> raw, final Map<TypeVariable<?>, Type> typeArgMappings);",
        "Junit_version": "4",
        "returnType": "ParameterizedType"
    },
    {
        "Method_body": "public static Map<Object, Object> toMap(final Object[] array) {\n    if (array == null) {\n        return null;\n    }\n    final Map<Object, Object> map = new HashMap<>((int) (array.length * 1.5));\n    for (int i = 0; i < array.length; i++) {\n        final Object object = array[i];\n        if (object instanceof Map.Entry<?, ?>) {\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) object;\n            map.put(entry.getKey(), entry.getValue());\n        } else if (object instanceof Object[]) {\n            final Object[] entry = (Object[]) object;\n            if (entry.length < 2) {\n                throw new IllegalArgumentException(\"Array element \" + i + \", '\" + object + \"', has a length less than 2\");\n            }\n            map.put(entry[0], entry[1]);\n        } else {\n            throw new IllegalArgumentException(\"Array element \" + i + \", '\" + object + \"', is neither of type Map.Entry nor an Array\");\n        }\n    }\n    return map;\n}",
        "all_field_declaration": "/**\n * An empty immutable {@code Object} array.\n */\npublic static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];\n/**\n * An empty immutable {@code Class} array.\n */\npublic static final Class<?>[] EMPTY_CLASS_ARRAY = new Class[0];\n/**\n * An empty immutable {@code String} array.\n */\npublic static final String[] EMPTY_STRING_ARRAY = new String[0];\n/**\n * An empty immutable {@code long} array.\n */\npublic static final long[] EMPTY_LONG_ARRAY = new long[0];\n/**\n * An empty immutable {@code Long} array.\n */\npublic static final Long[] EMPTY_LONG_OBJECT_ARRAY = new Long[0];\n/**\n * An empty immutable {@code int} array.\n */\npublic static final int[] EMPTY_INT_ARRAY = new int[0];\n/**\n * An empty immutable {@code Integer} array.\n */\npublic static final Integer[] EMPTY_INTEGER_OBJECT_ARRAY = new Integer[0];\n/**\n * An empty immutable {@code short} array.\n */\npublic static final short[] EMPTY_SHORT_ARRAY = new short[0];\n/**\n * An empty immutable {@code Short} array.\n */\npublic static final Short[] EMPTY_SHORT_OBJECT_ARRAY = new Short[0];\n/**\n * An empty immutable {@code byte} array.\n */\npublic static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\n/**\n * An empty immutable {@code Byte} array.\n */\npublic static final Byte[] EMPTY_BYTE_OBJECT_ARRAY = new Byte[0];\n/**\n * An empty immutable {@code double} array.\n */\npublic static final double[] EMPTY_DOUBLE_ARRAY = new double[0];\n/**\n * An empty immutable {@code Double} array.\n */\npublic static final Double[] EMPTY_DOUBLE_OBJECT_ARRAY = new Double[0];\n/**\n * An empty immutable {@code float} array.\n */\npublic static final float[] EMPTY_FLOAT_ARRAY = new float[0];\n/**\n * An empty immutable {@code Float} array.\n */\npublic static final Float[] EMPTY_FLOAT_OBJECT_ARRAY = new Float[0];\n/**\n * An empty immutable {@code boolean} array.\n */\npublic static final boolean[] EMPTY_BOOLEAN_ARRAY = new boolean[0];\n/**\n * An empty immutable {@code Boolean} array.\n */\npublic static final Boolean[] EMPTY_BOOLEAN_OBJECT_ARRAY = new Boolean[0];\n/**\n * An empty immutable {@code char} array.\n */\npublic static final char[] EMPTY_CHAR_ARRAY = new char[0];\n/**\n * An empty immutable {@code Character} array.\n */\npublic static final Character[] EMPTY_CHARACTER_OBJECT_ARRAY = new Character[0];\n/**\n * The index value when an element is not found in a list or array: {@code -1}.\n * This value is returned by methods in this class and can also be used in comparisons with values returned by\n * various method from {@link java.util.List}.\n */\npublic static final int INDEX_NOT_FOUND = -1;",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "4",
        "Filed": "",
        "Parameter_type": "Object[]",
        "Import_statements": "import java.lang.reflect.Array;\nimport java.util.HashMap;\nimport java.util.Map;\n",
        "public_method_signature": "public ArrayUtils();\npublic static String toString(final Object array);\npublic static String toString(final Object array, final String stringIfNull);\npublic static int hashCode(final Object array);\npublic static boolean isEquals(final Object array1, final Object array2);\npublic static Map<Object, Object> toMap(final Object[] array);\npublic static T[] toArray(final T... items);\npublic static T[] clone(final T[] array);\npublic static long[] clone(final long[] array);\npublic static int[] clone(final int[] array);\npublic static short[] clone(final short[] array);\npublic static char[] clone(final char[] array);\npublic static byte[] clone(final byte[] array);\npublic static double[] clone(final double[] array);\npublic static float[] clone(final float[] array);\npublic static boolean[] clone(final boolean[] array);\npublic static T[] nullToEmpty(final T[] array, final Class<T[]> type);\npublic static Object[] nullToEmpty(final Object[] array);\npublic static Class<?>[] nullToEmpty(final Class<?>[] array);\npublic static String[] nullToEmpty(final String[] array);\npublic static long[] nullToEmpty(final long[] array);\npublic static int[] nullToEmpty(final int[] array);\npublic static short[] nullToEmpty(final short[] array);\npublic static char[] nullToEmpty(final char[] array);\npublic static byte[] nullToEmpty(final byte[] array);\npublic static double[] nullToEmpty(final double[] array);\npublic static float[] nullToEmpty(final float[] array);\npublic static boolean[] nullToEmpty(final boolean[] array);\npublic static Long[] nullToEmpty(final Long[] array);\npublic static Integer[] nullToEmpty(final Integer[] array);\npublic static Short[] nullToEmpty(final Short[] array);\npublic static Character[] nullToEmpty(final Character[] array);\npublic static Byte[] nullToEmpty(final Byte[] array);\npublic static Double[] nullToEmpty(final Double[] array);\npublic static Float[] nullToEmpty(final Float[] array);\npublic static Boolean[] nullToEmpty(final Boolean[] array);\npublic static T[] subarray(final T[] array, int startIndexInclusive, int endIndexExclusive);\npublic static long[] subarray(final long[] array, int startIndexInclusive, int endIndexExclusive);\npublic static int[] subarray(final int[] array, int startIndexInclusive, int endIndexExclusive);\npublic static short[] subarray(final short[] array, int startIndexInclusive, int endIndexExclusive);\npublic static char[] subarray(final char[] array, int startIndexInclusive, int endIndexExclusive);\npublic static byte[] subarray(final byte[] array, int startIndexInclusive, int endIndexExclusive);\npublic static double[] subarray(final double[] array, int startIndexInclusive, int endIndexExclusive);\npublic static float[] subarray(final float[] array, int startIndexInclusive, int endIndexExclusive);\npublic static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive);\npublic static boolean isSameLength(final Object[] array1, final Object[] array2);\npublic static boolean isSameLength(final long[] array1, final long[] array2);\npublic static boolean isSameLength(final int[] array1, final int[] array2);\npublic static boolean isSameLength(final short[] array1, final short[] array2);\npublic static boolean isSameLength(final char[] array1, final char[] array2);\npublic static boolean isSameLength(final byte[] array1, final byte[] array2);\npublic static boolean isSameLength(final double[] array1, final double[] array2);\npublic static boolean isSameLength(final float[] array1, final float[] array2);\npublic static boolean isSameLength(final boolean[] array1, final boolean[] array2);\npublic static int getLength(final Object array);\npublic static boolean isSameType(final Object array1, final Object array2);\npublic static void reverse(final Object[] array);\npublic static void reverse(final long[] array);\npublic static void reverse(final int[] array);\npublic static void reverse(final short[] array);\npublic static void reverse(final char[] array);\npublic static void reverse(final byte[] array);\npublic static void reverse(final double[] array);\npublic static void reverse(final float[] array);\npublic static void reverse(final boolean[] array);\npublic static void reverse(final boolean[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final byte[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final char[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final double[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final float[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final int[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final long[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final Object[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final short[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void swap(final Object[] array, final int offset1, final int offset2);\npublic static void swap(final long[] array, final int offset1, final int offset2);\npublic static void swap(final int[] array, final int offset1, final int offset2);\npublic static void swap(final short[] array, final int offset1, final int offset2);\npublic static void swap(final char[] array, final int offset1, final int offset2);\npublic static void swap(final byte[] array, final int offset1, final int offset2);\npublic static void swap(final double[] array, final int offset1, final int offset2);\npublic static void swap(final float[] array, final int offset1, final int offset2);\npublic static void swap(final boolean[] array, final int offset1, final int offset2);\npublic static void swap(final boolean[] array, int offset1, int offset2, int len);\npublic static void swap(final byte[] array, int offset1, int offset2, int len);\npublic static void swap(final char[] array, int offset1, int offset2, int len);\npublic static void swap(final double[] array, int offset1, int offset2, int len);\npublic static void swap(final float[] array, int offset1, int offset2, int len);\npublic static void swap(final int[] array, int offset1, int offset2, int len);\npublic static void swap(final long[] array, int offset1, int offset2, int len);\npublic static void swap(final Object[] array, int offset1, int offset2, int len);\npublic static void swap(final short[] array, int offset1, int offset2, int len);\npublic static void shift(final Object[] array, final int offset);\npublic static void shift(final long[] array, final int offset);\npublic static void shift(final int[] array, final int offset);\npublic static void shift(final short[] array, final int offset);\npublic static void shift(final char[] array, final int offset);\npublic static void shift(final byte[] array, final int offset);\npublic static void shift(final double[] array, final int offset);\npublic static void shift(final float[] array, final int offset);\npublic static void shift(final boolean[] array, final int offset);\npublic static void shift(final boolean[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final byte[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final char[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final double[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final float[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final int[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final long[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final Object[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final short[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static int indexOf(final Object[] array, final Object objectToFind);\npublic static int indexOf(final Object[] array, final Object objectToFind, int startIndex);\npublic static int lastIndexOf(final Object[] array, final Object objectToFind);\npublic static int lastIndexOf(final Object[] array, final Object objectToFind, int startIndex);\npublic static boolean contains(final Object[] array, final Object objectToFind);\npublic static int indexOf(final long[] array, final long valueToFind);\npublic static int indexOf(final long[] array, final long valueToFind, int startIndex);\npublic static int lastIndexOf(final long[] array, final long valueToFind);\npublic static int lastIndexOf(final long[] array, final long valueToFind, int startIndex);\npublic static boolean contains(final long[] array, final long valueToFind);\npublic static int indexOf(final int[] array, final int valueToFind);\npublic static int indexOf(final int[] array, final int valueToFind, int startIndex);\npublic static int lastIndexOf(final int[] array, final int valueToFind);\npublic static int lastIndexOf(final int[] array, final int valueToFind, int startIndex);\npublic static boolean contains(final int[] array, final int valueToFind);\npublic static int indexOf(final short[] array, final short valueToFind);\npublic static int indexOf(final short[] array, final short valueToFind, int startIndex);\npublic static int lastIndexOf(final short[] array, final short valueToFind);\npublic static int lastIndexOf(final short[] array, final short valueToFind, int startIndex);\npublic static boolean contains(final short[] array, final short valueToFind);\npublic static int indexOf(final char[] array, final char valueToFind);\npublic static int indexOf(final char[] array, final char valueToFind, int startIndex);\npublic static int lastIndexOf(final char[] array, final char valueToFind);\npublic static int lastIndexOf(final char[] array, final char valueToFind, int startIndex);\npublic static boolean contains(final char[] array, final char valueToFind);\npublic static int indexOf(final byte[] array, final byte valueToFind);\npublic static int indexOf(final byte[] array, final byte valueToFind, int startIndex);\npublic static int lastIndexOf(final byte[] array, final byte valueToFind);\npublic static int lastIndexOf(final byte[] array, final byte valueToFind, int startIndex);\npublic static boolean contains(final byte[] array, final byte valueToFind);\npublic static int indexOf(final double[] array, final double valueToFind);\npublic static int indexOf(final double[] array, final double valueToFind, final double tolerance);\npublic static int indexOf(final double[] array, final double valueToFind, int startIndex);\npublic static int indexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance);\npublic static int lastIndexOf(final double[] array, final double valueToFind);\npublic static int lastIndexOf(final double[] array, final double valueToFind, final double tolerance);\npublic static int lastIndexOf(final double[] array, final double valueToFind, int startIndex);\npublic static int lastIndexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance);\npublic static boolean contains(final double[] array, final double valueToFind);\npublic static boolean contains(final double[] array, final double valueToFind, final double tolerance);\npublic static int indexOf(final float[] array, final float valueToFind);\npublic static int indexOf(final float[] array, final float valueToFind, int startIndex);\npublic static int lastIndexOf(final float[] array, final float valueToFind);\npublic static int lastIndexOf(final float[] array, final float valueToFind, int startIndex);\npublic static boolean contains(final float[] array, final float valueToFind);\npublic static int indexOf(final boolean[] array, final boolean valueToFind);\npublic static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex);\npublic static int lastIndexOf(final boolean[] array, final boolean valueToFind);\npublic static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex);\npublic static boolean contains(final boolean[] array, final boolean valueToFind);\npublic static char[] toPrimitive(final Character[] array);\npublic static char[] toPrimitive(final Character[] array, final char valueForNull);\npublic static Character[] toObject(final char[] array);\npublic static long[] toPrimitive(final Long[] array);\npublic static long[] toPrimitive(final Long[] array, final long valueForNull);\npublic static Long[] toObject(final long[] array);\npublic static int[] toPrimitive(final Integer[] array);\npublic static int[] toPrimitive(final Integer[] array, final int valueForNull);\npublic static Integer[] toObject(final int[] array);\npublic static short[] toPrimitive(final Short[] array);\npublic static short[] toPrimitive(final Short[] array, final short valueForNull);\npublic static Short[] toObject(final short[] array);\npublic static byte[] toPrimitive(final Byte[] array);\npublic static byte[] toPrimitive(final Byte[] array, final byte valueForNull);\npublic static Byte[] toObject(final byte[] array);\npublic static double[] toPrimitive(final Double[] array);\npublic static double[] toPrimitive(final Double[] array, final double valueForNull);\npublic static Double[] toObject(final double[] array);\npublic static float[] toPrimitive(final Float[] array);\npublic static float[] toPrimitive(final Float[] array, final float valueForNull);\npublic static Float[] toObject(final float[] array);\npublic static Object toPrimitive(final Object array);\npublic static boolean[] toPrimitive(final Boolean[] array);\npublic static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull);\npublic static Boolean[] toObject(final boolean[] array);\npublic static boolean isEmpty(final Object[] array);\npublic static boolean isEmpty(final long[] array);\npublic static boolean isEmpty(final int[] array);\npublic static boolean isEmpty(final short[] array);\npublic static boolean isEmpty(final char[] array);\npublic static boolean isEmpty(final byte[] array);\npublic static boolean isEmpty(final double[] array);\npublic static boolean isEmpty(final float[] array);\npublic static boolean isEmpty(final boolean[] array);\npublic static boolean isNotEmpty(final T[] array);\npublic static boolean isNotEmpty(final long[] array);\npublic static boolean isNotEmpty(final int[] array);\npublic static boolean isNotEmpty(final short[] array);\npublic static boolean isNotEmpty(final char[] array);\npublic static boolean isNotEmpty(final byte[] array);\npublic static boolean isNotEmpty(final double[] array);\npublic static boolean isNotEmpty(final float[] array);\npublic static boolean isNotEmpty(final boolean[] array);\npublic static T[] addAll(final T[] array1, final T... array2);\npublic static boolean[] addAll(final boolean[] array1, final boolean... array2);\npublic static char[] addAll(final char[] array1, final char... array2);\npublic static byte[] addAll(final byte[] array1, final byte... array2);\npublic static short[] addAll(final short[] array1, final short... array2);\npublic static int[] addAll(final int[] array1, final int... array2);\npublic static long[] addAll(final long[] array1, final long... array2);\npublic static float[] addAll(final float[] array1, final float... array2);\npublic static double[] addAll(final double[] array1, final double... array2);\npublic static T[] add(final T[] array, final T element);\npublic static boolean[] add(final boolean[] array, final boolean element);\npublic static byte[] add(final byte[] array, final byte element);\npublic static char[] add(final char[] array, final char element);\npublic static double[] add(final double[] array, final double element);\npublic static float[] add(final float[] array, final float element);\npublic static int[] add(final int[] array, final int element);\npublic static long[] add(final long[] array, final long element);\npublic static short[] add(final short[] array, final short element);\npublic static T[] add(final T[] array, final int index, final T element);\npublic static boolean[] add(final boolean[] array, final int index, final boolean element);\npublic static char[] add(final char[] array, final int index, final char element);\npublic static byte[] add(final byte[] array, final int index, final byte element);\npublic static short[] add(final short[] array, final int index, final short element);\npublic static int[] add(final int[] array, final int index, final int element);\npublic static long[] add(final long[] array, final int index, final long element);\npublic static float[] add(final float[] array, final int index, final float element);\npublic static double[] add(final double[] array, final int index, final double element);\npublic static T[] remove(final T[] array, final int index);\npublic static T[] removeElement(final T[] array, final Object element);\npublic static boolean[] remove(final boolean[] array, final int index);\npublic static boolean[] removeElement(final boolean[] array, final boolean element);\npublic static byte[] remove(final byte[] array, final int index);\npublic static byte[] removeElement(final byte[] array, final byte element);\npublic static char[] remove(final char[] array, final int index);\npublic static char[] removeElement(final char[] array, final char element);\npublic static double[] remove(final double[] array, final int index);\npublic static double[] removeElement(final double[] array, final double element);\npublic static float[] remove(final float[] array, final int index);\npublic static float[] removeElement(final float[] array, final float element);\npublic static int[] remove(final int[] array, final int index);\npublic static int[] removeElement(final int[] array, final int element);\npublic static long[] remove(final long[] array, final int index);\npublic static long[] removeElement(final long[] array, final long element);\npublic static short[] remove(final short[] array, final int index);\npublic static short[] removeElement(final short[] array, final short element);\npublic static T[] removeAll(final T[] array, final int... indices);\npublic static T[] removeElements(final T[] array, final T... values);\npublic static byte[] removeAll(final byte[] array, final int... indices);\npublic static byte[] removeElements(final byte[] array, final byte... values);\npublic static short[] removeAll(final short[] array, final int... indices);\npublic static short[] removeElements(final short[] array, final short... values);\npublic static int[] removeAll(final int[] array, final int... indices);\npublic static int[] removeElements(final int[] array, final int... values);\npublic static char[] removeAll(final char[] array, final int... indices);\npublic static char[] removeElements(final char[] array, final char... values);\npublic static long[] removeAll(final long[] array, final int... indices);\npublic static long[] removeElements(final long[] array, final long... values);\npublic static float[] removeAll(final float[] array, final int... indices);\npublic static float[] removeElements(final float[] array, final float... values);\npublic static double[] removeAll(final double[] array, final int... indices);\npublic static double[] removeElements(final double[] array, final double... values);\npublic static boolean[] removeAll(final boolean[] array, final int... indices);\npublic static boolean[] removeElements(final boolean[] array, final boolean... values);\npublic static boolean isSorted(final T[] array);\npublic static boolean isSorted(final T[] array, final Comparator<T> comparator);\npublic static boolean isSorted(final int[] array);\npublic static boolean isSorted(final long[] array);\npublic static boolean isSorted(final short[] array);\npublic static boolean isSorted(final double[] array);\npublic static boolean isSorted(final float[] array);\npublic static boolean isSorted(final byte[] array);\npublic static boolean isSorted(final char[] array);\npublic static boolean isSorted(final boolean[] array);\npublic static boolean[] removeAllOccurences(final boolean[] array, final boolean element);\npublic static char[] removeAllOccurences(final char[] array, final char element);\npublic static byte[] removeAllOccurences(final byte[] array, final byte element);\npublic static short[] removeAllOccurences(final short[] array, final short element);\npublic static int[] removeAllOccurences(final int[] array, final int element);\npublic static long[] removeAllOccurences(final long[] array, final long element);\npublic static float[] removeAllOccurences(final float[] array, final float element);\npublic static double[] removeAllOccurences(final double[] array, final double element);\npublic static T[] removeAllOccurences(final T[] array, final T element);\npublic static String[] toStringArray(final Object[] array);\npublic static String[] toStringArray(final Object[] array, final String valueForNullElements);\npublic static boolean[] insert(final int index, final boolean[] array, final boolean... values);\npublic static byte[] insert(final int index, final byte[] array, final byte... values);\npublic static char[] insert(final int index, final char[] array, final char... values);\npublic static double[] insert(final int index, final double[] array, final double... values);\npublic static float[] insert(final int index, final float[] array, final float... values);\npublic static int[] insert(final int index, final int[] array, final int... values);\npublic static long[] insert(final int index, final long[] array, final long... values);\npublic static short[] insert(final int index, final short[] array, final short... values);\npublic static T[] insert(final int index, final T[] array, final T... values);\npublic static void shuffle(final Object[] array);\npublic static void shuffle(final Object[] array, final Random random);\npublic static void shuffle(final boolean[] array);\npublic static void shuffle(final boolean[] array, final Random random);\npublic static void shuffle(final byte[] array);\npublic static void shuffle(final byte[] array, final Random random);\npublic static void shuffle(final char[] array);\npublic static void shuffle(final char[] array, final Random random);\npublic static void shuffle(final short[] array);\npublic static void shuffle(final short[] array, final Random random);\npublic static void shuffle(final int[] array);\npublic static void shuffle(final int[] array, final Random random);\npublic static void shuffle(final long[] array);\npublic static void shuffle(final long[] array, final Random random);\npublic static void shuffle(final float[] array);\npublic static void shuffle(final float[] array, final Random random);\npublic static void shuffle(final double[] array);\npublic static void shuffle(final double[] array, final Random random);",
        "public_field": "/**\n * An empty immutable {@code Object} array.\n */\npublic static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];\n/**\n * An empty immutable {@code Class} array.\n */\npublic static final Class<?>[] EMPTY_CLASS_ARRAY = new Class[0];\n/**\n * An empty immutable {@code String} array.\n */\npublic static final String[] EMPTY_STRING_ARRAY = new String[0];\n/**\n * An empty immutable {@code long} array.\n */\npublic static final long[] EMPTY_LONG_ARRAY = new long[0];\n/**\n * An empty immutable {@code Long} array.\n */\npublic static final Long[] EMPTY_LONG_OBJECT_ARRAY = new Long[0];\n/**\n * An empty immutable {@code int} array.\n */\npublic static final int[] EMPTY_INT_ARRAY = new int[0];\n/**\n * An empty immutable {@code Integer} array.\n */\npublic static final Integer[] EMPTY_INTEGER_OBJECT_ARRAY = new Integer[0];\n/**\n * An empty immutable {@code short} array.\n */\npublic static final short[] EMPTY_SHORT_ARRAY = new short[0];\n/**\n * An empty immutable {@code Short} array.\n */\npublic static final Short[] EMPTY_SHORT_OBJECT_ARRAY = new Short[0];\n/**\n * An empty immutable {@code byte} array.\n */\npublic static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\n/**\n * An empty immutable {@code Byte} array.\n */\npublic static final Byte[] EMPTY_BYTE_OBJECT_ARRAY = new Byte[0];\n/**\n * An empty immutable {@code double} array.\n */\npublic static final double[] EMPTY_DOUBLE_ARRAY = new double[0];\n/**\n * An empty immutable {@code Double} array.\n */\npublic static final Double[] EMPTY_DOUBLE_OBJECT_ARRAY = new Double[0];\n/**\n * An empty immutable {@code float} array.\n */\npublic static final float[] EMPTY_FLOAT_ARRAY = new float[0];\n/**\n * An empty immutable {@code Float} array.\n */\npublic static final Float[] EMPTY_FLOAT_OBJECT_ARRAY = new Float[0];\n/**\n * An empty immutable {@code boolean} array.\n */\npublic static final boolean[] EMPTY_BOOLEAN_ARRAY = new boolean[0];\n/**\n * An empty immutable {@code Boolean} array.\n */\npublic static final Boolean[] EMPTY_BOOLEAN_OBJECT_ARRAY = new Boolean[0];\n/**\n * An empty immutable {@code char} array.\n */\npublic static final char[] EMPTY_CHAR_ARRAY = new char[0];\n/**\n * An empty immutable {@code Character} array.\n */\npublic static final Character[] EMPTY_CHARACTER_OBJECT_ARRAY = new Character[0];\n/**\n * The index value when an element is not found in a list or array: {@code -1}.\n * This value is returned by methods in this class and can also be used in comparisons with values returned by\n * various method from {@link java.util.List}.\n */\npublic static final int INDEX_NOT_FOUND = -1;",
        "Method_statement": "toMap(final Object() array)",
        "Method_name": "toMap",
        "Class_declaration": "public class ArrayUtils {\n",
        "constructors": "public ArrayUtils() {\n    super();\n}",
        "all_method_signature": "public ArrayUtils();\npublic static String toString(final Object array);\npublic static String toString(final Object array, final String stringIfNull);\npublic static int hashCode(final Object array);\npublic static boolean isEquals(final Object array1, final Object array2);\npublic static Map<Object, Object> toMap(final Object[] array);\npublic static T[] toArray(final T... items);\npublic static T[] clone(final T[] array);\npublic static long[] clone(final long[] array);\npublic static int[] clone(final int[] array);\npublic static short[] clone(final short[] array);\npublic static char[] clone(final char[] array);\npublic static byte[] clone(final byte[] array);\npublic static double[] clone(final double[] array);\npublic static float[] clone(final float[] array);\npublic static boolean[] clone(final boolean[] array);\npublic static T[] nullToEmpty(final T[] array, final Class<T[]> type);\npublic static Object[] nullToEmpty(final Object[] array);\npublic static Class<?>[] nullToEmpty(final Class<?>[] array);\npublic static String[] nullToEmpty(final String[] array);\npublic static long[] nullToEmpty(final long[] array);\npublic static int[] nullToEmpty(final int[] array);\npublic static short[] nullToEmpty(final short[] array);\npublic static char[] nullToEmpty(final char[] array);\npublic static byte[] nullToEmpty(final byte[] array);\npublic static double[] nullToEmpty(final double[] array);\npublic static float[] nullToEmpty(final float[] array);\npublic static boolean[] nullToEmpty(final boolean[] array);\npublic static Long[] nullToEmpty(final Long[] array);\npublic static Integer[] nullToEmpty(final Integer[] array);\npublic static Short[] nullToEmpty(final Short[] array);\npublic static Character[] nullToEmpty(final Character[] array);\npublic static Byte[] nullToEmpty(final Byte[] array);\npublic static Double[] nullToEmpty(final Double[] array);\npublic static Float[] nullToEmpty(final Float[] array);\npublic static Boolean[] nullToEmpty(final Boolean[] array);\npublic static T[] subarray(final T[] array, int startIndexInclusive, int endIndexExclusive);\npublic static long[] subarray(final long[] array, int startIndexInclusive, int endIndexExclusive);\npublic static int[] subarray(final int[] array, int startIndexInclusive, int endIndexExclusive);\npublic static short[] subarray(final short[] array, int startIndexInclusive, int endIndexExclusive);\npublic static char[] subarray(final char[] array, int startIndexInclusive, int endIndexExclusive);\npublic static byte[] subarray(final byte[] array, int startIndexInclusive, int endIndexExclusive);\npublic static double[] subarray(final double[] array, int startIndexInclusive, int endIndexExclusive);\npublic static float[] subarray(final float[] array, int startIndexInclusive, int endIndexExclusive);\npublic static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive);\npublic static boolean isSameLength(final Object[] array1, final Object[] array2);\npublic static boolean isSameLength(final long[] array1, final long[] array2);\npublic static boolean isSameLength(final int[] array1, final int[] array2);\npublic static boolean isSameLength(final short[] array1, final short[] array2);\npublic static boolean isSameLength(final char[] array1, final char[] array2);\npublic static boolean isSameLength(final byte[] array1, final byte[] array2);\npublic static boolean isSameLength(final double[] array1, final double[] array2);\npublic static boolean isSameLength(final float[] array1, final float[] array2);\npublic static boolean isSameLength(final boolean[] array1, final boolean[] array2);\npublic static int getLength(final Object array);\npublic static boolean isSameType(final Object array1, final Object array2);\npublic static void reverse(final Object[] array);\npublic static void reverse(final long[] array);\npublic static void reverse(final int[] array);\npublic static void reverse(final short[] array);\npublic static void reverse(final char[] array);\npublic static void reverse(final byte[] array);\npublic static void reverse(final double[] array);\npublic static void reverse(final float[] array);\npublic static void reverse(final boolean[] array);\npublic static void reverse(final boolean[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final byte[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final char[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final double[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final float[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final int[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final long[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final Object[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final short[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void swap(final Object[] array, final int offset1, final int offset2);\npublic static void swap(final long[] array, final int offset1, final int offset2);\npublic static void swap(final int[] array, final int offset1, final int offset2);\npublic static void swap(final short[] array, final int offset1, final int offset2);\npublic static void swap(final char[] array, final int offset1, final int offset2);\npublic static void swap(final byte[] array, final int offset1, final int offset2);\npublic static void swap(final double[] array, final int offset1, final int offset2);\npublic static void swap(final float[] array, final int offset1, final int offset2);\npublic static void swap(final boolean[] array, final int offset1, final int offset2);\npublic static void swap(final boolean[] array, int offset1, int offset2, int len);\npublic static void swap(final byte[] array, int offset1, int offset2, int len);\npublic static void swap(final char[] array, int offset1, int offset2, int len);\npublic static void swap(final double[] array, int offset1, int offset2, int len);\npublic static void swap(final float[] array, int offset1, int offset2, int len);\npublic static void swap(final int[] array, int offset1, int offset2, int len);\npublic static void swap(final long[] array, int offset1, int offset2, int len);\npublic static void swap(final Object[] array, int offset1, int offset2, int len);\npublic static void swap(final short[] array, int offset1, int offset2, int len);\npublic static void shift(final Object[] array, final int offset);\npublic static void shift(final long[] array, final int offset);\npublic static void shift(final int[] array, final int offset);\npublic static void shift(final short[] array, final int offset);\npublic static void shift(final char[] array, final int offset);\npublic static void shift(final byte[] array, final int offset);\npublic static void shift(final double[] array, final int offset);\npublic static void shift(final float[] array, final int offset);\npublic static void shift(final boolean[] array, final int offset);\npublic static void shift(final boolean[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final byte[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final char[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final double[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final float[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final int[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final long[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final Object[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final short[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static int indexOf(final Object[] array, final Object objectToFind);\npublic static int indexOf(final Object[] array, final Object objectToFind, int startIndex);\npublic static int lastIndexOf(final Object[] array, final Object objectToFind);\npublic static int lastIndexOf(final Object[] array, final Object objectToFind, int startIndex);\npublic static boolean contains(final Object[] array, final Object objectToFind);\npublic static int indexOf(final long[] array, final long valueToFind);\npublic static int indexOf(final long[] array, final long valueToFind, int startIndex);\npublic static int lastIndexOf(final long[] array, final long valueToFind);\npublic static int lastIndexOf(final long[] array, final long valueToFind, int startIndex);\npublic static boolean contains(final long[] array, final long valueToFind);\npublic static int indexOf(final int[] array, final int valueToFind);\npublic static int indexOf(final int[] array, final int valueToFind, int startIndex);\npublic static int lastIndexOf(final int[] array, final int valueToFind);\npublic static int lastIndexOf(final int[] array, final int valueToFind, int startIndex);\npublic static boolean contains(final int[] array, final int valueToFind);\npublic static int indexOf(final short[] array, final short valueToFind);\npublic static int indexOf(final short[] array, final short valueToFind, int startIndex);\npublic static int lastIndexOf(final short[] array, final short valueToFind);\npublic static int lastIndexOf(final short[] array, final short valueToFind, int startIndex);\npublic static boolean contains(final short[] array, final short valueToFind);\npublic static int indexOf(final char[] array, final char valueToFind);\npublic static int indexOf(final char[] array, final char valueToFind, int startIndex);\npublic static int lastIndexOf(final char[] array, final char valueToFind);\npublic static int lastIndexOf(final char[] array, final char valueToFind, int startIndex);\npublic static boolean contains(final char[] array, final char valueToFind);\npublic static int indexOf(final byte[] array, final byte valueToFind);\npublic static int indexOf(final byte[] array, final byte valueToFind, int startIndex);\npublic static int lastIndexOf(final byte[] array, final byte valueToFind);\npublic static int lastIndexOf(final byte[] array, final byte valueToFind, int startIndex);\npublic static boolean contains(final byte[] array, final byte valueToFind);\npublic static int indexOf(final double[] array, final double valueToFind);\npublic static int indexOf(final double[] array, final double valueToFind, final double tolerance);\npublic static int indexOf(final double[] array, final double valueToFind, int startIndex);\npublic static int indexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance);\npublic static int lastIndexOf(final double[] array, final double valueToFind);\npublic static int lastIndexOf(final double[] array, final double valueToFind, final double tolerance);\npublic static int lastIndexOf(final double[] array, final double valueToFind, int startIndex);\npublic static int lastIndexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance);\npublic static boolean contains(final double[] array, final double valueToFind);\npublic static boolean contains(final double[] array, final double valueToFind, final double tolerance);\npublic static int indexOf(final float[] array, final float valueToFind);\npublic static int indexOf(final float[] array, final float valueToFind, int startIndex);\npublic static int lastIndexOf(final float[] array, final float valueToFind);\npublic static int lastIndexOf(final float[] array, final float valueToFind, int startIndex);\npublic static boolean contains(final float[] array, final float valueToFind);\npublic static int indexOf(final boolean[] array, final boolean valueToFind);\npublic static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex);\npublic static int lastIndexOf(final boolean[] array, final boolean valueToFind);\npublic static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex);\npublic static boolean contains(final boolean[] array, final boolean valueToFind);\npublic static char[] toPrimitive(final Character[] array);\npublic static char[] toPrimitive(final Character[] array, final char valueForNull);\npublic static Character[] toObject(final char[] array);\npublic static long[] toPrimitive(final Long[] array);\npublic static long[] toPrimitive(final Long[] array, final long valueForNull);\npublic static Long[] toObject(final long[] array);\npublic static int[] toPrimitive(final Integer[] array);\npublic static int[] toPrimitive(final Integer[] array, final int valueForNull);\npublic static Integer[] toObject(final int[] array);\npublic static short[] toPrimitive(final Short[] array);\npublic static short[] toPrimitive(final Short[] array, final short valueForNull);\npublic static Short[] toObject(final short[] array);\npublic static byte[] toPrimitive(final Byte[] array);\npublic static byte[] toPrimitive(final Byte[] array, final byte valueForNull);\npublic static Byte[] toObject(final byte[] array);\npublic static double[] toPrimitive(final Double[] array);\npublic static double[] toPrimitive(final Double[] array, final double valueForNull);\npublic static Double[] toObject(final double[] array);\npublic static float[] toPrimitive(final Float[] array);\npublic static float[] toPrimitive(final Float[] array, final float valueForNull);\npublic static Float[] toObject(final float[] array);\npublic static Object toPrimitive(final Object array);\npublic static boolean[] toPrimitive(final Boolean[] array);\npublic static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull);\npublic static Boolean[] toObject(final boolean[] array);\npublic static boolean isEmpty(final Object[] array);\npublic static boolean isEmpty(final long[] array);\npublic static boolean isEmpty(final int[] array);\npublic static boolean isEmpty(final short[] array);\npublic static boolean isEmpty(final char[] array);\npublic static boolean isEmpty(final byte[] array);\npublic static boolean isEmpty(final double[] array);\npublic static boolean isEmpty(final float[] array);\npublic static boolean isEmpty(final boolean[] array);\npublic static boolean isNotEmpty(final T[] array);\npublic static boolean isNotEmpty(final long[] array);\npublic static boolean isNotEmpty(final int[] array);\npublic static boolean isNotEmpty(final short[] array);\npublic static boolean isNotEmpty(final char[] array);\npublic static boolean isNotEmpty(final byte[] array);\npublic static boolean isNotEmpty(final double[] array);\npublic static boolean isNotEmpty(final float[] array);\npublic static boolean isNotEmpty(final boolean[] array);\npublic static T[] addAll(final T[] array1, final T... array2);\npublic static boolean[] addAll(final boolean[] array1, final boolean... array2);\npublic static char[] addAll(final char[] array1, final char... array2);\npublic static byte[] addAll(final byte[] array1, final byte... array2);\npublic static short[] addAll(final short[] array1, final short... array2);\npublic static int[] addAll(final int[] array1, final int... array2);\npublic static long[] addAll(final long[] array1, final long... array2);\npublic static float[] addAll(final float[] array1, final float... array2);\npublic static double[] addAll(final double[] array1, final double... array2);\npublic static T[] add(final T[] array, final T element);\npublic static boolean[] add(final boolean[] array, final boolean element);\npublic static byte[] add(final byte[] array, final byte element);\npublic static char[] add(final char[] array, final char element);\npublic static double[] add(final double[] array, final double element);\npublic static float[] add(final float[] array, final float element);\npublic static int[] add(final int[] array, final int element);\npublic static long[] add(final long[] array, final long element);\npublic static short[] add(final short[] array, final short element);\nprivate static Object copyArrayGrow1(final Object array, final Class<?> newArrayComponentType);\npublic static T[] add(final T[] array, final int index, final T element);\npublic static boolean[] add(final boolean[] array, final int index, final boolean element);\npublic static char[] add(final char[] array, final int index, final char element);\npublic static byte[] add(final byte[] array, final int index, final byte element);\npublic static short[] add(final short[] array, final int index, final short element);\npublic static int[] add(final int[] array, final int index, final int element);\npublic static long[] add(final long[] array, final int index, final long element);\npublic static float[] add(final float[] array, final int index, final float element);\npublic static double[] add(final double[] array, final int index, final double element);\nprivate static Object add(final Object array, final int index, final Object element, final Class<?> clss);\npublic static T[] remove(final T[] array, final int index);\npublic static T[] removeElement(final T[] array, final Object element);\npublic static boolean[] remove(final boolean[] array, final int index);\npublic static boolean[] removeElement(final boolean[] array, final boolean element);\npublic static byte[] remove(final byte[] array, final int index);\npublic static byte[] removeElement(final byte[] array, final byte element);\npublic static char[] remove(final char[] array, final int index);\npublic static char[] removeElement(final char[] array, final char element);\npublic static double[] remove(final double[] array, final int index);\npublic static double[] removeElement(final double[] array, final double element);\npublic static float[] remove(final float[] array, final int index);\npublic static float[] removeElement(final float[] array, final float element);\npublic static int[] remove(final int[] array, final int index);\npublic static int[] removeElement(final int[] array, final int element);\npublic static long[] remove(final long[] array, final int index);\npublic static long[] removeElement(final long[] array, final long element);\npublic static short[] remove(final short[] array, final int index);\npublic static short[] removeElement(final short[] array, final short element);\nprivate static Object remove(final Object array, final int index);\npublic static T[] removeAll(final T[] array, final int... indices);\npublic static T[] removeElements(final T[] array, final T... values);\npublic static byte[] removeAll(final byte[] array, final int... indices);\npublic static byte[] removeElements(final byte[] array, final byte... values);\npublic static short[] removeAll(final short[] array, final int... indices);\npublic static short[] removeElements(final short[] array, final short... values);\npublic static int[] removeAll(final int[] array, final int... indices);\npublic static int[] removeElements(final int[] array, final int... values);\npublic static char[] removeAll(final char[] array, final int... indices);\npublic static char[] removeElements(final char[] array, final char... values);\npublic static long[] removeAll(final long[] array, final int... indices);\npublic static long[] removeElements(final long[] array, final long... values);\npublic static float[] removeAll(final float[] array, final int... indices);\npublic static float[] removeElements(final float[] array, final float... values);\npublic static double[] removeAll(final double[] array, final int... indices);\npublic static double[] removeElements(final double[] array, final double... values);\npublic static boolean[] removeAll(final boolean[] array, final int... indices);\npublic static boolean[] removeElements(final boolean[] array, final boolean... values);\n static Object removeAll(final Object array, final int... indices);\n static Object removeAll(final Object array, final BitSet indices);\npublic static boolean isSorted(final T[] array);\npublic static boolean isSorted(final T[] array, final Comparator<T> comparator);\npublic static boolean isSorted(final int[] array);\npublic static boolean isSorted(final long[] array);\npublic static boolean isSorted(final short[] array);\npublic static boolean isSorted(final double[] array);\npublic static boolean isSorted(final float[] array);\npublic static boolean isSorted(final byte[] array);\npublic static boolean isSorted(final char[] array);\npublic static boolean isSorted(final boolean[] array);\npublic static boolean[] removeAllOccurences(final boolean[] array, final boolean element);\npublic static char[] removeAllOccurences(final char[] array, final char element);\npublic static byte[] removeAllOccurences(final byte[] array, final byte element);\npublic static short[] removeAllOccurences(final short[] array, final short element);\npublic static int[] removeAllOccurences(final int[] array, final int element);\npublic static long[] removeAllOccurences(final long[] array, final long element);\npublic static float[] removeAllOccurences(final float[] array, final float element);\npublic static double[] removeAllOccurences(final double[] array, final double element);\npublic static T[] removeAllOccurences(final T[] array, final T element);\npublic static String[] toStringArray(final Object[] array);\npublic static String[] toStringArray(final Object[] array, final String valueForNullElements);\npublic static boolean[] insert(final int index, final boolean[] array, final boolean... values);\npublic static byte[] insert(final int index, final byte[] array, final byte... values);\npublic static char[] insert(final int index, final char[] array, final char... values);\npublic static double[] insert(final int index, final double[] array, final double... values);\npublic static float[] insert(final int index, final float[] array, final float... values);\npublic static int[] insert(final int index, final int[] array, final int... values);\npublic static long[] insert(final int index, final long[] array, final long... values);\npublic static short[] insert(final int index, final short[] array, final short... values);\npublic static T[] insert(final int index, final T[] array, final T... values);\npublic static void shuffle(final Object[] array);\npublic static void shuffle(final Object[] array, final Random random);\npublic static void shuffle(final boolean[] array);\npublic static void shuffle(final boolean[] array, final Random random);\npublic static void shuffle(final byte[] array);\npublic static void shuffle(final byte[] array, final Random random);\npublic static void shuffle(final char[] array);\npublic static void shuffle(final char[] array, final Random random);\npublic static void shuffle(final short[] array);\npublic static void shuffle(final short[] array, final Random random);\npublic static void shuffle(final int[] array);\npublic static void shuffle(final int[] array, final Random random);\npublic static void shuffle(final long[] array);\npublic static void shuffle(final long[] array, final Random random);\npublic static void shuffle(final float[] array);\npublic static void shuffle(final float[] array, final Random random);\npublic static void shuffle(final double[] array);\npublic static void shuffle(final double[] array, final Random random);",
        "Class_name": "ArrayUtils",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/ArrayUtils###toMap",
        "Parameter_num": "1",
        "all_Import_statements": "import java.lang.reflect.Array;\n\nimport java.util.Arrays;\n\nimport java.util.BitSet;\n\nimport java.util.Comparator;\n\nimport java.util.HashMap;\n\nimport java.util.Map;\n\nimport java.util.Random;\n\nimport org.apache.commons.lang3.builder.EqualsBuilder;\n\nimport org.apache.commons.lang3.builder.HashCodeBuilder;\n\nimport org.apache.commons.lang3.builder.ToStringBuilder;\n\nimport org.apache.commons.lang3.builder.ToStringStyle;\n\nimport org.apache.commons.lang3.math.NumberUtils;\n\nimport org.apache.commons.lang3.mutable.MutableInt;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
        "comment": "\n     * <p>Converts the given array into a {@link java.util.Map}. Each element of the array\n     * must be either a {@link java.util.Map.Entry} or an Array, containing at least two\n     * elements, where the first element is used as key and the second as\n     * value.\n     *\n     * <p>This method can be used to initialize:\n     * <pre>\n     * // Create a Map mapping colors.\n     * Map colorMap = ArrayUtils.toMap(new String[][] {\n     *     {\"RED\", \"#FF0000\"},\n     *     {\"GREEN\", \"#00FF00\"},\n     *     {\"BLUE\", \"#0000FF\"}});\n     * </pre>\n     *\n     * <p>This method returns {@code null} for a {@code null} input array.\n     *\n     * @param array  an array whose elements are either a {@link java.util.Map.Entry} or\n     *  an Array containing at least two elements, may be {@code null}\n     * @return a {@code Map} that was created from the array\n     * @throws IllegalArgumentException  if one element of this Array is\n     *  itself an Array containing less then two elements\n     * @throws IllegalArgumentException  if the array contains elements other\n     *  than {@link java.util.Map.Entry} and an Array\n     ",
        "packageName": "org.apache.commons.lang3",
        "method_signature": "public static Map<Object, Object> toMap(final Object[] array);",
        "Junit_version": "4",
        "returnType": "Map<Object,Object>"
    },
    {
        "Method_body": "public static CharSet getInstance(final String... setStrs) {\n    if (setStrs == null) {\n        return null;\n    }\n    if (setStrs.length == 1) {\n        final CharSet common = COMMON.get(setStrs[0]);\n        if (common != null) {\n            return common;\n        }\n    }\n    return new CharSet(setStrs);\n}",
        "all_field_declaration": "/**\n * Required for serialization support. Lang version 2.0.\n *\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = 5947847346149275958L;\n/**\n * A CharSet defining no characters.\n * @since 2.0\n */\npublic static final CharSet EMPTY = new CharSet((String) null);\n/**\n * A CharSet defining ASCII alphabetic characters \"a-zA-Z\".\n * @since 2.0\n */\npublic static final CharSet ASCII_ALPHA = new CharSet(\"a-zA-Z\");\n/**\n * A CharSet defining ASCII alphabetic characters \"a-z\".\n * @since 2.0\n */\npublic static final CharSet ASCII_ALPHA_LOWER = new CharSet(\"a-z\");\n/**\n * A CharSet defining ASCII alphabetic characters \"A-Z\".\n * @since 2.0\n */\npublic static final CharSet ASCII_ALPHA_UPPER = new CharSet(\"A-Z\");\n/**\n * A CharSet defining ASCII alphabetic characters \"0-9\".\n * @since 2.0\n */\npublic static final CharSet ASCII_NUMERIC = new CharSet(\"0-9\");\n/**\n * A Map of the common cases used in the factory.\n * Subclasses can add more common patterns if desired\n * @since 2.0\n */\nprotected static final Map<String, CharSet> COMMON = new HashMap<String, CharSet>();\n/**\n * The set of CharRange objects.\n */\nprivate final Set<CharRange> set = new HashSet<CharRange>();",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "3",
        "Filed": "protected static final Map<String, CharSet> COMMON = new HashMap<String, CharSet>();private final Set<CharRange> set = new HashSet<CharRange>();",
        "Parameter_type": "String",
        "Import_statements": "import java.util.Set;\n",
        "public_method_signature": "public static CharSet getInstance(final String... setStrs);\npublic boolean contains(final char ch);\npublic boolean equals(final Object obj);\npublic int hashCode();\npublic String toString();",
        "public_field": "/**\n * A CharSet defining no characters.\n * @since 2.0\n */\npublic static final CharSet EMPTY = new CharSet((String) null);\n/**\n * A CharSet defining ASCII alphabetic characters \"a-zA-Z\".\n * @since 2.0\n */\npublic static final CharSet ASCII_ALPHA = new CharSet(\"a-zA-Z\");\n/**\n * A CharSet defining ASCII alphabetic characters \"a-z\".\n * @since 2.0\n */\npublic static final CharSet ASCII_ALPHA_LOWER = new CharSet(\"a-z\");\n/**\n * A CharSet defining ASCII alphabetic characters \"A-Z\".\n * @since 2.0\n */\npublic static final CharSet ASCII_ALPHA_UPPER = new CharSet(\"A-Z\");\n/**\n * A CharSet defining ASCII alphabetic characters \"0-9\".\n * @since 2.0\n */\npublic static final CharSet ASCII_NUMERIC = new CharSet(\"0-9\");",
        "Method_statement": "getInstance(final String... setStrs)",
        "Method_name": "getInstance",
        "Class_declaration": "public class CharSet {\n",
        "constructors": "protected CharSet(final String... set) {\n    super();\n    for (final String s : set) {\n        add(s);\n    }\n}",
        "all_method_signature": "public static CharSet getInstance(final String... setStrs);\nprotected CharSet(final String... set);\nprotected void add(final String str);\n CharRange[] getCharRanges();\npublic boolean contains(final char ch);\npublic boolean equals(final Object obj);\npublic int hashCode();\npublic String toString();",
        "Class_name": "CharSet",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/CharSet###getInstance",
        "Parameter_num": "1",
        "all_Import_statements": "import java.io.Serializable;\n\nimport java.util.HashMap;\n\nimport java.util.HashSet;\n\nimport java.util.Map;\n\nimport java.util.Set;\n",
        "comment": "\n     * <p>Factory method to create a new CharSet using a special syntax.</p>\n     *\n     * <ul>\n     *  <li>{@code null} or empty string (\"\")\n     * - set containing no characters</li>\n     *  <li>Single character, such as \"a\"\n     *  - set containing just that character</li>\n     *  <li>Multi character, such as \"a-e\"\n     *  - set containing characters from one character to the other</li>\n     *  <li>Negated, such as \"^a\" or \"^a-e\"\n     *  - set containing all characters except those defined</li>\n     *  <li>Combinations, such as \"abe-g\"\n     *  - set containing all the characters from the individual sets</li>\n     * </ul>\n     *\n     * <p>The matching order is:</p>\n     * <ol>\n     *  <li>Negated multi character range, such as \"^a-e\"\n     *  <li>Ordinary multi character range, such as \"a-e\"\n     *  <li>Negated single character, such as \"^a\"\n     *  <li>Ordinary single character, such as \"a\"\n     * </ol>\n     *\n     * <p>Matching works left to right. Once a match is found the\n     * search starts again from the next character.</p>\n     *\n     * <p>If the same range is defined twice using the same syntax, only\n     * one range will be kept.\n     * Thus, \"a-ca-c\" creates only one range of \"a-c\".</p>\n     *\n     * <p>If the start and end of a range are in the wrong order,\n     * they are reversed. Thus \"a-e\" is the same as \"e-a\".\n     * As a result, \"a-ee-a\" would create only one range,\n     * as the \"a-e\" and \"e-a\" are the same.</p>\n     *\n     * <p>The set of characters represented is the union of the specified ranges.</p>\n     *\n     * <p>There are two ways to add a literal negation character ({@code ^}):</p>\n     * <ul>\n     *     <li>As the last character in a string, e.g. {@code CharSet.getInstance(\"a-z^\")}</li>\n     *     <li>As a separate element, e.g. {@code CharSet.getInstance(\"^\",\"a-z\")}</li>\n     * </ul>\n     *\n     * <p>Examples using the negation character:</p>\n     * <pre>\n     *     CharSet.getInstance(\"^a-c\").contains('a') = false\n     *     CharSet.getInstance(\"^a-c\").contains('d') = true\n     *     CharSet.getInstance(\"^^a-c\").contains('a') = true // (only '^' is negated)\n     *     CharSet.getInstance(\"^^a-c\").contains('^') = false\n     *     CharSet.getInstance(\"^a-cd-f\").contains('d') = true\n     *     CharSet.getInstance(\"a-c^\").contains('^') = true\n     *     CharSet.getInstance(\"^\", \"a-c\").contains('^') = true\n     * </pre>\n     *\n     * <p>All CharSet objects returned by this method will be immutable.</p>\n     *\n     * @param setStrs  Strings to merge into the set, may be null\n     * @return a CharSet instance\n     * @since 2.4\n     ",
        "packageName": "org.apache.commons.lang3",
        "method_signature": "public static CharSet getInstance(final String... setStrs);",
        "Junit_version": "4",
        "returnType": "CharSet"
    },
    {
        "Method_body": "public CompareToBuilder appendSuper(final int superCompareTo) {\n    if (comparison != 0) {\n        return this;\n    }\n    comparison = superCompareTo;\n    return this;\n}",
        "all_field_declaration": "/**\n * Current state of the comparison as appended fields are checked.\n */\nprivate int comparison;",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "3",
        "Filed": "private int comparison;",
        "Parameter_type": "int",
        "Import_statements": "",
        "public_method_signature": "public CompareToBuilder();\npublic static int reflectionCompare(final Object lhs, final Object rhs);\npublic static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients);\npublic static int reflectionCompare(final Object lhs, final Object rhs, final Collection<String> excludeFields);\npublic static int reflectionCompare(final Object lhs, final Object rhs, final String... excludeFields);\npublic static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields);\npublic CompareToBuilder appendSuper(final int superCompareTo);\npublic CompareToBuilder append(final Object lhs, final Object rhs);\npublic CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator);\npublic CompareToBuilder append(final long lhs, final long rhs);\npublic CompareToBuilder append(final int lhs, final int rhs);\npublic CompareToBuilder append(final short lhs, final short rhs);\npublic CompareToBuilder append(final char lhs, final char rhs);\npublic CompareToBuilder append(final byte lhs, final byte rhs);\npublic CompareToBuilder append(final double lhs, final double rhs);\npublic CompareToBuilder append(final float lhs, final float rhs);\npublic CompareToBuilder append(final boolean lhs, final boolean rhs);\npublic CompareToBuilder append(final Object[] lhs, final Object[] rhs);\npublic CompareToBuilder append(final Object[] lhs, final Object[] rhs, final Comparator<?> comparator);\npublic CompareToBuilder append(final long[] lhs, final long[] rhs);\npublic CompareToBuilder append(final int[] lhs, final int[] rhs);\npublic CompareToBuilder append(final short[] lhs, final short[] rhs);\npublic CompareToBuilder append(final char[] lhs, final char[] rhs);\npublic CompareToBuilder append(final byte[] lhs, final byte[] rhs);\npublic CompareToBuilder append(final double[] lhs, final double[] rhs);\npublic CompareToBuilder append(final float[] lhs, final float[] rhs);\npublic CompareToBuilder append(final boolean[] lhs, final boolean[] rhs);\npublic int toComparison();\npublic Integer build();",
        "public_field": "",
        "Method_statement": "appendSuper(final int superCompareTo)",
        "Method_name": "appendSuper",
        "Class_declaration": "public class CompareToBuilder {\n",
        "constructors": "public CompareToBuilder() {\n    super();\n    comparison = 0;\n}",
        "all_method_signature": "public CompareToBuilder();\npublic static int reflectionCompare(final Object lhs, final Object rhs);\npublic static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients);\npublic static int reflectionCompare(final Object lhs, final Object rhs, final Collection<String> excludeFields);\npublic static int reflectionCompare(final Object lhs, final Object rhs, final String... excludeFields);\npublic static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields);\nprivate static void reflectionAppend(final Object lhs, final Object rhs, final Class<?> clazz, final CompareToBuilder builder, final boolean useTransients, final String[] excludeFields);\npublic CompareToBuilder appendSuper(final int superCompareTo);\npublic CompareToBuilder append(final Object lhs, final Object rhs);\npublic CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator);\nprivate void appendArray(final Object lhs, final Object rhs, final Comparator<?> comparator);\npublic CompareToBuilder append(final long lhs, final long rhs);\npublic CompareToBuilder append(final int lhs, final int rhs);\npublic CompareToBuilder append(final short lhs, final short rhs);\npublic CompareToBuilder append(final char lhs, final char rhs);\npublic CompareToBuilder append(final byte lhs, final byte rhs);\npublic CompareToBuilder append(final double lhs, final double rhs);\npublic CompareToBuilder append(final float lhs, final float rhs);\npublic CompareToBuilder append(final boolean lhs, final boolean rhs);\npublic CompareToBuilder append(final Object[] lhs, final Object[] rhs);\npublic CompareToBuilder append(final Object[] lhs, final Object[] rhs, final Comparator<?> comparator);\npublic CompareToBuilder append(final long[] lhs, final long[] rhs);\npublic CompareToBuilder append(final int[] lhs, final int[] rhs);\npublic CompareToBuilder append(final short[] lhs, final short[] rhs);\npublic CompareToBuilder append(final char[] lhs, final char[] rhs);\npublic CompareToBuilder append(final byte[] lhs, final byte[] rhs);\npublic CompareToBuilder append(final double[] lhs, final double[] rhs);\npublic CompareToBuilder append(final float[] lhs, final float[] rhs);\npublic CompareToBuilder append(final boolean[] lhs, final boolean[] rhs);\npublic int toComparison();\npublic Integer build();",
        "Class_name": "CompareToBuilder",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/builder/CompareToBuilder###appendSuper",
        "Parameter_num": "1",
        "all_Import_statements": "import java.lang.reflect.AccessibleObject;\n\nimport java.lang.reflect.Field;\n\nimport java.lang.reflect.Modifier;\n\nimport java.util.Collection;\n\nimport java.util.Comparator;\n\nimport org.apache.commons.lang3.ArrayUtils;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
        "comment": "\n     * <p>Appends to the <code>builder</code> the <code>compareTo(Object)</code>\n     * result of the superclass.</p>\n     *\n     * @param superCompareTo  result of calling <code>super.compareTo(Object)</code>\n     * @return this - used to chain append calls\n     * @since 2.0\n     ",
        "packageName": "org.apache.commons.lang3.builder",
        "method_signature": "public CompareToBuilder appendSuper(final int superCompareTo);",
        "Junit_version": "4",
        "returnType": "CompareToBuilder"
    },
    {
        "Method_body": "public static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts) {\n    if (src.length == 0 && srcPos == 0 || 0 == nInts) {\n        return dstInit;\n    }\n    if ((nInts - 1) * 32 + dstPos >= 64) {\n        throw new IllegalArgumentException(\"(nInts-1)*32+dstPos is greater or equal to than 64\");\n    }\n    long out = dstInit;\n    for (int i = 0; i < nInts; i++) {\n        final int shift = i * 32 + dstPos;\n        final long bits = (0xffffffffL & src[i + srcPos]) << shift;\n        final long mask = 0xffffffffL << shift;\n        out = (out & ~mask) | bits;\n    }\n    return out;\n}",
        "all_field_declaration": "",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "5",
        "Filed": "",
        "Parameter_type": "int[],int,long,int,int",
        "Import_statements": "",
        "public_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
        "public_field": "",
        "Method_statement": "intArrayToLong(final int() src, final int srcPos, final long dstInit, final int dstPos, final int nInts)",
        "Method_name": "intArrayToLong",
        "Class_declaration": "public class Conversion {\n",
        "constructors": "",
        "all_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
        "Class_name": "Conversion",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Conversion###intArrayToLong",
        "Parameter_num": "5",
        "all_Import_statements": "import java.util.UUID;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
        "comment": "\n     * <p>\n     * Converts an array of int into a long using the default (little endian, Lsb0) byte and bit\n     * ordering.\n     * </p>\n     *\n     * @param src the int array to convert\n     * @param srcPos the position in {@code src}, in int unit, from where to start the\n     *            conversion\n     * @param dstInit initial value of the destination long\n     * @param dstPos the position of the lsb, in bits, in the result long\n     * @param nInts the number of ints to convert\n     * @return a long containing the selected bits\n     * @throws IllegalArgumentException if {@code (nInts-1)*32+dstPos >= 64}\n     * @throws NullPointerException if {@code src} is {@code null}\n     * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nInts > src.length}\n     ",
        "packageName": "org.apache.commons.lang3",
        "method_signature": "public static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);",
        "Junit_version": "4",
        "returnType": "long"
    },
    {
        "Method_body": "public static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes) {\n    if (0 == nBytes) {\n        return dst;\n    }\n    if ((nBytes - 1) * 8 + srcPos >= 32) {\n        throw new IllegalArgumentException(\"(nBytes-1)*8+srcPos is greater or equal to than 32\");\n    }\n    for (int i = 0; i < nBytes; i++) {\n        final int shift = i * 8 + srcPos;\n        dst[dstPos + i] = (byte) (0xff & (src >> shift));\n    }\n    return dst;\n}",
        "all_field_declaration": "",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "4",
        "Filed": "",
        "Parameter_type": "int,int,byte[],int,int",
        "Import_statements": "",
        "public_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
        "public_field": "",
        "Method_statement": "intToByteArray(final int src, final int srcPos, final byte() dst, final int dstPos, final int nBytes)",
        "Method_name": "intToByteArray",
        "Class_declaration": "public class Conversion {\n",
        "constructors": "",
        "all_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
        "Class_name": "Conversion",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Conversion###intToByteArray",
        "Parameter_num": "5",
        "all_Import_statements": "import java.util.UUID;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
        "comment": "\n     * <p>\n     * Converts an int into an array of byte using the default (little endian, Lsb0) byte and bit\n     * ordering.\n     * </p>\n     *\n     * @param src the int to convert\n     * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n     * @param dst the destination array\n     * @param dstPos the position in {@code dst} where to copy the result\n     * @param nBytes the number of bytes to copy to {@code dst}, must be smaller or equal to the\n     *            width of the input (from srcPos to msb)\n     * @return {@code dst}\n     * @throws NullPointerException if {@code dst} is {@code null}\n     * @throws IllegalArgumentException if {@code (nBytes-1)*8+srcPos >= 32}\n     * @throws ArrayIndexOutOfBoundsException if {@code dstPos + nBytes > dst.length}\n     ",
        "packageName": "org.apache.commons.lang3",
        "method_signature": "public static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);",
        "Junit_version": "4",
        "returnType": "byte[]"
    },
    {
        "Method_body": "public static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts) {\n    if (0 == nShorts) {\n        return dst;\n    }\n    if ((nShorts - 1) * 16 + srcPos >= 32) {\n        throw new IllegalArgumentException(\"(nShorts-1)*16+srcPos is greater or equal to than 32\");\n    }\n    for (int i = 0; i < nShorts; i++) {\n        final int shift = i * 16 + srcPos;\n        dst[dstPos + i] = (short) (0xffff & (src >> shift));\n    }\n    return dst;\n}",
        "all_field_declaration": "",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "4",
        "Filed": "",
        "Parameter_type": "int,int,short[],int,int",
        "Import_statements": "",
        "public_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
        "public_field": "",
        "Method_statement": "intToShortArray(final int src, final int srcPos, final short() dst, final int dstPos, final int nShorts)",
        "Method_name": "intToShortArray",
        "Class_declaration": "public class Conversion {\n",
        "constructors": "",
        "all_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
        "Class_name": "Conversion",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Conversion###intToShortArray",
        "Parameter_num": "5",
        "all_Import_statements": "import java.util.UUID;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
        "comment": "\n     * <p>\n     * Converts an int into an array of short using the default (little endian, Lsb0) byte and\n     * bit ordering.\n     * </p>\n     *\n     * @param src the int to convert\n     * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n     * @param dst the destination array\n     * @param dstPos the position in {@code dst} where to copy the result\n     * @param nShorts the number of shorts to copy to {@code dst}, must be smaller or equal to\n     *            the width of the input (from srcPos to msb)\n     * @return {@code dst}\n     * @throws NullPointerException if {@code dst} is {@code null}\n     * @throws IllegalArgumentException if {@code (nShorts-1)*16+srcPos >= 32}\n     * @throws ArrayIndexOutOfBoundsException if {@code dstPos + nShorts > dst.length}\n     ",
        "packageName": "org.apache.commons.lang3",
        "method_signature": "public static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);",
        "Junit_version": "4",
        "returnType": "short[]"
    },
    {
        "Method_body": "public static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes) {\n    if (0 == nBytes) {\n        return dst;\n    }\n    if ((nBytes - 1) * 8 + srcPos >= 64) {\n        throw new IllegalArgumentException(\"(nBytes-1)*8+srcPos is greater or equal to than 64\");\n    }\n    for (int i = 0; i < nBytes; i++) {\n        final int shift = i * 8 + srcPos;\n        dst[dstPos + i] = (byte) (0xff & (src >> shift));\n    }\n    return dst;\n}",
        "all_field_declaration": "",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "4",
        "Filed": "",
        "Parameter_type": "long,int,byte[],int,int",
        "Import_statements": "",
        "public_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
        "public_field": "",
        "Method_statement": "longToByteArray(final long src, final int srcPos, final byte() dst, final int dstPos, final int nBytes)",
        "Method_name": "longToByteArray",
        "Class_declaration": "public class Conversion {\n",
        "constructors": "",
        "all_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
        "Class_name": "Conversion",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Conversion###longToByteArray",
        "Parameter_num": "5",
        "all_Import_statements": "import java.util.UUID;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
        "comment": "\n     * <p>\n     * Converts a long into an array of byte using the default (little endian, Lsb0) byte and\n     * bit ordering.\n     * </p>\n     *\n     * @param src the long to convert\n     * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n     * @param dst the destination array\n     * @param dstPos the position in {@code dst} where to copy the result\n     * @param nBytes the number of bytes to copy to {@code dst}, must be smaller or equal to the\n     *            width of the input (from srcPos to msb)\n     * @return {@code dst}\n     * @throws NullPointerException if {@code dst} is {@code null}\n     * @throws IllegalArgumentException if {@code (nBytes-1)*8+srcPos >= 64}\n     * @throws ArrayIndexOutOfBoundsException if {@code dstPos + nBytes > dst.length}\n     ",
        "packageName": "org.apache.commons.lang3",
        "method_signature": "public static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);",
        "Junit_version": "4",
        "returnType": "byte[]"
    },
    {
        "Method_body": "public static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts) {\n    if (0 == nShorts) {\n        return dst;\n    }\n    if ((nShorts - 1) * 16 + srcPos >= 64) {\n        throw new IllegalArgumentException(\"(nShorts-1)*16+srcPos is greater or equal to than 64\");\n    }\n    for (int i = 0; i < nShorts; i++) {\n        final int shift = i * 16 + srcPos;\n        dst[dstPos + i] = (short) (0xffff & (src >> shift));\n    }\n    return dst;\n}",
        "all_field_declaration": "",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "4",
        "Filed": "",
        "Parameter_type": "long,int,short[],int,int",
        "Import_statements": "",
        "public_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
        "public_field": "",
        "Method_statement": "longToShortArray(final long src, final int srcPos, final short() dst, final int dstPos, final int nShorts)",
        "Method_name": "longToShortArray",
        "Class_declaration": "public class Conversion {\n",
        "constructors": "",
        "all_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
        "Class_name": "Conversion",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Conversion###longToShortArray",
        "Parameter_num": "5",
        "all_Import_statements": "import java.util.UUID;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
        "comment": "\n     * <p>\n     * Converts a long into an array of short using the default (little endian, Lsb0) byte and\n     * bit ordering.\n     * </p>\n     *\n     * @param src the long to convert\n     * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n     * @param dst the destination array\n     * @param dstPos the position in {@code dst} where to copy the result\n     * @param nShorts the number of shorts to copy to {@code dst}, must be smaller or equal to\n     *            the width of the input (from srcPos to msb)\n     * @return {@code dst}\n     * @throws NullPointerException if {@code dst} is {@code null}\n     * @throws IllegalArgumentException if {@code (nShorts-1)*16+srcPos >= 64}\n     * @throws ArrayIndexOutOfBoundsException if {@code dstPos + nShorts > dst.length}\n     ",
        "packageName": "org.apache.commons.lang3",
        "method_signature": "public static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);",
        "Junit_version": "4",
        "returnType": "short[]"
    },
    {
        "Method_body": "public static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes) {\n    if (0 == nBytes) {\n        return dst;\n    }\n    if ((nBytes - 1) * 8 + srcPos >= 16) {\n        throw new IllegalArgumentException(\"(nBytes-1)*8+srcPos is greater or equal to than 16\");\n    }\n    for (int i = 0; i < nBytes; i++) {\n        final int shift = i * 8 + srcPos;\n        dst[dstPos + i] = (byte) (0xff & (src >> shift));\n    }\n    return dst;\n}",
        "all_field_declaration": "",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "4",
        "Filed": "",
        "Parameter_type": "short,int,byte[],int,int",
        "Import_statements": "",
        "public_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
        "public_field": "",
        "Method_statement": "shortToByteArray(final short src, final int srcPos, final byte() dst, final int dstPos, final int nBytes)",
        "Method_name": "shortToByteArray",
        "Class_declaration": "public class Conversion {\n",
        "constructors": "",
        "all_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
        "Class_name": "Conversion",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Conversion###shortToByteArray",
        "Parameter_num": "5",
        "all_Import_statements": "import java.util.UUID;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
        "comment": "\n     * <p>\n     * Converts a short into an array of byte using the default (little endian, Lsb0) byte and\n     * bit ordering.\n     * </p>\n     *\n     * @param src the short to convert\n     * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n     * @param dst the destination array\n     * @param dstPos the position in {@code dst} where to copy the result\n     * @param nBytes the number of bytes to copy to {@code dst}, must be smaller or equal to the\n     *            width of the input (from srcPos to msb)\n     * @return {@code dst}\n     * @throws NullPointerException if {@code dst} is {@code null}\n     * @throws IllegalArgumentException if {@code (nBytes-1)*8+srcPos >= 16}\n     * @throws ArrayIndexOutOfBoundsException if {@code dstPos + nBytes > dst.length}\n     ",
        "packageName": "org.apache.commons.lang3",
        "method_signature": "public static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);",
        "Junit_version": "4",
        "returnType": "byte[]"
    },
    {
        "Method_body": "public static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) {\n    if (0 == nHexs) {\n        return dstInit;\n    }\n    if ((nHexs - 1) * 4 + srcPos >= 16) {\n        throw new IllegalArgumentException(\"(nHexs-1)*4+srcPos is greater or equal to than 16\");\n    }\n    final StringBuilder sb = new StringBuilder(dstInit);\n    int append = sb.length();\n    for (int i = 0; i < nHexs; i++) {\n        final int shift = i * 4 + srcPos;\n        final int bits = 0xF & (src >> shift);\n        if (dstPos + i == append) {\n            ++append;\n            sb.append(intToHexDigit(bits));\n        } else {\n            sb.setCharAt(dstPos + i, intToHexDigit(bits));\n        }\n    }\n    return sb.toString();\n}",
        "all_field_declaration": "",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "6",
        "Filed": "",
        "Parameter_type": "short,int,String,int,int",
        "Import_statements": "",
        "public_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
        "public_field": "",
        "Method_statement": "shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs)",
        "Method_name": "shortToHex",
        "Class_declaration": "public class Conversion {\n",
        "constructors": "",
        "all_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
        "Class_name": "Conversion",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Conversion###shortToHex",
        "Parameter_num": "5",
        "all_Import_statements": "import java.util.UUID;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
        "comment": "\n     * <p>\n     * Converts a short into an array of Char using the default (little endian, Lsb0) byte and\n     * bit ordering.\n     * </p>\n     *\n     * @param src the short to convert\n     * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n     * @param dstInit the initial value for the result String\n     * @param dstPos the position in {@code dst} where to copy the result\n     * @param nHexs the number of Chars to copy to {@code dst}, must be smaller or equal to the\n     *            width of the input (from srcPos to msb)\n     * @return {@code dst}\n     * @throws IllegalArgumentException if {@code (nHexs-1)*4+srcPos >= 16}\n     * @throws StringIndexOutOfBoundsException if {@code dst.init.length() < dstPos}\n     ",
        "packageName": "org.apache.commons.lang3",
        "method_signature": "public static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);",
        "Junit_version": "4",
        "returnType": "String"
    },
    {
        "Method_body": "public static Calendar truncate(final Calendar date, final int field) {\n    if (date == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    final Calendar truncated = (Calendar) date.clone();\n    modify(truncated, field, ModifyType.TRUNCATE);\n    return truncated;\n}",
        "all_field_declaration": "/**\n * Number of milliseconds in a standard second.\n * @since 2.1\n */\npublic static final long MILLIS_PER_SECOND = 1000;\n/**\n * Number of milliseconds in a standard minute.\n * @since 2.1\n */\npublic static final long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND;\n/**\n * Number of milliseconds in a standard hour.\n * @since 2.1\n */\npublic static final long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE;\n/**\n * Number of milliseconds in a standard day.\n * @since 2.1\n */\npublic static final long MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR;\n/**\n * This is half a month, so this represents whether a date is in the top\n * or bottom half of the month.\n */\npublic static final int SEMI_MONTH = 1001;\nprivate static final int[][] fields = { { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */\n}, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } };\n/**\n * A week range, starting on Sunday.\n */\npublic static final int RANGE_WEEK_SUNDAY = 1;\n/**\n * A week range, starting on Monday.\n */\npublic static final int RANGE_WEEK_MONDAY = 2;\n/**\n * A week range, starting on the day focused.\n */\npublic static final int RANGE_WEEK_RELATIVE = 3;\n/**\n * A week range, centered around the day focused.\n */\npublic static final int RANGE_WEEK_CENTER = 4;\n/**\n * A month range, the week starting on Sunday.\n */\npublic static final int RANGE_MONTH_SUNDAY = 5;\n/**\n * A month range, the week starting on Monday.\n */\npublic static final int RANGE_MONTH_MONDAY = 6;",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "4",
        "Filed": "",
        "Parameter_type": "Calendar,int",
        "Import_statements": "import java.util.Calendar;\n",
        "public_method_signature": "public DateUtils();\npublic static boolean isSameDay(final Date date1, final Date date2);\npublic static boolean isSameDay(final Calendar cal1, final Calendar cal2);\npublic static boolean isSameInstant(final Date date1, final Date date2);\npublic static boolean isSameInstant(final Calendar cal1, final Calendar cal2);\npublic static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2);\npublic static Date parseDate(final String str, final String... parsePatterns) throws ParseException;\npublic static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException;\npublic static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException;\npublic static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException;\npublic static Date addYears(final Date date, final int amount);\npublic static Date addMonths(final Date date, final int amount);\npublic static Date addWeeks(final Date date, final int amount);\npublic static Date addDays(final Date date, final int amount);\npublic static Date addHours(final Date date, final int amount);\npublic static Date addMinutes(final Date date, final int amount);\npublic static Date addSeconds(final Date date, final int amount);\npublic static Date addMilliseconds(final Date date, final int amount);\npublic static Date setYears(final Date date, final int amount);\npublic static Date setMonths(final Date date, final int amount);\npublic static Date setDays(final Date date, final int amount);\npublic static Date setHours(final Date date, final int amount);\npublic static Date setMinutes(final Date date, final int amount);\npublic static Date setSeconds(final Date date, final int amount);\npublic static Date setMilliseconds(final Date date, final int amount);\npublic static Calendar toCalendar(final Date date);\npublic static Calendar toCalendar(final Date date, final TimeZone tz);\npublic static Date round(final Date date, final int field);\npublic static Calendar round(final Calendar date, final int field);\npublic static Date round(final Object date, final int field);\npublic static Date truncate(final Date date, final int field);\npublic static Calendar truncate(final Calendar date, final int field);\npublic static Date truncate(final Object date, final int field);\npublic static Date ceiling(final Date date, final int field);\npublic static Calendar ceiling(final Calendar date, final int field);\npublic static Date ceiling(final Object date, final int field);\npublic static Iterator<Calendar> iterator(final Date focus, final int rangeStyle);\npublic static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle);\npublic static Iterator<?> iterator(final Object focus, final int rangeStyle);\npublic static long getFragmentInMilliseconds(final Date date, final int fragment);\npublic static long getFragmentInSeconds(final Date date, final int fragment);\npublic static long getFragmentInMinutes(final Date date, final int fragment);\npublic static long getFragmentInHours(final Date date, final int fragment);\npublic static long getFragmentInDays(final Date date, final int fragment);\npublic static long getFragmentInMilliseconds(final Calendar calendar, final int fragment);\npublic static long getFragmentInSeconds(final Calendar calendar, final int fragment);\npublic static long getFragmentInMinutes(final Calendar calendar, final int fragment);\npublic static long getFragmentInHours(final Calendar calendar, final int fragment);\npublic static long getFragmentInDays(final Calendar calendar, final int fragment);\npublic static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field);\npublic static boolean truncatedEquals(final Date date1, final Date date2, final int field);\npublic static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field);\npublic static int truncatedCompareTo(final Date date1, final Date date2, final int field);",
        "public_field": "/**\n * Number of milliseconds in a standard second.\n * @since 2.1\n */\npublic static final long MILLIS_PER_SECOND = 1000;\n/**\n * Number of milliseconds in a standard minute.\n * @since 2.1\n */\npublic static final long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND;\n/**\n * Number of milliseconds in a standard hour.\n * @since 2.1\n */\npublic static final long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE;\n/**\n * Number of milliseconds in a standard day.\n * @since 2.1\n */\npublic static final long MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR;\n/**\n * This is half a month, so this represents whether a date is in the top\n * or bottom half of the month.\n */\npublic static final int SEMI_MONTH = 1001;\n/**\n * A week range, starting on Sunday.\n */\npublic static final int RANGE_WEEK_SUNDAY = 1;\n/**\n * A week range, starting on Monday.\n */\npublic static final int RANGE_WEEK_MONDAY = 2;\n/**\n * A week range, starting on the day focused.\n */\npublic static final int RANGE_WEEK_RELATIVE = 3;\n/**\n * A week range, centered around the day focused.\n */\npublic static final int RANGE_WEEK_CENTER = 4;\n/**\n * A month range, the week starting on Sunday.\n */\npublic static final int RANGE_MONTH_SUNDAY = 5;\n/**\n * A month range, the week starting on Monday.\n */\npublic static final int RANGE_MONTH_MONDAY = 6;",
        "Method_statement": "truncate(final Calendar date, final int field)",
        "Method_name": "truncate",
        "Class_declaration": "public class DateUtils {\n",
        "constructors": "public DateUtils() {\n    super();\n}",
        "all_method_signature": "public DateUtils();\npublic static boolean isSameDay(final Date date1, final Date date2);\npublic static boolean isSameDay(final Calendar cal1, final Calendar cal2);\npublic static boolean isSameInstant(final Date date1, final Date date2);\npublic static boolean isSameInstant(final Calendar cal1, final Calendar cal2);\npublic static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2);\npublic static Date parseDate(final String str, final String... parsePatterns) throws ParseException;\npublic static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException;\npublic static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException;\npublic static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException;\nprivate static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException;\npublic static Date addYears(final Date date, final int amount);\npublic static Date addMonths(final Date date, final int amount);\npublic static Date addWeeks(final Date date, final int amount);\npublic static Date addDays(final Date date, final int amount);\npublic static Date addHours(final Date date, final int amount);\npublic static Date addMinutes(final Date date, final int amount);\npublic static Date addSeconds(final Date date, final int amount);\npublic static Date addMilliseconds(final Date date, final int amount);\nprivate static Date add(final Date date, final int calendarField, final int amount);\npublic static Date setYears(final Date date, final int amount);\npublic static Date setMonths(final Date date, final int amount);\npublic static Date setDays(final Date date, final int amount);\npublic static Date setHours(final Date date, final int amount);\npublic static Date setMinutes(final Date date, final int amount);\npublic static Date setSeconds(final Date date, final int amount);\npublic static Date setMilliseconds(final Date date, final int amount);\nprivate static Date set(final Date date, final int calendarField, final int amount);\npublic static Calendar toCalendar(final Date date);\npublic static Calendar toCalendar(final Date date, final TimeZone tz);\npublic static Date round(final Date date, final int field);\npublic static Calendar round(final Calendar date, final int field);\npublic static Date round(final Object date, final int field);\npublic static Date truncate(final Date date, final int field);\npublic static Calendar truncate(final Calendar date, final int field);\npublic static Date truncate(final Object date, final int field);\npublic static Date ceiling(final Date date, final int field);\npublic static Calendar ceiling(final Calendar date, final int field);\npublic static Date ceiling(final Object date, final int field);\nprivate static void modify(final Calendar val, final int field, final ModifyType modType);\npublic static Iterator<Calendar> iterator(final Date focus, final int rangeStyle);\npublic static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle);\npublic static Iterator<?> iterator(final Object focus, final int rangeStyle);\npublic static long getFragmentInMilliseconds(final Date date, final int fragment);\npublic static long getFragmentInSeconds(final Date date, final int fragment);\npublic static long getFragmentInMinutes(final Date date, final int fragment);\npublic static long getFragmentInHours(final Date date, final int fragment);\npublic static long getFragmentInDays(final Date date, final int fragment);\npublic static long getFragmentInMilliseconds(final Calendar calendar, final int fragment);\npublic static long getFragmentInSeconds(final Calendar calendar, final int fragment);\npublic static long getFragmentInMinutes(final Calendar calendar, final int fragment);\npublic static long getFragmentInHours(final Calendar calendar, final int fragment);\npublic static long getFragmentInDays(final Calendar calendar, final int fragment);\nprivate static long getFragment(final Date date, final int fragment, final TimeUnit unit);\nprivate static long getFragment(final Calendar calendar, final int fragment, final TimeUnit unit);\npublic static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field);\npublic static boolean truncatedEquals(final Date date1, final Date date2, final int field);\npublic static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field);\npublic static int truncatedCompareTo(final Date date1, final Date date2, final int field);\nprivate static void validateDateNotNull(final Date date);",
        "Class_name": "DateUtils",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/time/DateUtils###truncate",
        "Parameter_num": "2",
        "all_Import_statements": "import java.text.ParseException;\n\nimport java.text.ParsePosition;\n\nimport java.util.Calendar;\n\nimport java.util.Date;\n\nimport java.util.Iterator;\n\nimport java.util.Locale;\n\nimport java.util.NoSuchElementException;\n\nimport java.util.TimeZone;\n\nimport java.util.concurrent.TimeUnit;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n\nimport org.apache.commons.lang3.Validate;\n",
        "comment": "\n     * <p>Truncates a date, leaving the field specified as the most\n     * significant field.</p>\n     *\n     * <p>For example, if you had the date-time of 28 Mar 2002\n     * 13:45:01.231, if you passed with HOUR, it would return 28 Mar\n     * 2002 13:00:00.000.  If this was passed with MONTH, it would\n     * return 1 Mar 2002 0:00:00.000.</p>\n     *\n     * @param date  the date to work with, not null\n     * @param field  the field from {@code Calendar} or <code>SEMI_MONTH</code>\n     * @return the different truncated date, not null\n     * @throws IllegalArgumentException if the date is <code>null</code>\n     * @throws ArithmeticException if the year is over 280 million\n     ",
        "packageName": "org.apache.commons.lang3.time",
        "method_signature": "public static Calendar truncate(final Calendar date, final int field);",
        "Junit_version": "4",
        "returnType": "Calendar"
    },
    {
        "Method_body": "static Token[] lexx(final String format) {\n    final ArrayList<Token> list = new ArrayList<>(format.length());\n    boolean inLiteral = false;\n    StringBuilder buffer = null;\n    Token previous = null;\n    for (int i = 0; i < format.length(); i++) {\n        final char ch = format.charAt(i);\n        if (inLiteral && ch != '\\'') {\n            buffer.append(ch);\n            continue;\n        }\n        Object value = null;\n        switch(ch) {\n            case '\\'':\n                if (inLiteral) {\n                    buffer = null;\n                    inLiteral = false;\n                } else {\n                    buffer = new StringBuilder();\n                    list.add(new Token(buffer));\n                    inLiteral = true;\n                }\n                break;\n            case 'y':\n                value = y;\n                break;\n            case 'M':\n                value = M;\n                break;\n            case 'd':\n                value = d;\n                break;\n            case 'H':\n                value = H;\n                break;\n            case 'm':\n                value = m;\n                break;\n            case 's':\n                value = s;\n                break;\n            case 'S':\n                value = S;\n                break;\n            default:\n                if (buffer == null) {\n                    buffer = new StringBuilder();\n                    list.add(new Token(buffer));\n                }\n                buffer.append(ch);\n        }\n        if (value != null) {\n            if (previous != null && previous.getValue().equals(value)) {\n                previous.increment();\n            } else {\n                final Token token = new Token(value);\n                list.add(token);\n                previous = token;\n            }\n            buffer = null;\n        }\n    }\n    if (inLiteral) {\n        throw new IllegalArgumentException(\"Unmatched quote in format: \" + format);\n    }\n    return list.toArray(new Token[list.size()]);\n}",
        "all_field_declaration": "/**\n * <p>Pattern used with <code>FastDateFormat</code> and <code>SimpleDateFormat</code>\n * for the ISO 8601 period format used in durations.</p>\n *\n * @see org.apache.commons.lang3.time.FastDateFormat\n * @see java.text.SimpleDateFormat\n */\npublic static final String ISO_EXTENDED_FORMAT_PATTERN = \"'P'yyyy'Y'M'M'd'DT'H'H'm'M's.SSS'S'\";\nstatic final Object y = \"y\";\nstatic final Object M = \"M\";\nstatic final Object d = \"d\";\nstatic final Object H = \"H\";\nstatic final Object m = \"m\";\nstatic final Object s = \"s\";\nstatic final Object S = \"S\";",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "7",
        "Filed": "static final Object y = \"y\";static final Object M = \"M\";static final Object d = \"d\";static final Object H = \"H\";static final Object m = \"m\";static final Object s = \"s\";static final Object S = \"S\";",
        "Parameter_type": "String",
        "Import_statements": "import java.util.ArrayList;\n",
        "public_method_signature": "public DurationFormatUtils();\npublic static String formatDurationHMS(final long durationMillis);\npublic static String formatDurationISO(final long durationMillis);\npublic static String formatDuration(final long durationMillis, final String format);\npublic static String formatDuration(final long durationMillis, final String format, final boolean padWithZeros);\npublic static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements);\npublic static String formatPeriodISO(final long startMillis, final long endMillis);\npublic static String formatPeriod(final long startMillis, final long endMillis, final String format);\npublic static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone);",
        "public_field": "/**\n * <p>Pattern used with <code>FastDateFormat</code> and <code>SimpleDateFormat</code>\n * for the ISO 8601 period format used in durations.</p>\n *\n * @see org.apache.commons.lang3.time.FastDateFormat\n * @see java.text.SimpleDateFormat\n */\npublic static final String ISO_EXTENDED_FORMAT_PATTERN = \"'P'yyyy'Y'M'M'd'DT'H'H'm'M's.SSS'S'\";",
        "Method_statement": "lexx(final String format)",
        "Method_name": "lexx",
        "Class_declaration": "public class DurationFormatUtils {\n",
        "constructors": "public DurationFormatUtils() {\n    super();\n}",
        "all_method_signature": "public DurationFormatUtils();\npublic static String formatDurationHMS(final long durationMillis);\npublic static String formatDurationISO(final long durationMillis);\npublic static String formatDuration(final long durationMillis, final String format);\npublic static String formatDuration(final long durationMillis, final String format, final boolean padWithZeros);\npublic static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements);\npublic static String formatPeriodISO(final long startMillis, final long endMillis);\npublic static String formatPeriod(final long startMillis, final long endMillis, final String format);\npublic static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone);\n static String format(final Token[] tokens, final long years, final long months, final long days, final long hours, final long minutes, final long seconds, final long milliseconds, final boolean padWithZeros);\nprivate static String paddedValue(final long value, final boolean padWithZeros, final int count);\n static Token[] lexx(final String format);",
        "Class_name": "DurationFormatUtils",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/time/DurationFormatUtils###lexx",
        "Parameter_num": "1",
        "all_Import_statements": "import java.util.ArrayList;\n\nimport java.util.Calendar;\n\nimport java.util.Date;\n\nimport java.util.GregorianCalendar;\n\nimport java.util.TimeZone;\n\nimport org.apache.commons.lang3.StringUtils;\n\nimport org.apache.commons.lang3.Validate;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
        "comment": "\n     * Parses a classic date format string into Tokens\n     *\n     * @param format  the format to parse, not null\n     * @return array of Token[]\n     ",
        "packageName": "org.apache.commons.lang3.time",
        "method_signature": " static Token[] lexx(final String format);",
        "Junit_version": "4",
        "returnType": "Token[]"
    },
    {
        "Method_body": "@Override\npublic boolean equals(final Object obj) {\n    if (!(obj instanceof FastDatePrinter)) {\n        return false;\n    }\n    final FastDatePrinter other = (FastDatePrinter) obj;\n    return mPattern.equals(other.mPattern) && mTimeZone.equals(other.mTimeZone) && mLocale.equals(other.mLocale);\n}",
        "all_field_declaration": "// A lot of the speed in this class comes from caching, but some comes\n// from the special int to StringBuffer conversion.\n// \n// The following produces a padded 2 digit number:\n// buffer.append((char)(value / 10 + '0'));\n// buffer.append((char)(value % 10 + '0'));\n// \n// Note that the fastest append to StringBuffer is a single char (used here).\n// Note that Integer.toString() is not called, the conversion is simply\n// taking the value and adding (mathematically) the ASCII value for '0'.\n// So, don't change this code! It works and is very fast.\n/**\n * Required for serialization support.\n *\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = 1L;\n/**\n * FULL locale dependent date or time style.\n */\npublic static final int FULL = DateFormat.FULL;\n/**\n * LONG locale dependent date or time style.\n */\npublic static final int LONG = DateFormat.LONG;\n/**\n * MEDIUM locale dependent date or time style.\n */\npublic static final int MEDIUM = DateFormat.MEDIUM;\n/**\n * SHORT locale dependent date or time style.\n */\npublic static final int SHORT = DateFormat.SHORT;\n/**\n * The pattern.\n */\nprivate final String mPattern;\n/**\n * The time zone.\n */\nprivate final TimeZone mTimeZone;\n/**\n * The locale.\n */\nprivate final Locale mLocale;\n/**\n * The parsed rules.\n */\nprivate transient Rule[] mRules;\n/**\n * The estimated maximum length.\n */\nprivate transient int mMaxLengthEstimate;\nprivate static final int MAX_DIGITS = 10;\nprivate static final ConcurrentMap<TimeZoneDisplayKey, String> cTimeZoneDisplayCache = new ConcurrentHashMap<>(7);",
        "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
        "lineNumbers": "3",
        "Filed": "private final String mPattern;private final TimeZone mTimeZone;private final Locale mLocale;",
        "Parameter_type": "Object",
        "Import_statements": "import java.util.Date;\nimport java.util.Locale;\nimport java.util.TimeZone;\n",
        "public_method_signature": "public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos);\npublic String format(final long millis);\npublic String format(final Date date);\npublic String format(final Calendar calendar);\npublic StringBuffer format(final long millis, final StringBuffer buf);\npublic StringBuffer format(final Date date, final StringBuffer buf);\npublic StringBuffer format(final Calendar calendar, final StringBuffer buf);\npublic B format(final long millis, final B buf);\npublic B format(final Date date, final B buf);\npublic B format(Calendar calendar, final B buf);\npublic String getPattern();\npublic TimeZone getTimeZone();\npublic Locale getLocale();\npublic int getMaxLengthEstimate();\npublic boolean equals(final Object obj);\npublic int hashCode();\npublic String toString();",
        "public_field": "/**\n * FULL locale dependent date or time style.\n */\npublic static final int FULL = DateFormat.FULL;\n/**\n * LONG locale dependent date or time style.\n */\npublic static final int LONG = DateFormat.LONG;\n/**\n * MEDIUM locale dependent date or time style.\n */\npublic static final int MEDIUM = DateFormat.MEDIUM;\n/**\n * SHORT locale dependent date or time style.\n */\npublic static final int SHORT = DateFormat.SHORT;",
        "Method_statement": "equals(final Object obj)",
        "Method_name": "equals",
        "Class_declaration": "public class FastDatePrinter {\n",
        "constructors": "protected FastDatePrinter(final String pattern, final TimeZone timeZone, final Locale locale) {\n    mPattern = pattern;\n    mTimeZone = timeZone;\n    mLocale = locale;\n    init();\n}",
        "all_method_signature": "protected FastDatePrinter(final String pattern, final TimeZone timeZone, final Locale locale);\nprivate void init();\nprotected List<Rule> parsePattern();\nprotected String parseToken(final String pattern, final int[] indexRef);\nprotected NumberRule selectNumberRule(final int field, final int padding);\npublic StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos);\n String format(final Object obj);\npublic String format(final long millis);\nprivate String applyRulesToString(final Calendar c);\nprivate Calendar newCalendar();\npublic String format(final Date date);\npublic String format(final Calendar calendar);\npublic StringBuffer format(final long millis, final StringBuffer buf);\npublic StringBuffer format(final Date date, final StringBuffer buf);\npublic StringBuffer format(final Calendar calendar, final StringBuffer buf);\npublic B format(final long millis, final B buf);\npublic B format(final Date date, final B buf);\npublic B format(Calendar calendar, final B buf);\nprotected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf);\nprivate B applyRules(final Calendar calendar, final B buf);\npublic String getPattern();\npublic TimeZone getTimeZone();\npublic Locale getLocale();\npublic int getMaxLengthEstimate();\npublic boolean equals(final Object obj);\npublic int hashCode();\npublic String toString();\nprivate void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException;\nprivate static void appendDigits(final Appendable buffer, final int value) throws IOException;\nprivate static void appendFullDigits(final Appendable buffer, int value, int minFieldWidth) throws IOException;\n static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale);",
        "Class_name": "FastDatePrinter",
        "project_path": "ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/time/FastDatePrinter###equals",
        "Parameter_num": "1",
        "all_Import_statements": "import java.io.IOException;\n\nimport java.io.ObjectInputStream;\n\nimport java.io.Serializable;\n\nimport java.text.DateFormat;\n\nimport java.text.DateFormatSymbols;\n\nimport java.text.FieldPosition;\n\nimport java.util.ArrayList;\n\nimport java.util.Calendar;\n\nimport java.util.Date;\n\nimport java.util.List;\n\nimport java.util.Locale;\n\nimport java.util.TimeZone;\n\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport java.util.concurrent.ConcurrentMap;\n\nimport org.apache.commons.lang3.exception.ExceptionUtils;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
        "comment": "\n     * <p>Compares two objects for equality.</p>\n     *\n     * @param obj  the object to compare to\n     * @return {@code true} if equal\n     ",
        "packageName": "org.apache.commons.lang3.time",
        "method_signature": "public boolean equals(final Object obj);",
        "Junit_version": "4",
        "returnType": "boolean"
    }
]