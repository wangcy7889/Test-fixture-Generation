import json
import os
import re
import shutil
import subprocess
import time
import argparse
from openai import OpenAI

input_folder = 'classified_results/yes'
output_folder = 'generated_calls'
output_folder_tmp = 'generated_calls_tmp'

CONFIG_FILE = "clear_env_config.json"


def parse_args():
    parser = argparse.ArgumentParser(description='Generate invocation examples')
    parser.add_argument('--api_key', required=True, help='API key')
    parser.add_argument('--base_url', required=True, help='API base URL')
    parser.add_argument('--model', required=True, help='Model name to use for generation')
    return parser.parse_args()


def initialize_config():
    script_dir = os.path.dirname(os.path.abspath(__file__))

    all_items = os.listdir(script_dir)
    dirs = {item for item in all_items if os.path.isdir(os.path.join(script_dir, item))}
    files = {item for item in all_items if os.path.isfile(os.path.join(script_dir, item))}

    files.discard(os.path.basename(__file__))
    files.discard(CONFIG_FILE)

    config = {
        "keep_dirs": list(dirs),
        "keep_files": list(files)
    }

    with open(CONFIG_FILE, "w", encoding='utf-8') as f:
        json.dump(config, f, indent=4)

    return dirs, files


def load_config():
    try:
        with open(CONFIG_FILE, "r", encoding='utf-8') as f:
            config = json.load(f)
        return set(config["keep_dirs"]), set(config["keep_files"])
    except FileNotFoundError:
        return initialize_config()


def clear_env():
    keep_dirs, keep_files = load_config()

    script_dir = os.path.dirname(os.path.abspath(__file__))

    for item in os.listdir(script_dir):
        item_path = os.path.join(script_dir, item)

        if item == CONFIG_FILE or item == os.path.basename(__file__):
            continue

        if os.path.isdir(item_path):
            if item not in keep_dirs:
                try:
                    shutil.rmtree(item_path)
                    print(f"folder deleted: {item}")
                except Exception as e:
                    print(f"Error deleting folder {item}: {e}")

        elif os.path.isfile(item_path):
            if item not in keep_files:
                try:
                    os.remove(item_path)
                    print(f"folder deleted: {item}")
                except Exception as e:
                    print(f"Error deleting folder {item}: {e}")


def generate_test_input(original_code, previous_attempt=None, error_message=None, model_name=None):
    if model_name is None:
        raise Exception("model name not specified")
    prompt = f"""
    Generate a correct function call example for the following Python function.
    Ensure the function is already provided before the call,so do not show or import the function code.

    Function code:
    ```python
    {original_code}
    ```
    """

    if previous_attempt and error_message:
        prompt += f"""
        Previous attempt (generated by you):
        ```python
        {previous_attempt}
        ```

        Execution result:
        ```
        {error_message} 
        ``` 
        **If this error is caused by web link or services, database, or external dependencies, 
        then introduce the mock method in the next instance generation. If not, 
        there's no need for a mock.
        If necessary, use 'from unittest import mock' uniformly.**
        Based on that, please generate a corrected call, and ensure all required imports and context are included.
        """
    try:
        response = client.chat.completions.create(
            model=model_name,
            messages=[
                {"role": "system", "content": "You are a helpful assistant."},
                {"role": "user", "content": prompt}
            ],
            temperature=0
        )

        content = response.choices[0].message.content
        pattern = r"```(?:python|py)?\n(.*?)\n```"
        matches = re.findall(pattern, content, re.DOTALL)
        if matches:
            return matches[0].strip()
        return content.strip()

    except Exception as e:
        print(f"Error calling the LLM: {e}")
        return None


def save_final_call(filename, original_code, call_example):
    os.makedirs(output_folder, exist_ok=True)
    output_path = os.path.join(output_folder, filename)

    with open(output_path, 'w', encoding='utf-8') as f:
        f.write("# focal method:\n")
        f.write(original_code)
        f.write("\n\n# call example:\n")
        f.write(call_example)
        f.write("\n")


def process_file(filename, model_name):
    global flg
    output_path = os.path.join(output_folder, filename)
    if os.path.exists(output_path):
        print(f"The file {filename} already has a successfully generated call example, skip it")
        return True
    filepath = os.path.join(input_folder, filename)

    with open(filepath, 'r', encoding='utf-8') as f:
        original_code = f.read()

    last_error = None
    success = False
    previous_attempt = ''


    for attempt in range(1, 4):
        print(f"Process file {filename}, attempt {attempt} th time")
        clear_env()

        test_call = generate_test_input(original_code, previous_attempt, last_error, model_name)
        if not test_call:
            print(f"Unable to generate test call for {filename}")
            continue

        previous_attempt = test_call
        temp_file = os.path.join(output_folder_tmp, filename)

        with open(temp_file, 'w', encoding='utf-8') as f:
            f.write(original_code + "\n")
            f.write(test_call + "\n")

        try:
            popen = subprocess.Popen(
                ['python', temp_file],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                encoding='utf-8'
            )

            start_time = time.time()
            while True:
                if popen.poll() is not None:
                    break
                if time.time() - start_time > 60:
                    popen.kill()
                    raise subprocess.TimeoutExpired(cmd=popen.args, timeout=60)
                time.sleep(0.1)

            stdout, stderr = popen.communicate()
            output = (stdout + stderr).lower()

            error_keywords = ['warn', 'error', 'err', 'fail', "working outside of"]
            has_error = any(keyword in output for keyword in error_keywords)

            if popen.returncode == 0 and not has_error:
                print(f"Successfully generated a call example for {filename}")
                save_final_call(filename, original_code, test_call)
                success = True
                return True

            last_error = f"Return code: {popen.returncode}\nStdout:\n{stdout}\nStderr:\n{stderr}"
            print(f"The {attempt} attempt failed: {stderr or stdout}")

        except Exception as e:
            last_error = f"Unexpected error: {str(e)}"
            print(f"{attempt} failed: {str (e)}")

    return success


def main():
    args = parse_args()

    global client
    client = OpenAI(api_key=args.api_key, base_url=args.base_url)

    os.makedirs(output_folder, exist_ok=True)
    os.makedirs(output_folder_tmp, exist_ok=True)

    for filename in os.listdir(input_folder):
        if filename.endswith('.py'):
            process_file(filename, args.model)


if __name__ == "__main__":
    if os.path.exists(CONFIG_FILE):
        os.remove(CONFIG_FILE)
    main()